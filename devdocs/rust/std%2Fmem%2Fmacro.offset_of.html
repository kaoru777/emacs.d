<h1 class="main-heading">Macro std::mem::offset_of</h1>
<pre class="rust item-decl" data-language="rust">pub macro offset_of($Container:ty, $($fields:tt).+ $(,)?) {
    ...
}</pre>
<span class="item-info"><div class="stab unstable">
<span class="emoji">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>offset_of</code> <a href="https://github.com/rust-lang/rust/issues/106655">#106655</a>)</span>
</div></span><p>Expands to the offset in bytes of a field from the beginning of the given type.</p> <p>Only structs, unions and tuples are supported.</p> <p>Nested field accesses may be used, but not array indexes like in <code>C</code>â€™s <code>offsetof</code>.</p> <p>Note that the output of this macro is not stable, except for <code>#[repr(C)]</code> types.</p> <h2 id="examples">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(offset_of)]

use std::mem;
#[repr(C)]
struct FieldStruct {
    first: u8,
    second: u16,
    third: u8
}

assert_eq!(mem::offset_of!(FieldStruct, first), 0);
assert_eq!(mem::offset_of!(FieldStruct, second), 2);
assert_eq!(mem::offset_of!(FieldStruct, third), 4);

#[repr(C)]
struct NestedA {
    b: NestedB
}

#[repr(C)]
struct NestedB(u8);

assert_eq!(mem::offset_of!(NestedA, b.0), 0);</pre></div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/std/mem/macro.offset_of.html" class="_attribution-link">https://doc.rust-lang.org/std/mem/macro.offset_of.html</a>
  </p>
</div>
