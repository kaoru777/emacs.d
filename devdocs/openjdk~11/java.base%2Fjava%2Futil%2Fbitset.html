  <main role="main">    <h1>Class BitSet</h1>   <ul class="inheritance"> <li><a href="../lang/object">java.lang.Object</a></li> <li> <ul class="inheritance"> <li>java.util.BitSet</li> </ul> </li> </ul>   <dl> <dt>All Implemented Interfaces:</dt> <dd>
<code><a href="../io/serializable">Serializable</a></code>, <code><a href="../lang/cloneable">Cloneable</a></code>
</dd> </dl>  <pre data-language="java">public class BitSet
extends Object
implements Cloneable, Serializable</pre> <div>
<p>This class implements a vector of bits that grows as needed. Each component of the bit set has a <code>boolean</code> value. The bits of a <code>BitSet</code> are indexed by nonnegative integers. Individual indexed bits can be examined, set, or cleared. One <code>BitSet</code> may be used to modify the contents of another <code>BitSet</code> through logical AND, logical inclusive OR, and logical exclusive OR operations. </p>
<p>By default, all bits in the set initially have the value <code>false</code>. </p>
<p>Every bit set has a current size, which is the number of bits of space currently in use by the bit set. Note that the size is related to the implementation of a bit set, so it may change with implementation. The length of a bit set relates to logical length of a bit set and is defined independently of implementation. </p>
<p>Unless otherwise noted, passing a null parameter to any of the methods in a <code>BitSet</code> will result in a <code>NullPointerException</code>. </p>
<p>A <code>BitSet</code> is not safe for multithreaded use without external synchronization.</p>
</div> <dl> <dt>Since:</dt> <dd>1.0</dd> <dt>See Also:</dt> <dd><a href="https://docs.oracle.com/en/java/javase/11/docs/api/serialized-form.html#java.util.BitSet">Serialized Form</a></dd> </dl>      <section role="region">  <h2 id="constructor.summary">Constructors</h2> <table>  <tr> <th scope="col">Constructor</th> <th scope="col">Description</th> </tr> <tr> <th scope="row"><code><a href="#%3Cinit%3E()">BitSet</a>()</code></th> <td> <p>Creates a new bit set.</p> </td> </tr> <tr> <th scope="row"><code><a href="#%3Cinit%3E(int)">BitSet</a>​(int nbits)</code></th> <td> <p>Creates a bit set whose initial size is large enough to explicitly represent bits with indices in the range <code>0</code> through <code>nbits-1</code>.</p> </td> </tr> </table>  </section>  <section role="region">  <h2 id="method.summary">Methods</h2> <table>  <tr> <th scope="col">Modifier and Type</th> <th scope="col">Method</th> <th scope="col">Description</th> </tr> <tr id="i0"> <td><code>void</code></td> <th scope="row"><code><a href="#and(java.util.BitSet)">and</a>​(<a href="bitset">BitSet</a> set)</code></th> <td> <p>Performs a logical <b>AND</b> of this target bit set with the argument bit set.</p> </td> </tr> <tr id="i1"> <td><code>void</code></td> <th scope="row"><code><a href="#andNot(java.util.BitSet)">andNot</a>​(<a href="bitset">BitSet</a> set)</code></th> <td> <p>Clears all of the bits in this <code>BitSet</code> whose corresponding bit is set in the specified <code>BitSet</code>.</p> </td> </tr> <tr id="i2"> <td><code>int</code></td> <th scope="row"><code><a href="#cardinality()">cardinality</a>()</code></th> <td> <p>Returns the number of bits set to <code>true</code> in this <code>BitSet</code>.</p> </td> </tr> <tr id="i3"> <td><code>void</code></td> <th scope="row"><code><a href="#clear()">clear</a>()</code></th> <td> <p>Sets all of the bits in this BitSet to <code>false</code>.</p> </td> </tr> <tr id="i4"> <td><code>void</code></td> <th scope="row"><code><a href="#clear(int)">clear</a>​(int bitIndex)</code></th> <td> <p>Sets the bit specified by the index to <code>false</code>.</p> </td> </tr> <tr id="i5"> <td><code>void</code></td> <th scope="row"><code><a href="#clear(int,int)">clear</a>​(int fromIndex,
     int toIndex)</code></th> <td> <p>Sets the bits from the specified <code>fromIndex</code> (inclusive) to the specified <code>toIndex</code> (exclusive) to <code>false</code>.</p> </td> </tr> <tr id="i6"> <td><code><a href="../lang/object">Object</a></code></td> <th scope="row"><code><a href="#clone()">clone</a>()</code></th> <td> <p>Cloning this <code>BitSet</code> produces a new <code>BitSet</code> that is equal to it.</p> </td> </tr> <tr id="i7"> <td><code>boolean</code></td> <th scope="row"><code><a href="#equals(java.lang.Object)">equals</a>​(<a href="../lang/object">Object</a> obj)</code></th> <td> <p>Compares this object against the specified object.</p> </td> </tr> <tr id="i8"> <td><code>void</code></td> <th scope="row"><code><a href="#flip(int)">flip</a>​(int bitIndex)</code></th> <td> <p>Sets the bit at the specified index to the complement of its current value.</p> </td> </tr> <tr id="i9"> <td><code>void</code></td> <th scope="row"><code><a href="#flip(int,int)">flip</a>​(int fromIndex,
    int toIndex)</code></th> <td> <p>Sets each bit from the specified <code>fromIndex</code> (inclusive) to the specified <code>toIndex</code> (exclusive) to the complement of its current value.</p> </td> </tr> <tr id="i10"> <td><code>boolean</code></td> <th scope="row"><code><a href="#get(int)">get</a>​(int bitIndex)</code></th> <td> <p>Returns the value of the bit with the specified index.</p> </td> </tr> <tr id="i11"> <td><code><a href="bitset">BitSet</a></code></td> <th scope="row"><code><a href="#get(int,int)">get</a>​(int fromIndex,
   int toIndex)</code></th> <td> <p>Returns a new <code>BitSet</code> composed of bits from this <code>BitSet</code> from <code>fromIndex</code> (inclusive) to <code>toIndex</code> (exclusive).</p> </td> </tr> <tr id="i12"> <td><code>int</code></td> <th scope="row"><code><a href="#hashCode()">hashCode</a>()</code></th> <td> <p>Returns the hash code value for this bit set.</p> </td> </tr> <tr id="i13"> <td><code>boolean</code></td> <th scope="row"><code><a href="#intersects(java.util.BitSet)">intersects</a>​(<a href="bitset">BitSet</a> set)</code></th> <td> <p>Returns true if the specified <code>BitSet</code> has any bits set to <code>true</code> that are also set to <code>true</code> in this <code>BitSet</code>.</p> </td> </tr> <tr id="i14"> <td><code>boolean</code></td> <th scope="row"><code><a href="#isEmpty()">isEmpty</a>()</code></th> <td> <p>Returns true if this <code>BitSet</code> contains no bits that are set to <code>true</code>.</p> </td> </tr> <tr id="i15"> <td><code>int</code></td> <th scope="row"><code><a href="#length()">length</a>()</code></th> <td> <p>Returns the "logical size" of this <code>BitSet</code>: the index of the highest set bit in the <code>BitSet</code> plus one.</p> </td> </tr> <tr id="i16"> <td><code>int</code></td> <th scope="row"><code><a href="#nextClearBit(int)">nextClearBit</a>​(int fromIndex)</code></th> <td> <p>Returns the index of the first bit that is set to <code>false</code> that occurs on or after the specified starting index.</p> </td> </tr> <tr id="i17"> <td><code>int</code></td> <th scope="row"><code><a href="#nextSetBit(int)">nextSetBit</a>​(int fromIndex)</code></th> <td> <p>Returns the index of the first bit that is set to <code>true</code> that occurs on or after the specified starting index.</p> </td> </tr> <tr id="i18"> <td><code>void</code></td> <th scope="row"><code><a href="#or(java.util.BitSet)">or</a>​(<a href="bitset">BitSet</a> set)</code></th> <td> <p>Performs a logical <b>OR</b> of this bit set with the bit set argument.</p> </td> </tr> <tr id="i19"> <td><code>int</code></td> <th scope="row"><code><a href="#previousClearBit(int)">previousClearBit</a>​(int fromIndex)</code></th> <td> <p>Returns the index of the nearest bit that is set to <code>false</code> that occurs on or before the specified starting index.</p> </td> </tr> <tr id="i20"> <td><code>int</code></td> <th scope="row"><code><a href="#previousSetBit(int)">previousSetBit</a>​(int fromIndex)</code></th> <td> <p>Returns the index of the nearest bit that is set to <code>true</code> that occurs on or before the specified starting index.</p> </td> </tr> <tr id="i21"> <td><code>void</code></td> <th scope="row"><code><a href="#set(int)">set</a>​(int bitIndex)</code></th> <td> <p>Sets the bit at the specified index to <code>true</code>.</p> </td> </tr> <tr id="i22"> <td><code>void</code></td> <th scope="row"><code><a href="#set(int,boolean)">set</a>​(int bitIndex,
   boolean value)</code></th> <td> <p>Sets the bit at the specified index to the specified value.</p> </td> </tr> <tr id="i23"> <td><code>void</code></td> <th scope="row"><code><a href="#set(int,int)">set</a>​(int fromIndex,
   int toIndex)</code></th> <td> <p>Sets the bits from the specified <code>fromIndex</code> (inclusive) to the specified <code>toIndex</code> (exclusive) to <code>true</code>.</p> </td> </tr> <tr id="i24"> <td><code>void</code></td> <th scope="row"><code><a href="#set(int,int,boolean)">set</a>​(int fromIndex,
   int toIndex,
   boolean value)</code></th> <td> <p>Sets the bits from the specified <code>fromIndex</code> (inclusive) to the specified <code>toIndex</code> (exclusive) to the specified value.</p> </td> </tr> <tr id="i25"> <td><code>int</code></td> <th scope="row"><code><a href="#size()">size</a>()</code></th> <td> <p>Returns the number of bits of space actually in use by this <code>BitSet</code> to represent bit values.</p> </td> </tr> <tr id="i26"> <td><code><a href="stream/intstream">IntStream</a></code></td> <th scope="row"><code><a href="#stream()">stream</a>()</code></th> <td> <p>Returns a stream of indices for which this <code>BitSet</code> contains a bit in the set state.</p> </td> </tr> <tr id="i27"> <td><code>byte[]</code></td> <th scope="row"><code><a href="#toByteArray()">toByteArray</a>()</code></th> <td> <p>Returns a new byte array containing all the bits in this bit set.</p> </td> </tr> <tr id="i28"> <td><code>long[]</code></td> <th scope="row"><code><a href="#toLongArray()">toLongArray</a>()</code></th> <td> <p>Returns a new long array containing all the bits in this bit set.</p> </td> </tr> <tr id="i29"> <td><code><a href="../lang/string">String</a></code></td> <th scope="row"><code><a href="#toString()">toString</a>()</code></th> <td> <p>Returns a string representation of this bit set.</p> </td> </tr> <tr id="i30"> <td><code>static <a href="bitset">BitSet</a></code></td> <th scope="row"><code><a href="#valueOf(byte%5B%5D)">valueOf</a>​(byte[] bytes)</code></th> <td> <p>Returns a new bit set containing all the bits in the given byte array.</p> </td> </tr> <tr id="i31"> <td><code>static <a href="bitset">BitSet</a></code></td> <th scope="row"><code><a href="#valueOf(long%5B%5D)">valueOf</a>​(long[] longs)</code></th> <td> <p>Returns a new bit set containing all the bits in the given long array.</p> </td> </tr> <tr id="i32"> <td><code>static <a href="bitset">BitSet</a></code></td> <th scope="row"><code><a href="#valueOf(java.nio.ByteBuffer)">valueOf</a>​(<a href="../nio/bytebuffer">ByteBuffer</a> bb)</code></th> <td> <p>Returns a new bit set containing all the bits in the given byte buffer between its position and limit.</p> </td> </tr> <tr id="i33"> <td><code>static <a href="bitset">BitSet</a></code></td> <th scope="row"><code><a href="#valueOf(java.nio.LongBuffer)">valueOf</a>​(<a href="../nio/longbuffer">LongBuffer</a> lb)</code></th> <td> <p>Returns a new bit set containing all the bits in the given long buffer between its position and limit.</p> </td> </tr> <tr id="i34"> <td><code>void</code></td> <th scope="row"><code><a href="#xor(java.util.BitSet)">xor</a>​(<a href="bitset">BitSet</a> set)</code></th> <td> <p>Performs a logical <b>XOR</b> of this bit set with the bit set argument.</p> </td> </tr> </table>  <h2 id="methods.inherited.from.class.java.lang.Object">Methods declared in class java.lang.<a href="../lang/object">Object</a>
</h2> <code><a href="../lang/object#finalize()">finalize</a>, <a href="../lang/object#getClass()">getClass</a>, <a href="../lang/object#notify()">notify</a>, <a href="../lang/object#notifyAll()">notifyAll</a>, <a href="../lang/object#wait()">wait</a>, <a href="../lang/object#wait(long)">wait</a>, <a href="../lang/object#wait(long,int)">wait</a></code>  </section>   <div>   <section role="region">  <h2 id="constructor.detail">Constructors</h2>   <h3 id="&lt;init&gt;()">BitSet</h3> <pre data-language="java">public BitSet()</pre> <p>Creates a new bit set. All bits are initially <code>false</code>.</p>    <h3 id="&lt;init&gt;(int)">BitSet</h3> <pre data-language="java">public BitSet(int nbits)</pre> <p>Creates a bit set whose initial size is large enough to explicitly represent bits with indices in the range <code>0</code> through <code>nbits-1</code>. All bits are initially <code>false</code>.</p> <dl> <dt>Parameters:</dt> <dd>
<code>nbits</code> - the initial size of the bit set</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/negativearraysizeexception">NegativeArraySizeException</a></code> - if the specified initial size is negative</dd> </dl>   </section>  <section role="region">  <h2 id="method.detail">Methods</h2>   <h3 id="valueOf(long[])">valueOf</h3> <pre data-language="java">public static BitSet valueOf(long[] longs)</pre> <div>
<p>Returns a new bit set containing all the bits in the given long array. </p>
<p>More precisely, <br><code>BitSet.valueOf(longs).get(n) == ((longs[n/64] &amp; (1L&lt;&lt;(n%64))) != 0)</code> <br>for all <code>n &lt; 64 * longs.length</code>. </p>
<p>This method is equivalent to <code>BitSet.valueOf(LongBuffer.wrap(longs))</code>.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>longs</code> - a long array containing a little-endian representation of a sequence of bits to be used as the initial bits of the new bit set</dd> <dt>Returns:</dt> <dd>a <code>BitSet</code> containing all the bits in the long array</dd> <dt>Since:</dt> <dd>1.7</dd> </dl>    <h3 id="valueOf(java.nio.LongBuffer)">valueOf</h3> <pre data-language="java">public static BitSet valueOf(LongBuffer lb)</pre> <div>
<p>Returns a new bit set containing all the bits in the given long buffer between its position and limit. </p>
<p>More precisely, <br><code>BitSet.valueOf(lb).get(n) == ((lb.get(lb.position()+n/64) &amp; (1L&lt;&lt;(n%64))) != 0)</code> <br>for all <code>n &lt; 64 * lb.remaining()</code>. </p>
<p>The long buffer is not modified by this method, and no reference to the buffer is retained by the bit set.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>lb</code> - a long buffer containing a little-endian representation of a sequence of bits between its position and limit, to be used as the initial bits of the new bit set</dd> <dt>Returns:</dt> <dd>a <code>BitSet</code> containing all the bits in the buffer in the specified range</dd> <dt>Since:</dt> <dd>1.7</dd> </dl>    <h3 id="valueOf(byte[])">valueOf</h3> <pre data-language="java">public static BitSet valueOf(byte[] bytes)</pre> <div>
<p>Returns a new bit set containing all the bits in the given byte array. </p>
<p>More precisely, <br><code>BitSet.valueOf(bytes).get(n) == ((bytes[n/8] &amp; (1&lt;&lt;(n%8))) != 0)</code> <br>for all <code>n &lt;  8 * bytes.length</code>. </p>
<p>This method is equivalent to <code>BitSet.valueOf(ByteBuffer.wrap(bytes))</code>.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>bytes</code> - a byte array containing a little-endian representation of a sequence of bits to be used as the initial bits of the new bit set</dd> <dt>Returns:</dt> <dd>a <code>BitSet</code> containing all the bits in the byte array</dd> <dt>Since:</dt> <dd>1.7</dd> </dl>    <h3 id="valueOf(java.nio.ByteBuffer)">valueOf</h3> <pre data-language="java">public static BitSet valueOf(ByteBuffer bb)</pre> <div>
<p>Returns a new bit set containing all the bits in the given byte buffer between its position and limit. </p>
<p>More precisely, <br><code>BitSet.valueOf(bb).get(n) == ((bb.get(bb.position()+n/8) &amp; (1&lt;&lt;(n%8))) != 0)</code> <br>for all <code>n &lt; 8 * bb.remaining()</code>. </p>
<p>The byte buffer is not modified by this method, and no reference to the buffer is retained by the bit set.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>bb</code> - a byte buffer containing a little-endian representation of a sequence of bits between its position and limit, to be used as the initial bits of the new bit set</dd> <dt>Returns:</dt> <dd>a <code>BitSet</code> containing all the bits in the buffer in the specified range</dd> <dt>Since:</dt> <dd>1.7</dd> </dl>    <h3 id="toByteArray()">toByteArray</h3> <pre data-language="java">public byte[] toByteArray()</pre> <div>
<p>Returns a new byte array containing all the bits in this bit set. </p>
<p>More precisely, if <br><code>byte[] bytes = s.toByteArray();</code> <br>then <code>bytes.length == (s.length()+7)/8</code> and <br><code>s.get(n) == ((bytes[n/8] &amp; (1&lt;&lt;(n%8))) != 0)</code> <br>for all <code>n &lt; 8 * bytes.length</code>.</p>
</div> <dl> <dt>Returns:</dt> <dd>a byte array containing a little-endian representation of all the bits in this bit set</dd> <dt>Since:</dt> <dd>1.7</dd> </dl>    <h3 id="toLongArray()">toLongArray</h3> <pre data-language="java">public long[] toLongArray()</pre> <div>
<p>Returns a new long array containing all the bits in this bit set. </p>
<p>More precisely, if <br><code>long[] longs = s.toLongArray();</code> <br>then <code>longs.length == (s.length()+63)/64</code> and <br><code>s.get(n) == ((longs[n/64] &amp; (1L&lt;&lt;(n%64))) != 0)</code> <br>for all <code>n &lt; 64 * longs.length</code>.</p>
</div> <dl> <dt>Returns:</dt> <dd>a long array containing a little-endian representation of all the bits in this bit set</dd> <dt>Since:</dt> <dd>1.7</dd> </dl>    <h3 id="flip(int)">flip</h3> <pre data-language="java">public void flip(int bitIndex)</pre> <p>Sets the bit at the specified index to the complement of its current value.</p> <dl> <dt>Parameters:</dt> <dd>
<code>bitIndex</code> - the index of the bit to flip</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/indexoutofboundsexception">IndexOutOfBoundsException</a></code> - if the specified index is negative</dd> <dt>Since:</dt> <dd>1.4</dd> </dl>    <h3 id="flip(int,int)">flip</h3> <pre data-language="java">public void flip(int fromIndex,
                 int toIndex)</pre> <p>Sets each bit from the specified <code>fromIndex</code> (inclusive) to the specified <code>toIndex</code> (exclusive) to the complement of its current value.</p> <dl> <dt>Parameters:</dt> <dd>
<code>fromIndex</code> - index of the first bit to flip</dd> <dd>
<code>toIndex</code> - index after the last bit to flip</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/indexoutofboundsexception">IndexOutOfBoundsException</a></code> - if <code>fromIndex</code> is negative, or <code>toIndex</code> is negative, or <code>fromIndex</code> is larger than <code>toIndex</code>
</dd> <dt>Since:</dt> <dd>1.4</dd> </dl>    <h3 id="set(int)">set</h3> <pre data-language="java">public void set(int bitIndex)</pre> <p>Sets the bit at the specified index to <code>true</code>.</p> <dl> <dt>Parameters:</dt> <dd>
<code>bitIndex</code> - a bit index</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/indexoutofboundsexception">IndexOutOfBoundsException</a></code> - if the specified index is negative</dd> <dt>Since:</dt> <dd>1.0</dd> </dl>    <h3 id="set(int,boolean)">set</h3> <pre data-language="java">public void set(int bitIndex,
                boolean value)</pre> <p>Sets the bit at the specified index to the specified value.</p> <dl> <dt>Parameters:</dt> <dd>
<code>bitIndex</code> - a bit index</dd> <dd>
<code>value</code> - a boolean value to set</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/indexoutofboundsexception">IndexOutOfBoundsException</a></code> - if the specified index is negative</dd> <dt>Since:</dt> <dd>1.4</dd> </dl>    <h3 id="set(int,int)">set</h3> <pre data-language="java">public void set(int fromIndex,
                int toIndex)</pre> <p>Sets the bits from the specified <code>fromIndex</code> (inclusive) to the specified <code>toIndex</code> (exclusive) to <code>true</code>.</p> <dl> <dt>Parameters:</dt> <dd>
<code>fromIndex</code> - index of the first bit to be set</dd> <dd>
<code>toIndex</code> - index after the last bit to be set</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/indexoutofboundsexception">IndexOutOfBoundsException</a></code> - if <code>fromIndex</code> is negative, or <code>toIndex</code> is negative, or <code>fromIndex</code> is larger than <code>toIndex</code>
</dd> <dt>Since:</dt> <dd>1.4</dd> </dl>    <h3 id="set(int,int,boolean)">set</h3> <pre data-language="java">public void set(int fromIndex,
                int toIndex,
                boolean value)</pre> <p>Sets the bits from the specified <code>fromIndex</code> (inclusive) to the specified <code>toIndex</code> (exclusive) to the specified value.</p> <dl> <dt>Parameters:</dt> <dd>
<code>fromIndex</code> - index of the first bit to be set</dd> <dd>
<code>toIndex</code> - index after the last bit to be set</dd> <dd>
<code>value</code> - value to set the selected bits to</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/indexoutofboundsexception">IndexOutOfBoundsException</a></code> - if <code>fromIndex</code> is negative, or <code>toIndex</code> is negative, or <code>fromIndex</code> is larger than <code>toIndex</code>
</dd> <dt>Since:</dt> <dd>1.4</dd> </dl>    <h3 id="clear(int)">clear</h3> <pre data-language="java">public void clear(int bitIndex)</pre> <p>Sets the bit specified by the index to <code>false</code>.</p> <dl> <dt>Parameters:</dt> <dd>
<code>bitIndex</code> - the index of the bit to be cleared</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/indexoutofboundsexception">IndexOutOfBoundsException</a></code> - if the specified index is negative</dd> <dt>Since:</dt> <dd>1.0</dd> </dl>    <h3 id="clear(int,int)">clear</h3> <pre data-language="java">public void clear(int fromIndex,
                  int toIndex)</pre> <p>Sets the bits from the specified <code>fromIndex</code> (inclusive) to the specified <code>toIndex</code> (exclusive) to <code>false</code>.</p> <dl> <dt>Parameters:</dt> <dd>
<code>fromIndex</code> - index of the first bit to be cleared</dd> <dd>
<code>toIndex</code> - index after the last bit to be cleared</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/indexoutofboundsexception">IndexOutOfBoundsException</a></code> - if <code>fromIndex</code> is negative, or <code>toIndex</code> is negative, or <code>fromIndex</code> is larger than <code>toIndex</code>
</dd> <dt>Since:</dt> <dd>1.4</dd> </dl>    <h3 id="clear()">clear</h3> <pre data-language="java">public void clear()</pre> <p>Sets all of the bits in this BitSet to <code>false</code>.</p> <dl> <dt>Since:</dt> <dd>1.4</dd> </dl>    <h3 id="get(int)">get</h3> <pre data-language="java">public boolean get(int bitIndex)</pre> <p>Returns the value of the bit with the specified index. The value is <code>true</code> if the bit with the index <code>bitIndex</code> is currently set in this <code>BitSet</code>; otherwise, the result is <code>false</code>.</p> <dl> <dt>Parameters:</dt> <dd>
<code>bitIndex</code> - the bit index</dd> <dt>Returns:</dt> <dd>the value of the bit with the specified index</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/indexoutofboundsexception">IndexOutOfBoundsException</a></code> - if the specified index is negative</dd> </dl>    <h3 id="get(int,int)">get</h3> <pre data-language="java">public BitSet get(int fromIndex,
                  int toIndex)</pre> <p>Returns a new <code>BitSet</code> composed of bits from this <code>BitSet</code> from <code>fromIndex</code> (inclusive) to <code>toIndex</code> (exclusive).</p> <dl> <dt>Parameters:</dt> <dd>
<code>fromIndex</code> - index of the first bit to include</dd> <dd>
<code>toIndex</code> - index after the last bit to include</dd> <dt>Returns:</dt> <dd>a new <code>BitSet</code> from a range of this <code>BitSet</code>
</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/indexoutofboundsexception">IndexOutOfBoundsException</a></code> - if <code>fromIndex</code> is negative, or <code>toIndex</code> is negative, or <code>fromIndex</code> is larger than <code>toIndex</code>
</dd> <dt>Since:</dt> <dd>1.4</dd> </dl>    <h3 id="nextSetBit(int)">nextSetBit</h3> <pre data-language="java">public int nextSetBit(int fromIndex)</pre> <div>
<p>Returns the index of the first bit that is set to <code>true</code> that occurs on or after the specified starting index. If no such bit exists then <code>-1</code> is returned. </p>
<p>To iterate over the <code>true</code> bits in a <code>BitSet</code>, use the following loop: </p>
<pre data-language="java">for (int i = bs.nextSetBit(0); i &gt;= 0; i = bs.nextSetBit(i+1)) {
     // operate on index i here
     if (i == Integer.MAX_VALUE) {
         break; // or (i+1) would overflow
     }
 }</pre>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>fromIndex</code> - the index to start checking from (inclusive)</dd> <dt>Returns:</dt> <dd>the index of the next set bit, or <code>-1</code> if there is no such bit</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/indexoutofboundsexception">IndexOutOfBoundsException</a></code> - if the specified index is negative</dd> <dt>Since:</dt> <dd>1.4</dd> </dl>    <h3 id="nextClearBit(int)">nextClearBit</h3> <pre data-language="java">public int nextClearBit(int fromIndex)</pre> <p>Returns the index of the first bit that is set to <code>false</code> that occurs on or after the specified starting index.</p> <dl> <dt>Parameters:</dt> <dd>
<code>fromIndex</code> - the index to start checking from (inclusive)</dd> <dt>Returns:</dt> <dd>the index of the next clear bit</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/indexoutofboundsexception">IndexOutOfBoundsException</a></code> - if the specified index is negative</dd> <dt>Since:</dt> <dd>1.4</dd> </dl>    <h3 id="previousSetBit(int)">previousSetBit</h3> <pre data-language="java">public int previousSetBit(int fromIndex)</pre> <div>
<p>Returns the index of the nearest bit that is set to <code>true</code> that occurs on or before the specified starting index. If no such bit exists, or if <code>-1</code> is given as the starting index, then <code>-1</code> is returned. </p>
<p>To iterate over the <code>true</code> bits in a <code>BitSet</code>, use the following loop: </p>
<pre data-language="java">for (int i = bs.length(); (i = bs.previousSetBit(i-1)) &gt;= 0; ) {
     // operate on index i here
 }</pre>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>fromIndex</code> - the index to start checking from (inclusive)</dd> <dt>Returns:</dt> <dd>the index of the previous set bit, or <code>-1</code> if there is no such bit</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/indexoutofboundsexception">IndexOutOfBoundsException</a></code> - if the specified index is less than <code>-1</code>
</dd> <dt>Since:</dt> <dd>1.7</dd> </dl>    <h3 id="previousClearBit(int)">previousClearBit</h3> <pre data-language="java">public int previousClearBit(int fromIndex)</pre> <p>Returns the index of the nearest bit that is set to <code>false</code> that occurs on or before the specified starting index. If no such bit exists, or if <code>-1</code> is given as the starting index, then <code>-1</code> is returned.</p> <dl> <dt>Parameters:</dt> <dd>
<code>fromIndex</code> - the index to start checking from (inclusive)</dd> <dt>Returns:</dt> <dd>the index of the previous clear bit, or <code>-1</code> if there is no such bit</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/indexoutofboundsexception">IndexOutOfBoundsException</a></code> - if the specified index is less than <code>-1</code>
</dd> <dt>Since:</dt> <dd>1.7</dd> </dl>    <h3 id="length()">length</h3> <pre data-language="java">public int length()</pre> <p>Returns the "logical size" of this <code>BitSet</code>: the index of the highest set bit in the <code>BitSet</code> plus one. Returns zero if the <code>BitSet</code> contains no set bits.</p> <dl> <dt>Returns:</dt> <dd>the logical size of this <code>BitSet</code>
</dd> <dt>Since:</dt> <dd>1.2</dd> </dl>    <h3 id="isEmpty()">isEmpty</h3> <pre data-language="java">public boolean isEmpty()</pre> <p>Returns true if this <code>BitSet</code> contains no bits that are set to <code>true</code>.</p> <dl> <dt>Returns:</dt> <dd>boolean indicating whether this <code>BitSet</code> is empty</dd> <dt>Since:</dt> <dd>1.4</dd> </dl>    <h3 id="intersects(java.util.BitSet)">intersects</h3> <pre data-language="java">public boolean intersects(BitSet set)</pre> <p>Returns true if the specified <code>BitSet</code> has any bits set to <code>true</code> that are also set to <code>true</code> in this <code>BitSet</code>.</p> <dl> <dt>Parameters:</dt> <dd>
<code>set</code> - <code>BitSet</code> to intersect with</dd> <dt>Returns:</dt> <dd>boolean indicating whether this <code>BitSet</code> intersects the specified <code>BitSet</code>
</dd> <dt>Since:</dt> <dd>1.4</dd> </dl>    <h3 id="cardinality()">cardinality</h3> <pre data-language="java">public int cardinality()</pre> <p>Returns the number of bits set to <code>true</code> in this <code>BitSet</code>.</p> <dl> <dt>Returns:</dt> <dd>the number of bits set to <code>true</code> in this <code>BitSet</code>
</dd> <dt>Since:</dt> <dd>1.4</dd> </dl>    <h3 id="and(java.util.BitSet)">and</h3> <pre data-language="java">public void and(BitSet set)</pre> <p>Performs a logical <b>AND</b> of this target bit set with the argument bit set. This bit set is modified so that each bit in it has the value <code>true</code> if and only if it both initially had the value <code>true</code> and the corresponding bit in the bit set argument also had the value <code>true</code>.</p> <dl> <dt>Parameters:</dt> <dd>
<code>set</code> - a bit set</dd> </dl>    <h3 id="or(java.util.BitSet)">or</h3> <pre data-language="java">public void or(BitSet set)</pre> <p>Performs a logical <b>OR</b> of this bit set with the bit set argument. This bit set is modified so that a bit in it has the value <code>true</code> if and only if it either already had the value <code>true</code> or the corresponding bit in the bit set argument has the value <code>true</code>.</p> <dl> <dt>Parameters:</dt> <dd>
<code>set</code> - a bit set</dd> </dl>    <h3 id="xor(java.util.BitSet)">xor</h3> <pre data-language="java">public void xor(BitSet set)</pre> <p>Performs a logical <b>XOR</b> of this bit set with the bit set argument. This bit set is modified so that a bit in it has the value <code>true</code> if and only if one of the following statements holds: <ul> <li>The bit initially has the value <code>true</code>, and the corresponding bit in the argument has the value <code>false</code>. </li>
<li>The bit initially has the value <code>false</code>, and the corresponding bit in the argument has the value <code>true</code>. </li>
</ul></p> <dl> <dt>Parameters:</dt> <dd>
<code>set</code> - a bit set</dd> </dl>    <h3 id="andNot(java.util.BitSet)">andNot</h3> <pre data-language="java">public void andNot(BitSet set)</pre> <p>Clears all of the bits in this <code>BitSet</code> whose corresponding bit is set in the specified <code>BitSet</code>.</p> <dl> <dt>Parameters:</dt> <dd>
<code>set</code> - the <code>BitSet</code> with which to mask this <code>BitSet</code>
</dd> <dt>Since:</dt> <dd>1.2</dd> </dl>    <h3 id="hashCode()">hashCode</h3> <pre data-language="java">public int hashCode()</pre> <div>
<p>Returns the hash code value for this bit set. The hash code depends only on which bits are set within this <code>BitSet</code>. </p>
<p>The hash code is defined to be the result of the following calculation: </p>
<pre data-language="java">public int hashCode() {
     long h = 1234;
     long[] words = toLongArray();
     for (int i = words.length; --i &gt;= 0; )
         h ^= words[i] * (i + 1);
     return (int)((h &gt;&gt; 32) ^ h);
 }</pre> Note that the hash code changes if the set of bits is altered.</div> <dl> <dt>Overrides:</dt> <dd>
<code><a href="../lang/object#hashCode()">hashCode</a></code> in class <code><a href="../lang/object">Object</a></code>
</dd> <dt>Returns:</dt> <dd>the hash code value for this bit set</dd> <dt>See Also:</dt> <dd>
<a href="../lang/object#equals(java.lang.Object)"><code>Object.equals(java.lang.Object)</code></a>, <a href="../lang/system#identityHashCode(java.lang.Object)"><code>System.identityHashCode(java.lang.Object)</code></a>
</dd> </dl>    <h3 id="size()">size</h3> <pre data-language="java">public int size()</pre> <p>Returns the number of bits of space actually in use by this <code>BitSet</code> to represent bit values. The maximum element in the set is the size - 1st element.</p> <dl> <dt>Returns:</dt> <dd>the number of bits currently in this bit set</dd> </dl>    <h3 id="equals(java.lang.Object)">equals</h3> <pre data-language="java">public boolean equals(Object obj)</pre> <p>Compares this object against the specified object. The result is <code>true</code> if and only if the argument is not <code>null</code> and is a <code>Bitset</code> object that has exactly the same set of bits set to <code>true</code> as this bit set. That is, for every nonnegative <code>int</code> index <code>k</code>, <pre data-language="java">((BitSet)obj).get(k) == this.get(k)</pre> must be true. The current sizes of the two bit sets are not compared.</p> <dl> <dt>Overrides:</dt> <dd>
<code><a href="../lang/object#equals(java.lang.Object)">equals</a></code> in class <code><a href="../lang/object">Object</a></code>
</dd> <dt>Parameters:</dt> <dd>
<code>obj</code> - the object to compare with</dd> <dt>Returns:</dt> <dd>
<code>true</code> if the objects are the same; <code>false</code> otherwise</dd> <dt>See Also:</dt> <dd><a href="#size()"><code>size()</code></a></dd> </dl>    <h3 id="clone()">clone</h3> <pre data-language="java">public Object clone()</pre> <p>Cloning this <code>BitSet</code> produces a new <code>BitSet</code> that is equal to it. The clone of the bit set is another bit set that has exactly the same bits set to <code>true</code> as this bit set.</p> <dl> <dt>Overrides:</dt> <dd>
<code><a href="../lang/object#clone()">clone</a></code> in class <code><a href="../lang/object">Object</a></code>
</dd> <dt>Returns:</dt> <dd>a clone of this bit set</dd> <dt>See Also:</dt> <dd><a href="#size()"><code>size()</code></a></dd> </dl>    <h3 id="toString()">toString</h3> <pre data-language="java">public String toString()</pre> <div>
<p>Returns a string representation of this bit set. For every index for which this <code>BitSet</code> contains a bit in the set state, the decimal representation of that index is included in the result. Such indices are listed in order from lowest to highest, separated by ", " (a comma and a space) and surrounded by braces, resulting in the usual mathematical notation for a set of integers. </p>
<p>Example: </p>
<pre data-language="java">BitSet drPepper = new BitSet();</pre> Now <code>drPepper.toString()</code> returns "<code>{}</code>". <pre data-language="java">drPepper.set(2);</pre> Now <code>drPepper.toString()</code> returns "<code>{2}</code>". <pre data-language="java">drPepper.set(4);
 drPepper.set(10);</pre> Now <code>drPepper.toString()</code> returns "<code>{2, 4, 10}</code>".</div> <dl> <dt>Overrides:</dt> <dd>
<code><a href="../lang/object#toString()">toString</a></code> in class <code><a href="../lang/object">Object</a></code>
</dd> <dt>Returns:</dt> <dd>a string representation of this bit set</dd> </dl>    <h3 id="stream()">stream</h3> <pre data-language="java">public IntStream stream()</pre> <div>
<p>Returns a stream of indices for which this <code>BitSet</code> contains a bit in the set state. The indices are returned in order, from lowest to highest. The size of the stream is the number of bits in the set state, equal to the value returned by the <a href="#cardinality()"><code>cardinality()</code></a> method. </p>
<p>The stream binds to this bit set when the terminal stream operation commences (specifically, the spliterator for the stream is <a href="spliterator#binding"><em>late-binding</em></a>). If the bit set is modified during that operation then the result is undefined.</p>
</div> <dl> <dt>Returns:</dt> <dd>a stream of integers representing set indices</dd> <dt>Since:</dt> <dd>1.8</dd> </dl>   </section>  </div>  </main>  <div class="_attribution">
  <p class="_attribution-p">
    &copy; 1993, 2020, Oracle and/or its affiliates. All rights reserved.<br>Documentation extracted from Debian's OpenJDK Development Kit package.<br>Licensed under the GNU General Public License, version 2, with the Classpath Exception.<br>Various third party code in OpenJDK is licensed under different licenses (see Debian package).<br>Java and OpenJDK are trademarks or registered trademarks of Oracle and/or its affiliates.<br>
    <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/BitSet.html" class="_attribution-link">https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/BitSet.html</a>
  </p>
</div>
