  <main role="main">    <h1>Class DatagramChannel</h1>   <ul class="inheritance"> <li><a href="../../lang/object">java.lang.Object</a></li> <li> <ul class="inheritance"> <li><a href="spi/abstractinterruptiblechannel">java.nio.channels.spi.AbstractInterruptibleChannel</a></li> <li> <ul class="inheritance"> <li><a href="selectablechannel">java.nio.channels.SelectableChannel</a></li> <li> <ul class="inheritance"> <li><a href="spi/abstractselectablechannel">java.nio.channels.spi.AbstractSelectableChannel</a></li> <li> <ul class="inheritance"> <li>java.nio.channels.DatagramChannel</li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> </ul>   <dl> <dt>All Implemented Interfaces:</dt> <dd>
<code><a href="../../io/closeable">Closeable</a></code>, <code><a href="../../lang/autocloseable">AutoCloseable</a></code>, <code><a href="bytechannel">ByteChannel</a></code>, <code><a href="channel">Channel</a></code>, <code><a href="gatheringbytechannel">GatheringByteChannel</a></code>, <code><a href="interruptiblechannel">InterruptibleChannel</a></code>, <code><a href="multicastchannel">MulticastChannel</a></code>, <code><a href="networkchannel">NetworkChannel</a></code>, <code><a href="readablebytechannel">ReadableByteChannel</a></code>, <code><a href="scatteringbytechannel">ScatteringByteChannel</a></code>, <code><a href="writablebytechannel">WritableByteChannel</a></code>
</dd> </dl>  <pre data-language="java">public abstract class DatagramChannel
extends AbstractSelectableChannel
implements ByteChannel, ScatteringByteChannel, GatheringByteChannel, MulticastChannel</pre> <div>
<p>A selectable channel for datagram-oriented sockets. </p>
<p> A datagram channel is created by invoking one of the <a href="#open()"><code>open</code></a> methods of this class. It is not possible to create a channel for an arbitrary, pre-existing datagram socket. A newly-created datagram channel is open but not connected. A datagram channel need not be connected in order for the <a href="#send(java.nio.ByteBuffer,java.net.SocketAddress)"><code>send</code></a> and <a href="#receive(java.nio.ByteBuffer)"><code>receive</code></a> methods to be used. A datagram channel may be connected, by invoking its <a href="#connect(java.net.SocketAddress)"><code>connect</code></a> method, in order to avoid the overhead of the security checks are otherwise performed as part of every send and receive operation. A datagram channel must be connected in order to use the <a href="#read(java.nio.ByteBuffer)"><code>read</code></a> and <a href="#write(java.nio.ByteBuffer)"><code>write</code></a> methods, since those methods do not accept or return socket addresses. </p>
<p> Once connected, a datagram channel remains connected until it is disconnected or closed. Whether or not a datagram channel is connected may be determined by invoking its <a href="#isConnected()"><code>isConnected</code></a> method. </p>
<p> Socket options are configured using the <a href="#setOption(java.net.SocketOption,T)"><code>setOption</code></a> method. A datagram channel to an Internet Protocol socket supports the following options: </p>
<table>  <thead> <tr> <th scope="col">Option Name</th> <th scope="col">Description</th> </tr> </thead>  <tr> <th scope="row"> <a href="../../net/standardsocketoptions#SO_SNDBUF"><code>SO_SNDBUF</code></a> </th> <td> The size of the socket send buffer </td> </tr> <tr> <th scope="row"> <a href="../../net/standardsocketoptions#SO_RCVBUF"><code>SO_RCVBUF</code></a> </th> <td> The size of the socket receive buffer </td> </tr> <tr> <th scope="row"> <a href="../../net/standardsocketoptions#SO_REUSEADDR"><code>SO_REUSEADDR</code></a> </th> <td> Re-use address </td> </tr> <tr> <th scope="row"> <a href="../../net/standardsocketoptions#SO_BROADCAST"><code>SO_BROADCAST</code></a> </th> <td> Allow transmission of broadcast datagrams </td> </tr> <tr> <th scope="row"> <a href="../../net/standardsocketoptions#IP_TOS"><code>IP_TOS</code></a> </th> <td> The Type of Service (ToS) octet in the Internet Protocol (IP) header </td> </tr> <tr> <th scope="row"> <a href="../../net/standardsocketoptions#IP_MULTICAST_IF"><code>IP_MULTICAST_IF</code></a> </th> <td> The network interface for Internet Protocol (IP) multicast datagrams </td> </tr> <tr> <th scope="row"> <a href="../../net/standardsocketoptions#IP_MULTICAST_TTL"><code>IP_MULTICAST_TTL</code></a> </th> <td> The <em>time-to-live</em> for Internet Protocol (IP) multicast datagrams </td> </tr> <tr> <th scope="row"> <a href="../../net/standardsocketoptions#IP_MULTICAST_LOOP"><code>IP_MULTICAST_LOOP</code></a> </th> <td> Loopback for Internet Protocol (IP) multicast datagrams </td> </tr>  </table> Additional (implementation specific) options may also be supported. <p> Datagram channels are safe for use by multiple concurrent threads. They support concurrent reading and writing, though at most one thread may be reading and at most one thread may be writing at any given time. </p>
</div> <dl> <dt>Since:</dt> <dd>1.4</dd> </dl>      <section role="region">  <h2 id="constructor.summary">Constructors</h2> <table>  <tr> <th scope="col">Modifier</th> <th scope="col">Constructor</th> <th scope="col">Description</th> </tr> <tr> <td><code>protected </code></td> <th scope="row"><code><a href="#%3Cinit%3E(java.nio.channels.spi.SelectorProvider)">DatagramChannel</a>​(<a href="spi/selectorprovider">SelectorProvider</a> provider)</code></th> <td> <p>Initializes a new instance of this class.</p> </td> </tr> </table>  </section>  <section role="region">  <h2 id="method.summary">Methods</h2> <table>  <tr> <th scope="col">Modifier and Type</th> <th scope="col">Method</th> <th scope="col">Description</th> </tr> <tr id="i0"> <td><code>abstract <a href="datagramchannel">DatagramChannel</a></code></td> <th scope="row"><code><a href="#bind(java.net.SocketAddress)">bind</a>​(<a href="../../net/socketaddress">SocketAddress</a> local)</code></th> <td> <p>Binds the channel's socket to a local address.</p> </td> </tr> <tr id="i1"> <td><code>abstract <a href="datagramchannel">DatagramChannel</a></code></td> <th scope="row"><code><a href="#connect(java.net.SocketAddress)">connect</a>​(<a href="../../net/socketaddress">SocketAddress</a> remote)</code></th> <td> <p>Connects this channel's socket.</p> </td> </tr> <tr id="i2"> <td><code>abstract <a href="datagramchannel">DatagramChannel</a></code></td> <th scope="row"><code><a href="#disconnect()">disconnect</a>()</code></th> <td> <p>Disconnects this channel's socket.</p> </td> </tr> <tr id="i3"> <td><code>abstract <a href="../../net/socketaddress">SocketAddress</a></code></td> <th scope="row"><code><a href="#getLocalAddress()">getLocalAddress</a>()</code></th> <td> <p>Returns the socket address that this channel's socket is bound to.</p> </td> </tr> <tr id="i4"> <td><code>abstract <a href="../../net/socketaddress">SocketAddress</a></code></td> <th scope="row"><code><a href="#getRemoteAddress()">getRemoteAddress</a>()</code></th> <td> <p>Returns the remote address to which this channel's socket is connected.</p> </td> </tr> <tr id="i5"> <td><code>abstract boolean</code></td> <th scope="row"><code><a href="#isConnected()">isConnected</a>()</code></th> <td> <p>Tells whether or not this channel's socket is connected.</p> </td> </tr> <tr id="i6"> <td><code>static <a href="datagramchannel">DatagramChannel</a></code></td> <th scope="row"><code><a href="#open()">open</a>()</code></th> <td> <p>Opens a datagram channel.</p> </td> </tr> <tr id="i7"> <td><code>static <a href="datagramchannel">DatagramChannel</a></code></td> <th scope="row"><code><a href="#open(java.net.ProtocolFamily)">open</a>​(<a href="../../net/protocolfamily">ProtocolFamily</a> family)</code></th> <td> <p>Opens a datagram channel.</p> </td> </tr> <tr id="i8"> <td><code>abstract int</code></td> <th scope="row"><code><a href="#read(java.nio.ByteBuffer)">read</a>​(<a href="../bytebuffer">ByteBuffer</a> dst)</code></th> <td> <p>Reads a datagram from this channel.</p> </td> </tr> <tr id="i9"> <td><code>long</code></td> <th scope="row"><code><a href="#read(java.nio.ByteBuffer%5B%5D)">read</a>​(<a href="../bytebuffer">ByteBuffer</a>[] dsts)</code></th> <td> <p>Reads a datagram from this channel.</p> </td> </tr> <tr id="i10"> <td><code>abstract long</code></td> <th scope="row"><code><a href="#read(java.nio.ByteBuffer%5B%5D,int,int)">read</a>​(<a href="../bytebuffer">ByteBuffer</a>[] dsts,
    int offset,
    int length)</code></th> <td> <p>Reads a datagram from this channel.</p> </td> </tr> <tr id="i11"> <td><code>abstract <a href="../../net/socketaddress">SocketAddress</a></code></td> <th scope="row"><code><a href="#receive(java.nio.ByteBuffer)">receive</a>​(<a href="../bytebuffer">ByteBuffer</a> dst)</code></th> <td> <p>Receives a datagram via this channel.</p> </td> </tr> <tr id="i12"> <td><code>abstract int</code></td> <th scope="row"><code><a href="#send(java.nio.ByteBuffer,java.net.SocketAddress)">send</a>​(<a href="../bytebuffer">ByteBuffer</a> src,
    <a href="../../net/socketaddress">SocketAddress</a> target)</code></th> <td> <p>Sends a datagram via this channel.</p> </td> </tr> <tr id="i13"> <td><code>abstract &lt;T&gt; <a href="datagramchannel">DatagramChannel</a></code></td> <th scope="row"><code><a href="#setOption(java.net.SocketOption,T)">setOption</a>​(<a href="../../net/socketoption">SocketOption</a>&lt;T&gt; name,
         T value)</code></th> <td> <p>Sets the value of a socket option.</p> </td> </tr> <tr id="i14"> <td><code>abstract <a href="../../net/datagramsocket">DatagramSocket</a></code></td> <th scope="row"><code><a href="#socket()">socket</a>()</code></th> <td> <p>Retrieves a datagram socket associated with this channel.</p> </td> </tr> <tr id="i15"> <td><code>int</code></td> <th scope="row"><code><a href="#validOps()">validOps</a>()</code></th> <td> <p>Returns an operation set identifying this channel's supported operations.</p> </td> </tr> <tr id="i16"> <td><code>abstract int</code></td> <th scope="row"><code><a href="#write(java.nio.ByteBuffer)">write</a>​(<a href="../bytebuffer">ByteBuffer</a> src)</code></th> <td> <p>Writes a datagram to this channel.</p> </td> </tr> <tr id="i17"> <td><code>long</code></td> <th scope="row"><code><a href="#write(java.nio.ByteBuffer%5B%5D)">write</a>​(<a href="../bytebuffer">ByteBuffer</a>[] srcs)</code></th> <td> <p>Writes a datagram to this channel.</p> </td> </tr> <tr id="i18"> <td><code>abstract long</code></td> <th scope="row"><code><a href="#write(java.nio.ByteBuffer%5B%5D,int,int)">write</a>​(<a href="../bytebuffer">ByteBuffer</a>[] srcs,
     int offset,
     int length)</code></th> <td> <p>Writes a datagram to this channel.</p> </td> </tr> </table>  <h2 id="methods.inherited.from.class.java.nio.channels.spi.AbstractSelectableChannel">Methods declared in class java.nio.channels.spi.<a href="spi/abstractselectablechannel">AbstractSelectableChannel</a>
</h2> <code><a href="spi/abstractselectablechannel#configureBlocking(boolean)">configureBlocking</a>, <a href="spi/abstractselectablechannel#implCloseChannel()">implCloseChannel</a>, <a href="spi/abstractselectablechannel#implCloseSelectableChannel()">implCloseSelectableChannel</a>, <a href="spi/abstractselectablechannel#implConfigureBlocking(boolean)">implConfigureBlocking</a>, <a href="spi/abstractselectablechannel#provider()">provider</a>, <a href="spi/abstractselectablechannel#register(java.nio.channels.Selector,int,java.lang.Object)">register</a></code>  <h2 id="methods.inherited.from.class.java.nio.channels.SelectableChannel">Methods declared in class java.nio.channels.<a href="selectablechannel">SelectableChannel</a>
</h2> <code><a href="selectablechannel#blockingLock()">blockingLock</a>, <a href="selectablechannel#isBlocking()">isBlocking</a>, <a href="selectablechannel#isRegistered()">isRegistered</a>, <a href="selectablechannel#keyFor(java.nio.channels.Selector)">keyFor</a>, <a href="selectablechannel#register(java.nio.channels.Selector,int)">register</a></code>  <h2 id="methods.inherited.from.class.java.nio.channels.spi.AbstractInterruptibleChannel">Methods declared in class java.nio.channels.spi.<a href="spi/abstractinterruptiblechannel">AbstractInterruptibleChannel</a>
</h2> <code><a href="spi/abstractinterruptiblechannel#begin()">begin</a>, <a href="spi/abstractinterruptiblechannel#close()">close</a>, <a href="spi/abstractinterruptiblechannel#end(boolean)">end</a></code>  <h2 id="methods.inherited.from.class.java.lang.Object">Methods declared in class java.lang.<a href="../../lang/object">Object</a>
</h2> <code><a href="../../lang/object#clone()">clone</a>, <a href="../../lang/object#equals(java.lang.Object)">equals</a>, <a href="../../lang/object#finalize()">finalize</a>, <a href="../../lang/object#getClass()">getClass</a>, <a href="../../lang/object#hashCode()">hashCode</a>, <a href="../../lang/object#notify()">notify</a>, <a href="../../lang/object#notifyAll()">notifyAll</a>, <a href="../../lang/object#toString()">toString</a>, <a href="../../lang/object#wait()">wait</a>, <a href="../../lang/object#wait(long)">wait</a>, <a href="../../lang/object#wait(long,int)">wait</a></code>  <h2 id="methods.inherited.from.class.java.nio.channels.Channel">Methods declared in interface java.nio.channels.<a href="channel">Channel</a>
</h2> <code><a href="channel#isOpen()">isOpen</a></code>  <h2 id="methods.inherited.from.class.java.nio.channels.MulticastChannel">Methods declared in interface java.nio.channels.<a href="multicastchannel">MulticastChannel</a>
</h2> <code><a href="multicastchannel#close()">close</a>, <a href="multicastchannel#join(java.net.InetAddress,java.net.NetworkInterface)">join</a>, <a href="multicastchannel#join(java.net.InetAddress,java.net.NetworkInterface,java.net.InetAddress)">join</a></code>  <h2 id="methods.inherited.from.class.java.nio.channels.NetworkChannel">Methods declared in interface java.nio.channels.<a href="networkchannel">NetworkChannel</a>
</h2> <code><a href="networkchannel#getOption(java.net.SocketOption)">getOption</a>, <a href="networkchannel#supportedOptions()">supportedOptions</a></code>  </section>   <div>   <section role="region">  <h2 id="constructor.detail">Constructors</h2>   <h3 id="&lt;init&gt;(java.nio.channels.spi.SelectorProvider)">DatagramChannel</h3> <pre data-language="java">protected DatagramChannel(SelectorProvider provider)</pre> <p>Initializes a new instance of this class.</p> <dl> <dt>Parameters:</dt> <dd>
<code>provider</code> - The provider that created this channel</dd> </dl>   </section>  <section role="region">  <h2 id="method.detail">Methods</h2>   <h3 id="open()">open</h3> <pre data-language="java">public static DatagramChannel open()
                            throws IOException</pre> <div>
<p>Opens a datagram channel. </p>
<p> The new channel is created by invoking the <a href="spi/selectorprovider#openDatagramChannel()"><code>openDatagramChannel</code></a> method of the system-wide default <a href="spi/selectorprovider"><code>SelectorProvider</code></a> object. The channel will not be connected. </p>
<p> The <a href="../../net/protocolfamily"><code>ProtocolFamily</code></a> of the channel's socket is platform (and possibly configuration) dependent and therefore unspecified. The <a href="#open(java.net.ProtocolFamily)"><code>open</code></a> allows the protocol family to be selected when opening a datagram channel, and should be used to open datagram channels that are intended for Internet Protocol multicasting.</p>
</div> <dl> <dt>Returns:</dt> <dd>A new datagram channel</dd> <dt>Throws:</dt> <dd>
<code><a href="../../io/ioexception">IOException</a></code> - If an I/O error occurs</dd> </dl>    <h3 id="open(java.net.ProtocolFamily)">open</h3> <pre data-language="java">public static DatagramChannel open(ProtocolFamily family)
                            throws IOException</pre> <div>
<p>Opens a datagram channel. </p>
<p> The <code>family</code> parameter is used to specify the <a href="../../net/protocolfamily"><code>ProtocolFamily</code></a>. If the datagram channel is to be used for IP multicasting then this should correspond to the address type of the multicast groups that this channel will join. </p>
<p> The new channel is created by invoking the <a href="spi/selectorprovider#openDatagramChannel(java.net.ProtocolFamily)"><code>openDatagramChannel</code></a> method of the system-wide default <a href="spi/selectorprovider"><code>SelectorProvider</code></a> object. The channel will not be connected.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>family</code> - The protocol family</dd> <dt>Returns:</dt> <dd>A new datagram channel</dd> <dt>Throws:</dt> <dd>
<code><a href="../../lang/unsupportedoperationexception">UnsupportedOperationException</a></code> - If the specified protocol family is not supported. For example, suppose the parameter is specified as <a href="../../net/standardprotocolfamily#INET6"><code>StandardProtocolFamily.INET6</code></a> but IPv6 is not enabled on the platform.</dd> <dd>
<code><a href="../../io/ioexception">IOException</a></code> - If an I/O error occurs</dd> <dt>Since:</dt> <dd>1.7</dd> </dl>    <h3 id="validOps()">validOps</h3> <pre data-language="java">public final int validOps()</pre> <div>
<p>Returns an operation set identifying this channel's supported operations. </p>
<p> Datagram channels support reading and writing, so this method returns <code>(</code><a href="selectionkey#OP_READ"><code>SelectionKey.OP_READ</code></a> <code>|</code> <a href="selectionkey#OP_WRITE"><code>SelectionKey.OP_WRITE</code></a><code>)</code>.</p>
</div> <dl> <dt>Specified by:</dt> <dd>
<code><a href="selectablechannel#validOps()">validOps</a></code> in class <code><a href="selectablechannel">SelectableChannel</a></code>
</dd> <dt>Returns:</dt> <dd>The valid-operation set</dd> </dl>    <h3 id="bind(java.net.SocketAddress)">bind</h3> <pre data-language="java">public abstract DatagramChannel bind(SocketAddress local)
                              throws IOException</pre> <p>Description copied from interface: <code><a href="networkchannel#bind(java.net.SocketAddress)">NetworkChannel</a></code></p> <div>
<p>Binds the channel's socket to a local address. </p>
<p> This method is used to establish an association between the socket and a local address. Once an association is established then the socket remains bound until the channel is closed. If the <code>local</code> parameter has the value <code>null</code> then the socket will be bound to an address that is assigned automatically.</p>
</div> <dl> <dt>Specified by:</dt> <dd>
<code><a href="networkchannel#bind(java.net.SocketAddress)">bind</a></code> in interface <code><a href="networkchannel">NetworkChannel</a></code>
</dd> <dt>Parameters:</dt> <dd>
<code>local</code> - The address to bind the socket, or <code>null</code> to bind the socket to an automatically assigned socket address</dd> <dt>Returns:</dt> <dd>This channel</dd> <dt>Throws:</dt> <dd>
<code><a href="alreadyboundexception">AlreadyBoundException</a></code> - If the socket is already bound</dd> <dd>
<code><a href="unsupportedaddresstypeexception">UnsupportedAddressTypeException</a></code> - If the type of the given address is not supported</dd> <dd>
<code><a href="closedchannelexception">ClosedChannelException</a></code> - If the channel is closed</dd> <dd>
<code><a href="../../io/ioexception">IOException</a></code> - If some other I/O error occurs</dd> <dd>
<code><a href="../../lang/securityexception">SecurityException</a></code> - If a security manager has been installed and its <a href="../../lang/securitymanager#checkListen(int)"><code>checkListen</code></a> method denies the operation</dd> <dt>Since:</dt> <dd>1.7</dd> <dt>See Also:</dt> <dd><a href="networkchannel#getLocalAddress()"><code>NetworkChannel.getLocalAddress()</code></a></dd> </dl>    <h3 id="setOption(java.net.SocketOption,java.lang.Object)">setOption</h3> <pre data-language="java">public abstract &lt;T&gt; DatagramChannel setOption(SocketOption&lt;T&gt; name,
                                              T value)
                                       throws IOException</pre> <p>Description copied from interface: <code><a href="networkchannel#setOption(java.net.SocketOption,T)">NetworkChannel</a></code></p> <p>Sets the value of a socket option.</p> <dl> <dt>Specified by:</dt> <dd>
<code><a href="networkchannel#setOption(java.net.SocketOption,T)">setOption</a></code> in interface <code><a href="networkchannel">NetworkChannel</a></code>
</dd> <dt>Type Parameters:</dt> <dd>
<code>T</code> - The type of the socket option value</dd> <dt>Parameters:</dt> <dd>
<code>name</code> - The socket option</dd> <dd>
<code>value</code> - The value of the socket option. A value of <code>null</code> may be a valid value for some socket options.</dd> <dt>Returns:</dt> <dd>This channel</dd> <dt>Throws:</dt> <dd>
<code><a href="../../lang/unsupportedoperationexception">UnsupportedOperationException</a></code> - If the socket option is not supported by this channel</dd> <dd>
<code><a href="../../lang/illegalargumentexception">IllegalArgumentException</a></code> - If the value is not a valid value for this socket option</dd> <dd>
<code><a href="closedchannelexception">ClosedChannelException</a></code> - If this channel is closed</dd> <dd>
<code><a href="../../io/ioexception">IOException</a></code> - If an I/O error occurs</dd> <dt>Since:</dt> <dd>1.7</dd> <dt>See Also:</dt> <dd><a href="../../net/standardsocketoptions"><code>StandardSocketOptions</code></a></dd> </dl>    <h3 id="socket()">socket</h3> <pre data-language="java">public abstract DatagramSocket socket()</pre> <div>
<p>Retrieves a datagram socket associated with this channel. </p>
<p> The returned object will not declare any public methods that are not declared in the <a href="../../net/datagramsocket"><code>DatagramSocket</code></a> class. </p>
</div> <dl> <dt>Returns:</dt> <dd>A datagram socket associated with this channel</dd> </dl>    <h3 id="isConnected()">isConnected</h3> <pre data-language="java">public abstract boolean isConnected()</pre> <p>Tells whether or not this channel's socket is connected.</p> <dl> <dt>Returns:</dt> <dd>
<code>true</code> if, and only if, this channel's socket is <a href="channel#isOpen()"><code>open</code></a> and connected</dd> </dl>    <h3 id="connect(java.net.SocketAddress)">connect</h3> <pre data-language="java">public abstract DatagramChannel connect(SocketAddress remote)
                                 throws IOException</pre> <div>
<p>Connects this channel's socket. </p>
<p> The channel's socket is configured so that it only receives datagrams from, and sends datagrams to, the given remote <i>peer</i> address. Once connected, datagrams may not be received from or sent to any other address. A datagram socket remains connected until it is explicitly disconnected or until it is closed. </p>
<p> This method performs exactly the same security checks as the <a href="../../net/datagramsocket#connect(java.net.InetAddress,int)"><code>connect</code></a> method of the <a href="../../net/datagramsocket"><code>DatagramSocket</code></a> class. That is, if a security manager has been installed then this method verifies that its <a href="../../lang/securitymanager#checkAccept(java.lang.String,int)"><code>checkAccept</code></a> and <a href="../../lang/securitymanager#checkConnect(java.lang.String,int)"><code>checkConnect</code></a> methods permit datagrams to be received from and sent to, respectively, the given remote address. </p>
<p> This method may be invoked at any time. It will not have any effect on read or write operations that are already in progress at the moment that it is invoked. If this channel's socket is not bound then this method will first cause the socket to be bound to an address that is assigned automatically, as if invoking the <a href="#bind(java.net.SocketAddress)"><code>bind</code></a> method with a parameter of <code>null</code>. </p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>remote</code> - The remote address to which this channel is to be connected</dd> <dt>Returns:</dt> <dd>This datagram channel</dd> <dt>Throws:</dt> <dd>
<code><a href="alreadyconnectedexception">AlreadyConnectedException</a></code> - If this channel is already connected</dd> <dd>
<code><a href="closedchannelexception">ClosedChannelException</a></code> - If this channel is closed</dd> <dd>
<code><a href="asynchronouscloseexception">AsynchronousCloseException</a></code> - If another thread closes this channel while the connect operation is in progress</dd> <dd>
<code><a href="closedbyinterruptexception">ClosedByInterruptException</a></code> - If another thread interrupts the current thread while the connect operation is in progress, thereby closing the channel and setting the current thread's interrupt status</dd> <dd>
<code><a href="unresolvedaddressexception">UnresolvedAddressException</a></code> - If the given remote address is not fully resolved</dd> <dd>
<code><a href="unsupportedaddresstypeexception">UnsupportedAddressTypeException</a></code> - If the type of the given remote address is not supported</dd> <dd>
<code><a href="../../lang/securityexception">SecurityException</a></code> - If a security manager has been installed and it does not permit access to the given remote address</dd> <dd>
<code><a href="../../io/ioexception">IOException</a></code> - If some other I/O error occurs</dd> </dl>    <h3 id="disconnect()">disconnect</h3> <pre data-language="java">public abstract DatagramChannel disconnect()
                                    throws IOException</pre> <div>
<p>Disconnects this channel's socket. </p>
<p> The channel's socket is configured so that it can receive datagrams from, and sends datagrams to, any remote address so long as the security manager, if installed, permits it. </p>
<p> This method may be invoked at any time. It will not have any effect on read or write operations that are already in progress at the moment that it is invoked. </p>
<p> If this channel's socket is not connected, or if the channel is closed, then invoking this method has no effect. </p>
</div> <dl> <dt>Returns:</dt> <dd>This datagram channel</dd> <dt>Throws:</dt> <dd>
<code><a href="../../io/ioexception">IOException</a></code> - If some other I/O error occurs</dd> </dl>    <h3 id="getRemoteAddress()">getRemoteAddress</h3> <pre data-language="java">public abstract SocketAddress getRemoteAddress()
                                        throws IOException</pre> <p>Returns the remote address to which this channel's socket is connected.</p> <dl> <dt>Returns:</dt> <dd>The remote address; <code>null</code> if the channel's socket is not connected</dd> <dt>Throws:</dt> <dd>
<code><a href="closedchannelexception">ClosedChannelException</a></code> - If the channel is closed</dd> <dd>
<code><a href="../../io/ioexception">IOException</a></code> - If an I/O error occurs</dd> <dt>Since:</dt> <dd>1.7</dd> </dl>    <h3 id="receive(java.nio.ByteBuffer)">receive</h3> <pre data-language="java">public abstract SocketAddress receive(ByteBuffer dst)
                               throws IOException</pre> <div>
<p>Receives a datagram via this channel. </p>
<p> If a datagram is immediately available, or if this channel is in blocking mode and one eventually becomes available, then the datagram is copied into the given byte buffer and its source address is returned. If this channel is in non-blocking mode and a datagram is not immediately available then this method immediately returns <code>null</code>. </p>
<p> The datagram is transferred into the given byte buffer starting at its current position, as if by a regular <a href="readablebytechannel#read(java.nio.ByteBuffer)"><code>read</code></a> operation. If there are fewer bytes remaining in the buffer than are required to hold the datagram then the remainder of the datagram is silently discarded. </p>
<p> This method performs exactly the same security checks as the <a href="../../net/datagramsocket#receive(java.net.DatagramPacket)"><code>receive</code></a> method of the <a href="../../net/datagramsocket"><code>DatagramSocket</code></a> class. That is, if the socket is not connected to a specific remote address and a security manager has been installed then for each datagram received this method verifies that the source's address and port number are permitted by the security manager's <a href="../../lang/securitymanager#checkAccept(java.lang.String,int)"><code>checkAccept</code></a> method. The overhead of this security check can be avoided by first connecting the socket via the <a href="#connect(java.net.SocketAddress)"><code>connect</code></a> method. </p>
<p> This method may be invoked at any time. If another thread has already initiated a read operation upon this channel, however, then an invocation of this method will block until the first operation is complete. If this channel's socket is not bound then this method will first cause the socket to be bound to an address that is assigned automatically, as if invoking the <a href="#bind(java.net.SocketAddress)"><code>bind</code></a> method with a parameter of <code>null</code>. </p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>dst</code> - The buffer into which the datagram is to be transferred</dd> <dt>Returns:</dt> <dd>The datagram's source address, or <code>null</code> if this channel is in non-blocking mode and no datagram was immediately available</dd> <dt>Throws:</dt> <dd>
<code><a href="closedchannelexception">ClosedChannelException</a></code> - If this channel is closed</dd> <dd>
<code><a href="asynchronouscloseexception">AsynchronousCloseException</a></code> - If another thread closes this channel while the read operation is in progress</dd> <dd>
<code><a href="closedbyinterruptexception">ClosedByInterruptException</a></code> - If another thread interrupts the current thread while the read operation is in progress, thereby closing the channel and setting the current thread's interrupt status</dd> <dd>
<code><a href="../../lang/securityexception">SecurityException</a></code> - If a security manager has been installed and it does not permit datagrams to be accepted from the datagram's sender</dd> <dd>
<code><a href="../../io/ioexception">IOException</a></code> - If some other I/O error occurs</dd> </dl>    <h3 id="send(java.nio.ByteBuffer,java.net.SocketAddress)">send</h3> <pre data-language="java">public abstract int send(ByteBuffer src,
                         SocketAddress target)
                  throws IOException</pre> <div>
<p>Sends a datagram via this channel. </p>
<p> If this channel is in non-blocking mode and there is sufficient room in the underlying output buffer, or if this channel is in blocking mode and sufficient room becomes available, then the remaining bytes in the given buffer are transmitted as a single datagram to the given target address. </p>
<p> The datagram is transferred from the byte buffer as if by a regular <a href="writablebytechannel#write(java.nio.ByteBuffer)"><code>write</code></a> operation. </p>
<p> This method performs exactly the same security checks as the <a href="../../net/datagramsocket#send(java.net.DatagramPacket)"><code>send</code></a> method of the <a href="../../net/datagramsocket"><code>DatagramSocket</code></a> class. That is, if the socket is not connected to a specific remote address and a security manager has been installed then for each datagram sent this method verifies that the target address and port number are permitted by the security manager's <a href="../../lang/securitymanager#checkConnect(java.lang.String,int)"><code>checkConnect</code></a> method. The overhead of this security check can be avoided by first connecting the socket via the <a href="#connect(java.net.SocketAddress)"><code>connect</code></a> method. </p>
<p> This method may be invoked at any time. If another thread has already initiated a write operation upon this channel, however, then an invocation of this method will block until the first operation is complete. If this channel's socket is not bound then this method will first cause the socket to be bound to an address that is assigned automatically, as if by invoking the <a href="#bind(java.net.SocketAddress)"><code>bind</code></a> method with a parameter of <code>null</code>. </p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>src</code> - The buffer containing the datagram to be sent</dd> <dd>
<code>target</code> - The address to which the datagram is to be sent</dd> <dt>Returns:</dt> <dd>The number of bytes sent, which will be either the number of bytes that were remaining in the source buffer when this method was invoked or, if this channel is non-blocking, may be zero if there was insufficient room for the datagram in the underlying output buffer</dd> <dt>Throws:</dt> <dd>
<code><a href="alreadyconnectedexception">AlreadyConnectedException</a></code> - If this channel is connected to a different address from that specified by <code>target</code>
</dd> <dd>
<code><a href="closedchannelexception">ClosedChannelException</a></code> - If this channel is closed</dd> <dd>
<code><a href="asynchronouscloseexception">AsynchronousCloseException</a></code> - If another thread closes this channel while the read operation is in progress</dd> <dd>
<code><a href="closedbyinterruptexception">ClosedByInterruptException</a></code> - If another thread interrupts the current thread while the read operation is in progress, thereby closing the channel and setting the current thread's interrupt status</dd> <dd>
<code><a href="unresolvedaddressexception">UnresolvedAddressException</a></code> - If the given remote address is not fully resolved</dd> <dd>
<code><a href="unsupportedaddresstypeexception">UnsupportedAddressTypeException</a></code> - If the type of the given remote address is not supported</dd> <dd>
<code><a href="../../lang/securityexception">SecurityException</a></code> - If a security manager has been installed and it does not permit datagrams to be sent to the given address</dd> <dd>
<code><a href="../../io/ioexception">IOException</a></code> - If some other I/O error occurs</dd> </dl>    <h3 id="read(java.nio.ByteBuffer)">read</h3> <pre data-language="java">public abstract int read(ByteBuffer dst)
                  throws IOException</pre> <div>
<p>Reads a datagram from this channel. </p>
<p> This method may only be invoked if this channel's socket is connected, and it only accepts datagrams from the socket's peer. If there are more bytes in the datagram than remain in the given buffer then the remainder of the datagram is silently discarded. Otherwise this method behaves exactly as specified in the <a href="readablebytechannel"><code>ReadableByteChannel</code></a> interface. </p>
</div> <dl> <dt>Specified by:</dt> <dd>
<code><a href="readablebytechannel#read(java.nio.ByteBuffer)">read</a></code> in interface <code><a href="readablebytechannel">ReadableByteChannel</a></code>
</dd> <dt>Parameters:</dt> <dd>
<code>dst</code> - The buffer into which bytes are to be transferred</dd> <dt>Returns:</dt> <dd>The number of bytes read, possibly zero, or <code>-1</code> if the channel has reached end-of-stream</dd> <dt>Throws:</dt> <dd>
<code><a href="notyetconnectedexception">NotYetConnectedException</a></code> - If this channel's socket is not connected</dd> <dd>
<code><a href="closedchannelexception">ClosedChannelException</a></code> - If this channel is closed</dd> <dd>
<code><a href="asynchronouscloseexception">AsynchronousCloseException</a></code> - If another thread closes this channel while the read operation is in progress</dd> <dd>
<code><a href="closedbyinterruptexception">ClosedByInterruptException</a></code> - If another thread interrupts the current thread while the read operation is in progress, thereby closing the channel and setting the current thread's interrupt status</dd> <dd>
<code><a href="../../io/ioexception">IOException</a></code> - If some other I/O error occurs</dd> </dl>    <h3 id="read(java.nio.ByteBuffer[],int,int)">read</h3> <pre data-language="java">public abstract long read(ByteBuffer[] dsts,
                          int offset,
                          int length)
                   throws IOException</pre> <div>
<p>Reads a datagram from this channel. </p>
<p> This method may only be invoked if this channel's socket is connected, and it only accepts datagrams from the socket's peer. If there are more bytes in the datagram than remain in the given buffers then the remainder of the datagram is silently discarded. Otherwise this method behaves exactly as specified in the <a href="scatteringbytechannel"><code>ScatteringByteChannel</code></a> interface. </p>
</div> <dl> <dt>Specified by:</dt> <dd>
<code><a href="scatteringbytechannel#read(java.nio.ByteBuffer%5B%5D,int,int)">read</a></code> in interface <code><a href="scatteringbytechannel">ScatteringByteChannel</a></code>
</dd> <dt>Parameters:</dt> <dd>
<code>dsts</code> - The buffers into which bytes are to be transferred</dd> <dd>
<code>offset</code> - The offset within the buffer array of the first buffer into which bytes are to be transferred; must be non-negative and no larger than <code>dsts.length</code>
</dd> <dd>
<code>length</code> - The maximum number of buffers to be accessed; must be non-negative and no larger than <code>dsts.length</code> - <code>offset</code>
</dd> <dt>Returns:</dt> <dd>The number of bytes read, possibly zero, or <code>-1</code> if the channel has reached end-of-stream</dd> <dt>Throws:</dt> <dd>
<code><a href="notyetconnectedexception">NotYetConnectedException</a></code> - If this channel's socket is not connected</dd> <dd>
<code><a href="closedchannelexception">ClosedChannelException</a></code> - If this channel is closed</dd> <dd>
<code><a href="asynchronouscloseexception">AsynchronousCloseException</a></code> - If another thread closes this channel while the read operation is in progress</dd> <dd>
<code><a href="closedbyinterruptexception">ClosedByInterruptException</a></code> - If another thread interrupts the current thread while the read operation is in progress, thereby closing the channel and setting the current thread's interrupt status</dd> <dd>
<code><a href="../../io/ioexception">IOException</a></code> - If some other I/O error occurs</dd> </dl>    <h3 id="read(java.nio.ByteBuffer[])">read</h3> <pre data-language="java">public final long read(ByteBuffer[] dsts)
                throws IOException</pre> <div>
<p>Reads a datagram from this channel. </p>
<p> This method may only be invoked if this channel's socket is connected, and it only accepts datagrams from the socket's peer. If there are more bytes in the datagram than remain in the given buffers then the remainder of the datagram is silently discarded. Otherwise this method behaves exactly as specified in the <a href="scatteringbytechannel"><code>ScatteringByteChannel</code></a> interface. </p>
</div> <dl> <dt>Specified by:</dt> <dd>
<code><a href="scatteringbytechannel#read(java.nio.ByteBuffer%5B%5D)">read</a></code> in interface <code><a href="scatteringbytechannel">ScatteringByteChannel</a></code>
</dd> <dt>Parameters:</dt> <dd>
<code>dsts</code> - The buffers into which bytes are to be transferred</dd> <dt>Returns:</dt> <dd>The number of bytes read, possibly zero, or <code>-1</code> if the channel has reached end-of-stream</dd> <dt>Throws:</dt> <dd>
<code><a href="notyetconnectedexception">NotYetConnectedException</a></code> - If this channel's socket is not connected</dd> <dd>
<code><a href="closedchannelexception">ClosedChannelException</a></code> - If this channel is closed</dd> <dd>
<code><a href="asynchronouscloseexception">AsynchronousCloseException</a></code> - If another thread closes this channel while the read operation is in progress</dd> <dd>
<code><a href="closedbyinterruptexception">ClosedByInterruptException</a></code> - If another thread interrupts the current thread while the read operation is in progress, thereby closing the channel and setting the current thread's interrupt status</dd> <dd>
<code><a href="../../io/ioexception">IOException</a></code> - If some other I/O error occurs</dd> </dl>    <h3 id="write(java.nio.ByteBuffer)">write</h3> <pre data-language="java">public abstract int write(ByteBuffer src)
                   throws IOException</pre> <div>
<p>Writes a datagram to this channel. </p>
<p> This method may only be invoked if this channel's socket is connected, in which case it sends datagrams directly to the socket's peer. Otherwise it behaves exactly as specified in the <a href="writablebytechannel"><code>WritableByteChannel</code></a> interface. </p>
</div> <dl> <dt>Specified by:</dt> <dd>
<code><a href="writablebytechannel#write(java.nio.ByteBuffer)">write</a></code> in interface <code><a href="writablebytechannel">WritableByteChannel</a></code>
</dd> <dt>Parameters:</dt> <dd>
<code>src</code> - The buffer from which bytes are to be retrieved</dd> <dt>Returns:</dt> <dd>The number of bytes written, possibly zero</dd> <dt>Throws:</dt> <dd>
<code><a href="notyetconnectedexception">NotYetConnectedException</a></code> - If this channel's socket is not connected</dd> <dd>
<code><a href="closedchannelexception">ClosedChannelException</a></code> - If this channel is closed</dd> <dd>
<code><a href="asynchronouscloseexception">AsynchronousCloseException</a></code> - If another thread closes this channel while the write operation is in progress</dd> <dd>
<code><a href="closedbyinterruptexception">ClosedByInterruptException</a></code> - If another thread interrupts the current thread while the write operation is in progress, thereby closing the channel and setting the current thread's interrupt status</dd> <dd>
<code><a href="../../io/ioexception">IOException</a></code> - If some other I/O error occurs</dd> </dl>    <h3 id="write(java.nio.ByteBuffer[],int,int)">write</h3> <pre data-language="java">public abstract long write(ByteBuffer[] srcs,
                           int offset,
                           int length)
                    throws IOException</pre> <div>
<p>Writes a datagram to this channel. </p>
<p> This method may only be invoked if this channel's socket is connected, in which case it sends datagrams directly to the socket's peer. Otherwise it behaves exactly as specified in the <a href="gatheringbytechannel"><code>GatheringByteChannel</code></a> interface. </p>
</div> <dl> <dt>Specified by:</dt> <dd>
<code><a href="gatheringbytechannel#write(java.nio.ByteBuffer%5B%5D,int,int)">write</a></code> in interface <code><a href="gatheringbytechannel">GatheringByteChannel</a></code>
</dd> <dt>Parameters:</dt> <dd>
<code>srcs</code> - The buffers from which bytes are to be retrieved</dd> <dd>
<code>offset</code> - The offset within the buffer array of the first buffer from which bytes are to be retrieved; must be non-negative and no larger than <code>srcs.length</code>
</dd> <dd>
<code>length</code> - The maximum number of buffers to be accessed; must be non-negative and no larger than <code>srcs.length</code> - <code>offset</code>
</dd> <dt>Returns:</dt> <dd>The number of bytes sent, which will be either the number of bytes that were remaining in the source buffer when this method was invoked or, if this channel is non-blocking, may be zero if there was insufficient room for the datagram in the underlying output buffer</dd> <dt>Throws:</dt> <dd>
<code><a href="notyetconnectedexception">NotYetConnectedException</a></code> - If this channel's socket is not connected</dd> <dd>
<code><a href="closedchannelexception">ClosedChannelException</a></code> - If this channel is closed</dd> <dd>
<code><a href="asynchronouscloseexception">AsynchronousCloseException</a></code> - If another thread closes this channel while the write operation is in progress</dd> <dd>
<code><a href="closedbyinterruptexception">ClosedByInterruptException</a></code> - If another thread interrupts the current thread while the write operation is in progress, thereby closing the channel and setting the current thread's interrupt status</dd> <dd>
<code><a href="../../io/ioexception">IOException</a></code> - If some other I/O error occurs</dd> </dl>    <h3 id="write(java.nio.ByteBuffer[])">write</h3> <pre data-language="java">public final long write(ByteBuffer[] srcs)
                 throws IOException</pre> <div>
<p>Writes a datagram to this channel. </p>
<p> This method may only be invoked if this channel's socket is connected, in which case it sends datagrams directly to the socket's peer. Otherwise it behaves exactly as specified in the <a href="gatheringbytechannel"><code>GatheringByteChannel</code></a> interface. </p>
</div> <dl> <dt>Specified by:</dt> <dd>
<code><a href="gatheringbytechannel#write(java.nio.ByteBuffer%5B%5D)">write</a></code> in interface <code><a href="gatheringbytechannel">GatheringByteChannel</a></code>
</dd> <dt>Parameters:</dt> <dd>
<code>srcs</code> - The buffers from which bytes are to be retrieved</dd> <dt>Returns:</dt> <dd>The number of bytes sent, which will be either the number of bytes that were remaining in the source buffer when this method was invoked or, if this channel is non-blocking, may be zero if there was insufficient room for the datagram in the underlying output buffer</dd> <dt>Throws:</dt> <dd>
<code><a href="notyetconnectedexception">NotYetConnectedException</a></code> - If this channel's socket is not connected</dd> <dd>
<code><a href="closedchannelexception">ClosedChannelException</a></code> - If this channel is closed</dd> <dd>
<code><a href="asynchronouscloseexception">AsynchronousCloseException</a></code> - If another thread closes this channel while the write operation is in progress</dd> <dd>
<code><a href="closedbyinterruptexception">ClosedByInterruptException</a></code> - If another thread interrupts the current thread while the write operation is in progress, thereby closing the channel and setting the current thread's interrupt status</dd> <dd>
<code><a href="../../io/ioexception">IOException</a></code> - If some other I/O error occurs</dd> </dl>    <h3 id="getLocalAddress()">getLocalAddress</h3> <pre data-language="java">public abstract SocketAddress getLocalAddress()
                                       throws IOException</pre> <div>
<p>Returns the socket address that this channel's socket is bound to. </p>
<p> Where the channel is <a href="networkchannel#bind(java.net.SocketAddress)"><code>bound</code></a> to an Internet Protocol socket address then the return value from this method is of type <a href="../../net/inetsocketaddress"><code>InetSocketAddress</code></a>. </p>
<p> If there is a security manager set, its <code>checkConnect</code> method is called with the local address and <code>-1</code> as its arguments to see if the operation is allowed. If the operation is not allowed, a <code>SocketAddress</code> representing the <a href="../../net/inetaddress#getLoopbackAddress()"><code>loopback</code></a> address and the local port of the channel's socket is returned.</p>
</div> <dl> <dt>Specified by:</dt> <dd>
<code><a href="networkchannel#getLocalAddress()">getLocalAddress</a></code> in interface <code><a href="networkchannel">NetworkChannel</a></code>
</dd> <dt>Returns:</dt> <dd>The <code>SocketAddress</code> that the socket is bound to, or the <code>SocketAddress</code> representing the loopback address if denied by the security manager, or <code>null</code> if the channel's socket is not bound</dd> <dt>Throws:</dt> <dd>
<code><a href="closedchannelexception">ClosedChannelException</a></code> - If the channel is closed</dd> <dd>
<code><a href="../../io/ioexception">IOException</a></code> - If an I/O error occurs</dd> </dl>   </section>  </div>  </main>  <div class="_attribution">
  <p class="_attribution-p">
    &copy; 1993, 2020, Oracle and/or its affiliates. All rights reserved.<br>Documentation extracted from Debian's OpenJDK Development Kit package.<br>Licensed under the GNU General Public License, version 2, with the Classpath Exception.<br>Various third party code in OpenJDK is licensed under different licenses (see Debian package).<br>Java and OpenJDK are trademarks or registered trademarks of Oracle and/or its affiliates.<br>
    <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/nio/channels/DatagramChannel.html" class="_attribution-link">https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/nio/channels/DatagramChannel.html</a>
  </p>
</div>
