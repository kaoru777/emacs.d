  <main role="main">    <h1>Class Module</h1>   <ul class="inheritance"> <li><a href="object">java.lang.Object</a></li> <li> <ul class="inheritance"> <li>java.lang.Module</li> </ul> </li> </ul>   <dl> <dt>All Implemented Interfaces:</dt> <dd><code><a href="reflect/annotatedelement">AnnotatedElement</a></code></dd> </dl>  <pre data-language="java">public final class Module
extends Object
implements AnnotatedElement</pre> <div>
<p>Represents a run-time module, either <a href="#isNamed()"><code>named</code></a> or unnamed. </p>
<p> Named modules have a <a href="#getName()"><code>name</code></a> and are constructed by the Java Virtual Machine when a graph of modules is defined to the Java virtual machine to create a <a href="modulelayer">module layer</a>. </p> <p> An unnamed module does not have a name. There is an unnamed module for each <a href="classloader"><code>ClassLoader</code></a>, obtained by invoking its <a href="classloader#getUnnamedModule()"><code>getUnnamedModule</code></a> method. All types that are not in a named module are members of their defining class loader's unnamed module. </p> <p> The package names that are parameters or returned by methods defined in this class are the fully-qualified names of the packages as defined in section 6.5.3 of <cite>The Java™ Language Specification</cite>, for example, <code>"java.lang"</code>. </p> <p> Unless otherwise specified, passing a <code>null</code> argument to a method in this class causes a <a href="nullpointerexception"><code>NullPointerException</code></a> to be thrown. </p>
</div> <dl> <dt>Since:</dt> <dd>9</dd> <dt>See Also:</dt> <dd><a href="class#getModule()"><code>Class.getModule()</code></a></dd> </dl>      <section role="region">  <h2 id="method.summary">Methods</h2> <table>  <tr> <th scope="col">Modifier and Type</th> <th scope="col">Method</th> <th scope="col">Description</th> </tr> <tr id="i0"> <td><code><a href="module">Module</a></code></td> <th scope="row"><code><a href="#addExports(java.lang.String,java.lang.Module)">addExports</a>​(<a href="string">String</a> pn,
          <a href="module">Module</a> other)</code></th> <td> <p>If the caller's module is this module then update this module to export the given package to the given module.</p> </td> </tr> <tr id="i1"> <td><code><a href="module">Module</a></code></td> <th scope="row"><code><a href="#addOpens(java.lang.String,java.lang.Module)">addOpens</a>​(<a href="string">String</a> pn,
        <a href="module">Module</a> other)</code></th> <td> <p>If this module has <em>opened</em> a package to at least the caller module then update this module to open the package to the given module.</p> </td> </tr> <tr id="i2"> <td><code><a href="module">Module</a></code></td> <th scope="row"><code><a href="#addReads(java.lang.Module)">addReads</a>​(<a href="module">Module</a> other)</code></th> <td> <p>If the caller's module is this module then update this module to read the given module.</p> </td> </tr> <tr id="i3"> <td><code><a href="module">Module</a></code></td> <th scope="row"><code><a href="#addUses(java.lang.Class)">addUses</a>​(<a href="class">Class</a>&lt;?&gt; service)</code></th> <td> <p>If the caller's module is this module then update this module to add a service dependence on the given service type.</p> </td> </tr> <tr id="i4"> <td><code>boolean</code></td> <th scope="row"><code><a href="#canRead(java.lang.Module)">canRead</a>​(<a href="module">Module</a> other)</code></th> <td> <p>Indicates if this module reads the given module.</p> </td> </tr> <tr id="i5"> <td><code>boolean</code></td> <th scope="row"><code><a href="#canUse(java.lang.Class)">canUse</a>​(<a href="class">Class</a>&lt;?&gt; service)</code></th> <td> <p>Indicates if this module has a service dependence on the given service type.</p> </td> </tr> <tr id="i6"> <td><code>&lt;T extends <a href="annotation/annotation">Annotation</a>&gt;<br>T</code></td> <th scope="row"><code><a href="#getAnnotation(java.lang.Class)">getAnnotation</a>​(<a href="class">Class</a>&lt;T&gt; annotationClass)</code></th> <td> <p>Returns this element's annotation for the specified type if such an annotation is <em>present</em>, else null.</p> </td> </tr> <tr id="i7"> <td><code><a href="annotation/annotation">Annotation</a>[]</code></td> <th scope="row"><code><a href="#getAnnotations()">getAnnotations</a>()</code></th> <td> <p>Returns annotations that are <em>present</em> on this element.</p> </td> </tr> <tr id="i8"> <td><code><a href="classloader">ClassLoader</a></code></td> <th scope="row"><code><a href="#getClassLoader()">getClassLoader</a>()</code></th> <td> <p>Returns the <code>ClassLoader</code> for this module.</p> </td> </tr> <tr id="i9"> <td><code><a href="annotation/annotation">Annotation</a>[]</code></td> <th scope="row"><code><a href="#getDeclaredAnnotations()">getDeclaredAnnotations</a>()</code></th> <td> <p>Returns annotations that are <em>directly present</em> on this element.</p> </td> </tr> <tr id="i10"> <td><code><a href="module/moduledescriptor">ModuleDescriptor</a></code></td> <th scope="row"><code><a href="#getDescriptor()">getDescriptor</a>()</code></th> <td> <p>Returns the module descriptor for this module or <code>null</code> if this module is an unnamed module.</p> </td> </tr> <tr id="i11"> <td><code><a href="modulelayer">ModuleLayer</a></code></td> <th scope="row"><code><a href="#getLayer()">getLayer</a>()</code></th> <td> <p>Returns the module layer that contains this module or <code>null</code> if this module is not in a module layer.</p> </td> </tr> <tr id="i12"> <td><code><a href="string">String</a></code></td> <th scope="row"><code><a href="#getName()">getName</a>()</code></th> <td> <p>Returns the module name or <code>null</code> if this module is an unnamed module.</p> </td> </tr> <tr id="i13"> <td><code><a href="../util/set">Set</a>&lt;<a href="string">String</a>&gt;</code></td> <th scope="row"><code><a href="#getPackages()">getPackages</a>()</code></th> <td> <p>Returns the set of package names for the packages in this module.</p> </td> </tr> <tr id="i14"> <td><code><a href="../io/inputstream">InputStream</a></code></td> <th scope="row"><code><a href="#getResourceAsStream(java.lang.String)">getResourceAsStream</a>​(<a href="string">String</a> name)</code></th> <td> <p>Returns an input stream for reading a resource in this module.</p> </td> </tr> <tr id="i15"> <td><code>boolean</code></td> <th scope="row"><code><a href="#isExported(java.lang.String)">isExported</a>​(<a href="string">String</a> pn)</code></th> <td> <p>Returns <code>true</code> if this module exports the given package unconditionally.</p> </td> </tr> <tr id="i16"> <td><code>boolean</code></td> <th scope="row"><code><a href="#isExported(java.lang.String,java.lang.Module)">isExported</a>​(<a href="string">String</a> pn,
          <a href="module">Module</a> other)</code></th> <td> <p>Returns <code>true</code> if this module exports the given package to at least the given module.</p> </td> </tr> <tr id="i17"> <td><code>boolean</code></td> <th scope="row"><code><a href="#isNamed()">isNamed</a>()</code></th> <td> <p>Returns <code>true</code> if this module is a named module.</p> </td> </tr> <tr id="i18"> <td><code>boolean</code></td> <th scope="row"><code><a href="#isOpen(java.lang.String)">isOpen</a>​(<a href="string">String</a> pn)</code></th> <td> <p>Returns <code>true</code> if this module has <em>opened</em> a package unconditionally.</p> </td> </tr> <tr id="i19"> <td><code>boolean</code></td> <th scope="row"><code><a href="#isOpen(java.lang.String,java.lang.Module)">isOpen</a>​(<a href="string">String</a> pn,
      <a href="module">Module</a> other)</code></th> <td> <p>Returns <code>true</code> if this module has <em>opened</em> a package to at least the given module.</p> </td> </tr> <tr id="i20"> <td><code><a href="string">String</a></code></td> <th scope="row"><code><a href="#toString()">toString</a>()</code></th> <td> <p>Returns the string representation of this module.</p> </td> </tr> </table>  <h2 id="methods.inherited.from.class.java.lang.Object">Methods declared in class java.lang.<a href="object">Object</a>
</h2> <code><a href="object#clone()">clone</a>, <a href="object#equals(java.lang.Object)">equals</a>, <a href="object#finalize()">finalize</a>, <a href="object#getClass()">getClass</a>, <a href="object#hashCode()">hashCode</a>, <a href="object#notify()">notify</a>, <a href="object#notifyAll()">notifyAll</a>, <a href="object#wait()">wait</a>, <a href="object#wait(long)">wait</a>, <a href="object#wait(long,int)">wait</a></code>  <h2 id="methods.inherited.from.class.java.lang.reflect.AnnotatedElement">Methods declared in interface java.lang.reflect.<a href="reflect/annotatedelement">AnnotatedElement</a>
</h2> <code><a href="reflect/annotatedelement#getAnnotationsByType(java.lang.Class)">getAnnotationsByType</a>, <a href="reflect/annotatedelement#getDeclaredAnnotation(java.lang.Class)">getDeclaredAnnotation</a>, <a href="reflect/annotatedelement#getDeclaredAnnotationsByType(java.lang.Class)">getDeclaredAnnotationsByType</a>, <a href="reflect/annotatedelement#isAnnotationPresent(java.lang.Class)">isAnnotationPresent</a></code>  </section>   <div>   <section role="region">  <h2 id="method.detail">Methods</h2>   <h3 id="isNamed()">isNamed</h3> <pre data-language="java">public boolean isNamed()</pre> <p>Returns <code>true</code> if this module is a named module.</p> <dl> <dt>Returns:</dt> <dd>
<code>true</code> if this is a named module</dd> <dt>See Also:</dt> <dd><a href="classloader#getUnnamedModule()"><code>ClassLoader.getUnnamedModule()</code></a></dd> </dl>    <h3 id="getName()">getName</h3> <pre data-language="java">public String getName()</pre> <p>Returns the module name or <code>null</code> if this module is an unnamed module.</p> <dl> <dt>Returns:</dt> <dd>The module name</dd> </dl>    <h3 id="getClassLoader()">getClassLoader</h3> <pre data-language="java">public ClassLoader getClassLoader()</pre> <div>
<p>Returns the <code>ClassLoader</code> for this module. </p>
<p> If there is a security manager then its <code>checkPermission</code> method if first called with a <code>RuntimePermission("getClassLoader")</code> permission to check that the caller is allowed to get access to the class loader. </p>
</div> <dl> <dt>Returns:</dt> <dd>The class loader for this module</dd> <dt>Throws:</dt> <dd>
<code><a href="securityexception">SecurityException</a></code> - If denied by the security manager</dd> </dl>    <h3 id="getDescriptor()">getDescriptor</h3> <pre data-language="java">public ModuleDescriptor getDescriptor()</pre> <p>Returns the module descriptor for this module or <code>null</code> if this module is an unnamed module.</p> <dl> <dt>Returns:</dt> <dd>The module descriptor for this module</dd> </dl>    <h3 id="getLayer()">getLayer</h3> <pre data-language="java">public ModuleLayer getLayer()</pre> <div>
<p>Returns the module layer that contains this module or <code>null</code> if this module is not in a module layer. A module layer contains named modules and therefore this method always returns <code>null</code> when invoked on an unnamed module. </p>
<p> <a href="reflect/proxy#dynamicmodule">Dynamic modules</a> are named modules that are generated at runtime. A dynamic module may or may not be in a module layer. </p>
</div> <dl> <dt>Returns:</dt> <dd>The module layer that contains this module</dd> <dt>See Also:</dt> <dd><a href="reflect/proxy"><code>Proxy</code></a></dd> </dl>    <h3 id="canRead(java.lang.Module)">canRead</h3> <pre data-language="java">public boolean canRead(Module other)</pre> <p>Indicates if this module reads the given module. This method returns <code>true</code> if invoked to test if this module reads itself. It also returns <code>true</code> if invoked on an unnamed module (as unnamed modules read all modules).</p> <dl> <dt>Parameters:</dt> <dd>
<code>other</code> - The other module</dd> <dt>Returns:</dt> <dd>
<code>true</code> if this module reads <code>other</code>
</dd> <dt>See Also:</dt> <dd><a href="#addReads(java.lang.Module)"><code>addReads(Module)</code></a></dd> </dl>    <h3 id="addReads(java.lang.Module)">addReads</h3> <pre data-language="java">public Module addReads(Module other)</pre> <p>If the caller's module is this module then update this module to read the given module. This method is a no-op if <code>other</code> is this module (all modules read themselves), this module is an unnamed module (as unnamed modules read all modules), or this module already reads <code>other</code>.</p> <dl> <dt>Implementation Note:</dt> <dd>
<em>Read edges</em> added by this method are <em>weak</em> and do not prevent <code>other</code> from being GC'ed when this module is strongly reachable.</dd> <dt>Parameters:</dt> <dd>
<code>other</code> - The other module</dd> <dt>Returns:</dt> <dd>this module</dd> <dt>Throws:</dt> <dd>
<code><a href="illegalcallerexception">IllegalCallerException</a></code> - If this is a named module and the caller's module is not this module</dd> <dt>See Also:</dt> <dd><a href="#canRead(java.lang.Module)"><code>canRead(java.lang.Module)</code></a></dd> </dl>    <h3 id="isExported(java.lang.String,java.lang.Module)">isExported</h3> <pre data-language="java">public boolean isExported(String pn,
                          Module other)</pre> <div>
<p>Returns <code>true</code> if this module exports the given package to at least the given module. </p>
<p> This method returns <code>true</code> if invoked to test if a package in this module is exported to itself. It always returns <code>true</code> when invoked on an unnamed module. A package that is <a href="#isOpen(java.lang.String,java.lang.Module)"><code>open</code></a> to the given module is considered exported to that module at run-time and so this method returns <code>true</code> if the package is open to the given module. </p> <p> This method does not check if the given module reads this module. </p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>pn</code> - The package name</dd> <dd>
<code>other</code> - The other module</dd> <dt>Returns:</dt> <dd>
<code>true</code> if this module exports the package to at least the given module</dd> <dt>See Also:</dt> <dd>
<a href="module/moduledescriptor#exports()"><code>ModuleDescriptor.exports()</code></a>, <a href="#addExports(java.lang.String,java.lang.Module)"><code>addExports(String,Module)</code></a>
</dd> </dl>    <h3 id="isOpen(java.lang.String,java.lang.Module)">isOpen</h3> <pre data-language="java">public boolean isOpen(String pn,
                      Module other)</pre> <div>
<p>Returns <code>true</code> if this module has <em>opened</em> a package to at least the given module. </p>
<p> This method returns <code>true</code> if invoked to test if a package in this module is open to itself. It returns <code>true</code> when invoked on an <a href="module/moduledescriptor#isOpen()"><code>open</code></a> module with a package in the module. It always returns <code>true</code> when invoked on an unnamed module. </p> <p> This method does not check if the given module reads this module. </p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>pn</code> - The package name</dd> <dd>
<code>other</code> - The other module</dd> <dt>Returns:</dt> <dd>
<code>true</code> if this module has <em>opened</em> the package to at least the given module</dd> <dt>See Also:</dt> <dd>
<a href="module/moduledescriptor#opens()"><code>ModuleDescriptor.opens()</code></a>, <a href="#addOpens(java.lang.String,java.lang.Module)"><code>addOpens(String,Module)</code></a>, <a href="reflect/accessibleobject#setAccessible(boolean)"><code>AccessibleObject.setAccessible(boolean)</code></a>, <a href="invoke/methodhandles#privateLookupIn(java.lang.Class,java.lang.invoke.MethodHandles.Lookup)"><code>MethodHandles.privateLookupIn(java.lang.Class&lt;?&gt;, java.lang.invoke.MethodHandles.Lookup)</code></a>
</dd> </dl>    <h3 id="isExported(java.lang.String)">isExported</h3> <pre data-language="java">public boolean isExported(String pn)</pre> <div>
<p>Returns <code>true</code> if this module exports the given package unconditionally. </p>
<p> This method always returns <code>true</code> when invoked on an unnamed module. A package that is <a href="#isOpen(java.lang.String)"><code>opened</code></a> unconditionally is considered exported unconditionally at run-time and so this method returns <code>true</code> if the package is opened unconditionally. </p> <p> This method does not check if the given module reads this module. </p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>pn</code> - The package name</dd> <dt>Returns:</dt> <dd>
<code>true</code> if this module exports the package unconditionally</dd> <dt>See Also:</dt> <dd><a href="module/moduledescriptor#exports()"><code>ModuleDescriptor.exports()</code></a></dd> </dl>    <h3 id="isOpen(java.lang.String)">isOpen</h3> <pre data-language="java">public boolean isOpen(String pn)</pre> <div>
<p>Returns <code>true</code> if this module has <em>opened</em> a package unconditionally. </p>
<p> This method always returns <code>true</code> when invoked on an unnamed module. Additionally, it always returns <code>true</code> when invoked on an <a href="module/moduledescriptor#isOpen()"><code>open</code></a> module with a package in the module. </p> <p> This method does not check if the given module reads this module. </p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>pn</code> - The package name</dd> <dt>Returns:</dt> <dd>
<code>true</code> if this module has <em>opened</em> the package unconditionally</dd> <dt>See Also:</dt> <dd><a href="module/moduledescriptor#opens()"><code>ModuleDescriptor.opens()</code></a></dd> </dl>    <h3 id="addExports(java.lang.String,java.lang.Module)">addExports</h3> <pre data-language="java">public Module addExports(String pn,
                         Module other)</pre> <div>
<p>If the caller's module is this module then update this module to export the given package to the given module. </p>
<p> This method has no effect if the package is already exported (or <em>open</em>) to the given module. </p>
</div> <dl> <dt>API Note:</dt> <dd>As specified in section 5.4.3 of the <cite>The Java™ Virtual Machine Specification </cite>, if an attempt to resolve a symbolic reference fails because of a linkage error, then subsequent attempts to resolve the reference always fail with the same error that was thrown as a result of the initial resolution attempt.</dd> <dt>Parameters:</dt> <dd>
<code>pn</code> - The package name</dd> <dd>
<code>other</code> - The module</dd> <dt>Returns:</dt> <dd>this module</dd> <dt>Throws:</dt> <dd>
<code><a href="illegalargumentexception">IllegalArgumentException</a></code> - If <code>pn</code> is <code>null</code>, or this is a named module and the package <code>pn</code> is not a package in this module</dd> <dd>
<code><a href="illegalcallerexception">IllegalCallerException</a></code> - If this is a named module and the caller's module is not this module</dd> <dt>See Also:</dt> <dd><a href="#isExported(java.lang.String,java.lang.Module)"><code>isExported(String,Module)</code></a></dd>   </dl>    <h3 id="addOpens(java.lang.String,java.lang.Module)">addOpens</h3> <pre data-language="java">public Module addOpens(String pn,
                       Module other)</pre> <div>
<p>If this module has <em>opened</em> a package to at least the caller module then update this module to open the package to the given module. Opening a package with this method allows all types in the package, and all their members, not just public types and their public members, to be reflected on by the given module when using APIs that support private access or a way to bypass or suppress default Java language access control checks. </p>
<p> This method has no effect if the package is already <em>open</em> to the given module. </p>
</div> <dl> <dt>API Note:</dt> <dd>This method can be used for cases where a <em>consumer module</em> uses a qualified opens to open a package to an <em>API module</em> but where the reflective access to the members of classes in the consumer module is delegated to code in another module. Code in the API module can use this method to open the package in the consumer module to the other module.</dd> <dt>Parameters:</dt> <dd>
<code>pn</code> - The package name</dd> <dd>
<code>other</code> - The module</dd> <dt>Returns:</dt> <dd>this module</dd> <dt>Throws:</dt> <dd>
<code><a href="illegalargumentexception">IllegalArgumentException</a></code> - If <code>pn</code> is <code>null</code>, or this is a named module and the package <code>pn</code> is not a package in this module</dd> <dd>
<code><a href="illegalcallerexception">IllegalCallerException</a></code> - If this is a named module and this module has not opened the package to at least the caller's module</dd> <dt>See Also:</dt> <dd>
<a href="#isOpen(java.lang.String,java.lang.Module)"><code>isOpen(String,Module)</code></a>, <a href="reflect/accessibleobject#setAccessible(boolean)"><code>AccessibleObject.setAccessible(boolean)</code></a>, <a href="invoke/methodhandles#privateLookupIn(java.lang.Class,java.lang.invoke.MethodHandles.Lookup)"><code>MethodHandles.privateLookupIn(java.lang.Class&lt;?&gt;, java.lang.invoke.MethodHandles.Lookup)</code></a>
</dd> </dl>    <h3 id="addUses(java.lang.Class)">addUses</h3> <pre data-language="java">public Module addUses(Class&lt;?&gt; service)</pre> <div>
<p>If the caller's module is this module then update this module to add a service dependence on the given service type. This method is intended for use by frameworks that invoke <a href="../util/serviceloader"><code>ServiceLoader</code></a> on behalf of other modules or where the framework is passed a reference to the service type by other code. This method is a no-op when invoked on an unnamed module or an automatic module. </p>
<p> This method does not cause <a href="module/configuration#resolveAndBind(java.lang.module.ModuleFinder,java.lang.module.ModuleFinder,java.util.Collection)"><code>resolveAndBind</code></a> to be re-run. </p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>service</code> - The service type</dd> <dt>Returns:</dt> <dd>this module</dd> <dt>Throws:</dt> <dd>
<code><a href="illegalcallerexception">IllegalCallerException</a></code> - If this is a named module and the caller's module is not this module</dd> <dt>See Also:</dt> <dd>
<a href="#canUse(java.lang.Class)"><code>canUse(Class)</code></a>, <a href="module/moduledescriptor#uses()"><code>ModuleDescriptor.uses()</code></a>
</dd> </dl>    <h3 id="canUse(java.lang.Class)">canUse</h3> <pre data-language="java">public boolean canUse(Class&lt;?&gt; service)</pre> <p>Indicates if this module has a service dependence on the given service type. This method always returns <code>true</code> when invoked on an unnamed module or an automatic module.</p> <dl> <dt>Parameters:</dt> <dd>
<code>service</code> - The service type</dd> <dt>Returns:</dt> <dd>
<code>true</code> if this module uses service type <code>st</code>
</dd> <dt>See Also:</dt> <dd><a href="#addUses(java.lang.Class)"><code>addUses(Class)</code></a></dd> </dl>    <h3 id="getPackages()">getPackages</h3> <pre data-language="java">public Set&lt;String&gt; getPackages()</pre> <div>
<p>Returns the set of package names for the packages in this module. </p>
<p> For named modules, the returned set contains an element for each package in the module. </p> <p> For unnamed modules, this method is the equivalent to invoking the <a href="classloader#getDefinedPackages()"><code>getDefinedPackages</code></a> method of this module's class loader and returning the set of package names. </p>
</div> <dl> <dt>Returns:</dt> <dd>the set of the package names of the packages in this module</dd> </dl>    <h3 id="getAnnotation(java.lang.Class)">getAnnotation</h3> <pre data-language="java">public &lt;T extends Annotation&gt; T getAnnotation(Class&lt;T&gt; annotationClass)</pre> <p>Returns this element's annotation for the specified type if such an annotation is <em>present</em>, else null. This method returns <code>null</code> when invoked on an unnamed module.</p> <dl> <dt>Specified by:</dt> <dd>
<code><a href="reflect/annotatedelement#getAnnotation(java.lang.Class)">getAnnotation</a></code> in interface <code><a href="reflect/annotatedelement">AnnotatedElement</a></code>
</dd> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the type of the annotation to query for and return if present</dd> <dt>Parameters:</dt> <dd>
<code>annotationClass</code> - the Class object corresponding to the annotation type</dd> <dt>Returns:</dt> <dd>this element's annotation for the specified annotation type if present on this element, else null</dd> </dl>    <h3 id="getAnnotations()">getAnnotations</h3> <pre data-language="java">public Annotation[] getAnnotations()</pre> <p>Returns annotations that are <em>present</em> on this element. If there are no annotations <em>present</em> on this element, the return value is an array of length 0. The caller of this method is free to modify the returned array; it will have no effect on the arrays returned to other callers. This method returns an empty array when invoked on an unnamed module.</p> <dl> <dt>Specified by:</dt> <dd>
<code><a href="reflect/annotatedelement#getAnnotations()">getAnnotations</a></code> in interface <code><a href="reflect/annotatedelement">AnnotatedElement</a></code>
</dd> <dt>Returns:</dt> <dd>annotations present on this element</dd> </dl>    <h3 id="getDeclaredAnnotations()">getDeclaredAnnotations</h3> <pre data-language="java">public Annotation[] getDeclaredAnnotations()</pre> <p>Returns annotations that are <em>directly present</em> on this element. This method ignores inherited annotations. If there are no annotations <em>directly present</em> on this element, the return value is an array of length 0. The caller of this method is free to modify the returned array; it will have no effect on the arrays returned to other callers. This method returns an empty array when invoked on an unnamed module.</p> <dl> <dt>Specified by:</dt> <dd>
<code><a href="reflect/annotatedelement#getDeclaredAnnotations()">getDeclaredAnnotations</a></code> in interface <code><a href="reflect/annotatedelement">AnnotatedElement</a></code>
</dd> <dt>Returns:</dt> <dd>annotations directly present on this element</dd> </dl>    <h3 id="getResourceAsStream(java.lang.String)">getResourceAsStream</h3> <pre data-language="java">public InputStream getResourceAsStream(String name)
                                throws IOException</pre> <div>
<p>Returns an input stream for reading a resource in this module. The <code>name</code> parameter is a <code>'/'</code>-separated path name that identifies the resource. As with <a href="class#getResourceAsStream(java.lang.String)"><code>Class.getResourceAsStream</code></a>, this method delegates to the module's class loader <a href="classloader#findResource(java.lang.String,java.lang.String)"><code>findResource(String,String)</code></a> method, invoking it with the module name (or <code>null</code> when the module is unnamed) and the name of the resource. If the resource name has a leading slash then it is dropped before delegation. </p>
<p> A resource in a named module may be <em>encapsulated</em> so that it cannot be located by code in other modules. Whether a resource can be located or not is determined as follows: </p> <ul> <li> If the resource name ends with "<code>.class</code>" then it is not encapsulated. </li> <li> A <em>package name</em> is derived from the resource name. If the package name is a <a href="#getPackages()">package</a> in the module then the resource can only be located by the caller of this method when the package is <a href="#isOpen(java.lang.String,java.lang.Module)">open</a> to at least the caller's module. If the resource is not in a package in the module then the resource is not encapsulated. </li> </ul> <p> In the above, the <em>package name</em> for a resource is derived from the subsequence of characters that precedes the last <code>'/'</code> in the name and then replacing each <code>'/'</code> character in the subsequence with <code>'.'</code>. A leading slash is ignored when deriving the package name. As an example, the package name derived for a resource named "<code>a/b/c/foo.properties</code>" is "<code>a.b.c</code>". A resource name with the name "<code>META-INF/MANIFEST.MF</code>" is never encapsulated because "<code>META-INF</code>" is not a legal package name. </p> <p> This method returns <code>null</code> if the resource is not in this module, the resource is encapsulated and cannot be located by the caller, or access to the resource is denied by the security manager. </p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>name</code> - The resource name</dd> <dt>Returns:</dt> <dd>An input stream for reading the resource or <code>null</code>
</dd> <dt>Throws:</dt> <dd>
<code><a href="../io/ioexception">IOException</a></code> - If an I/O error occurs</dd> <dt>See Also:</dt> <dd><a href="class#getResourceAsStream(java.lang.String)"><code>Class.getResourceAsStream(String)</code></a></dd> </dl>    <h3 id="toString()">toString</h3> <pre data-language="java">public String toString()</pre> <p>Returns the string representation of this module. For a named module, the representation is the string <code>"module"</code>, followed by a space, and then the module name. For an unnamed module, the representation is the string <code>"unnamed module"</code>, followed by a space, and then an implementation specific string that identifies the unnamed module.</p> <dl> <dt>Overrides:</dt> <dd>
<code><a href="object#toString()">toString</a></code> in class <code><a href="object">Object</a></code>
</dd> <dt>Returns:</dt> <dd>The string representation of this module</dd> </dl>   </section>  </div>  </main>  <div class="_attribution">
  <p class="_attribution-p">
    &copy; 1993, 2020, Oracle and/or its affiliates. All rights reserved.<br>Documentation extracted from Debian's OpenJDK Development Kit package.<br>Licensed under the GNU General Public License, version 2, with the Classpath Exception.<br>Various third party code in OpenJDK is licensed under different licenses (see Debian package).<br>Java and OpenJDK are trademarks or registered trademarks of Oracle and/or its affiliates.<br>
    <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Module.html" class="_attribution-link">https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Module.html</a>
  </p>
</div>
