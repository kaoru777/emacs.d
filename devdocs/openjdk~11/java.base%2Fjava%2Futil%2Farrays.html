  <main role="main">    <h1>Class Arrays</h1>   <ul class="inheritance"> <li><a href="../lang/object">java.lang.Object</a></li> <li> <ul class="inheritance"> <li>java.util.Arrays</li> </ul> </li> </ul>    <pre data-language="java">public class Arrays
extends Object</pre> <div>
<p>This class contains various methods for manipulating arrays (such as sorting and searching). This class also contains a static factory that allows arrays to be viewed as lists. </p>
<p>The methods in this class all throw a <code>NullPointerException</code>, if the specified array reference is null, except where noted. </p>
<p>The documentation for the methods contained in this class includes brief descriptions of the <i>implementations</i>. Such descriptions should be regarded as <i>implementation notes</i>, rather than parts of the <i>specification</i>. Implementors should feel free to substitute other algorithms, so long as the specification itself is adhered to. (For example, the algorithm used by <code>sort(Object[])</code> does not have to be a MergeSort, but it does have to be <i>stable</i>.) </p>
<p>This class is a member of the <a href="package-summary#CollectionsFramework"> Java Collections Framework</a>.</p>
</div> <dl> <dt>Since:</dt> <dd>1.2</dd> </dl>      <section role="region">  <h2 id="method.summary">Methods</h2> <table>  <tr> <th scope="col">Modifier and Type</th> <th scope="col">Method</th> <th scope="col">Description</th> </tr> <tr id="i0"> <td><code>static &lt;T&gt; <a href="list">List</a>&lt;T&gt;</code></td> <th scope="row"><code><a href="#asList(T...)">asList</a>​(T... a)</code></th> <td> <p>Returns a fixed-size list backed by the specified array.</p> </td> </tr> <tr id="i1"> <td><code>static int</code></td> <th scope="row"><code><a href="#binarySearch(byte%5B%5D,byte)">binarySearch</a>​(byte[] a,
            byte key)</code></th> <td> <p>Searches the specified array of bytes for the specified value using the binary search algorithm.</p> </td> </tr> <tr id="i2"> <td><code>static int</code></td> <th scope="row"><code><a href="#binarySearch(byte%5B%5D,int,int,byte)">binarySearch</a>​(byte[] a,
            int fromIndex,
            int toIndex,
            byte key)</code></th> <td> <p>Searches a range of the specified array of bytes for the specified value using the binary search algorithm.</p> </td> </tr> <tr id="i3"> <td><code>static int</code></td> <th scope="row"><code><a href="#binarySearch(char%5B%5D,char)">binarySearch</a>​(char[] a,
            char key)</code></th> <td> <p>Searches the specified array of chars for the specified value using the binary search algorithm.</p> </td> </tr> <tr id="i4"> <td><code>static int</code></td> <th scope="row"><code><a href="#binarySearch(char%5B%5D,int,int,char)">binarySearch</a>​(char[] a,
            int fromIndex,
            int toIndex,
            char key)</code></th> <td> <p>Searches a range of the specified array of chars for the specified value using the binary search algorithm.</p> </td> </tr> <tr id="i5"> <td><code>static int</code></td> <th scope="row"><code><a href="#binarySearch(double%5B%5D,double)">binarySearch</a>​(double[] a,
            double key)</code></th> <td> <p>Searches the specified array of doubles for the specified value using the binary search algorithm.</p> </td> </tr> <tr id="i6"> <td><code>static int</code></td> <th scope="row"><code><a href="#binarySearch(double%5B%5D,int,int,double)">binarySearch</a>​(double[] a,
            int fromIndex,
            int toIndex,
            double key)</code></th> <td> <p>Searches a range of the specified array of doubles for the specified value using the binary search algorithm.</p> </td> </tr> <tr id="i7"> <td><code>static int</code></td> <th scope="row"><code><a href="#binarySearch(float%5B%5D,float)">binarySearch</a>​(float[] a,
            float key)</code></th> <td> <p>Searches the specified array of floats for the specified value using the binary search algorithm.</p> </td> </tr> <tr id="i8"> <td><code>static int</code></td> <th scope="row"><code><a href="#binarySearch(float%5B%5D,int,int,float)">binarySearch</a>​(float[] a,
            int fromIndex,
            int toIndex,
            float key)</code></th> <td> <p>Searches a range of the specified array of floats for the specified value using the binary search algorithm.</p> </td> </tr> <tr id="i9"> <td><code>static int</code></td> <th scope="row"><code><a href="#binarySearch(int%5B%5D,int)">binarySearch</a>​(int[] a,
            int key)</code></th> <td> <p>Searches the specified array of ints for the specified value using the binary search algorithm.</p> </td> </tr> <tr id="i10"> <td><code>static int</code></td> <th scope="row"><code><a href="#binarySearch(int%5B%5D,int,int,int)">binarySearch</a>​(int[] a,
            int fromIndex,
            int toIndex,
            int key)</code></th> <td> <p>Searches a range of the specified array of ints for the specified value using the binary search algorithm.</p> </td> </tr> <tr id="i11"> <td><code>static int</code></td> <th scope="row"><code><a href="#binarySearch(long%5B%5D,int,int,long)">binarySearch</a>​(long[] a,
            int fromIndex,
            int toIndex,
            long key)</code></th> <td> <p>Searches a range of the specified array of longs for the specified value using the binary search algorithm.</p> </td> </tr> <tr id="i12"> <td><code>static int</code></td> <th scope="row"><code><a href="#binarySearch(long%5B%5D,long)">binarySearch</a>​(long[] a,
            long key)</code></th> <td> <p>Searches the specified array of longs for the specified value using the binary search algorithm.</p> </td> </tr> <tr id="i13"> <td><code>static int</code></td> <th scope="row"><code><a href="#binarySearch(short%5B%5D,int,int,short)">binarySearch</a>​(short[] a,
            int fromIndex,
            int toIndex,
            short key)</code></th> <td> <p>Searches a range of the specified array of shorts for the specified value using the binary search algorithm.</p> </td> </tr> <tr id="i14"> <td><code>static int</code></td> <th scope="row"><code><a href="#binarySearch(short%5B%5D,short)">binarySearch</a>​(short[] a,
            short key)</code></th> <td> <p>Searches the specified array of shorts for the specified value using the binary search algorithm.</p> </td> </tr> <tr id="i15"> <td><code>static int</code></td> <th scope="row"><code><a href="#binarySearch(java.lang.Object%5B%5D,int,int,java.lang.Object)">binarySearch</a>​(<a href="../lang/object">Object</a>[] a,
            int fromIndex,
            int toIndex,
            <a href="../lang/object">Object</a> key)</code></th> <td> <p>Searches a range of the specified array for the specified object using the binary search algorithm.</p> </td> </tr> <tr id="i16"> <td><code>static int</code></td> <th scope="row"><code><a href="#binarySearch(java.lang.Object%5B%5D,java.lang.Object)">binarySearch</a>​(<a href="../lang/object">Object</a>[] a,
            <a href="../lang/object">Object</a> key)</code></th> <td> <p>Searches the specified array for the specified object using the binary search algorithm.</p> </td> </tr> <tr id="i17"> <td><code>static &lt;T&gt; int</code></td> <th scope="row"><code><a href="#binarySearch(T%5B%5D,int,int,T,java.util.Comparator)">binarySearch</a>​(T[] a,
            int fromIndex,
            int toIndex,
            T key,
            <a href="comparator">Comparator</a>&lt;? super T&gt; c)</code></th> <td> <p>Searches a range of the specified array for the specified object using the binary search algorithm.</p> </td> </tr> <tr id="i18"> <td><code>static &lt;T&gt; int</code></td> <th scope="row"><code><a href="#binarySearch(T%5B%5D,T,java.util.Comparator)">binarySearch</a>​(T[] a,
            T key,
            <a href="comparator">Comparator</a>&lt;? super T&gt; c)</code></th> <td> <p>Searches the specified array for the specified object using the binary search algorithm.</p> </td> </tr> <tr id="i19"> <td><code>static int</code></td> <th scope="row"><code><a href="#compare(boolean%5B%5D,boolean%5B%5D)">compare</a>​(boolean[] a,
       boolean[] b)</code></th> <td> <p>Compares two <code>boolean</code> arrays lexicographically.</p> </td> </tr> <tr id="i20"> <td><code>static int</code></td> <th scope="row"><code><a href="#compare(boolean%5B%5D,int,int,boolean%5B%5D,int,int)">compare</a>​(boolean[] a,
       int aFromIndex,
       int aToIndex,
       boolean[] b,
       int bFromIndex,
       int bToIndex)</code></th> <td> <p>Compares two <code>boolean</code> arrays lexicographically over the specified ranges.</p> </td> </tr> <tr id="i21"> <td><code>static int</code></td> <th scope="row"><code><a href="#compare(byte%5B%5D,byte%5B%5D)">compare</a>​(byte[] a,
       byte[] b)</code></th> <td> <p>Compares two <code>byte</code> arrays lexicographically.</p> </td> </tr> <tr id="i22"> <td><code>static int</code></td> <th scope="row"><code><a href="#compare(byte%5B%5D,int,int,byte%5B%5D,int,int)">compare</a>​(byte[] a,
       int aFromIndex,
       int aToIndex,
       byte[] b,
       int bFromIndex,
       int bToIndex)</code></th> <td> <p>Compares two <code>byte</code> arrays lexicographically over the specified ranges.</p> </td> </tr> <tr id="i23"> <td><code>static int</code></td> <th scope="row"><code><a href="#compare(char%5B%5D,char%5B%5D)">compare</a>​(char[] a,
       char[] b)</code></th> <td> <p>Compares two <code>char</code> arrays lexicographically.</p> </td> </tr> <tr id="i24"> <td><code>static int</code></td> <th scope="row"><code><a href="#compare(char%5B%5D,int,int,char%5B%5D,int,int)">compare</a>​(char[] a,
       int aFromIndex,
       int aToIndex,
       char[] b,
       int bFromIndex,
       int bToIndex)</code></th> <td> <p>Compares two <code>char</code> arrays lexicographically over the specified ranges.</p> </td> </tr> <tr id="i25"> <td><code>static int</code></td> <th scope="row"><code><a href="#compare(double%5B%5D,double%5B%5D)">compare</a>​(double[] a,
       double[] b)</code></th> <td> <p>Compares two <code>double</code> arrays lexicographically.</p> </td> </tr> <tr id="i26"> <td><code>static int</code></td> <th scope="row"><code><a href="#compare(double%5B%5D,int,int,double%5B%5D,int,int)">compare</a>​(double[] a,
       int aFromIndex,
       int aToIndex,
       double[] b,
       int bFromIndex,
       int bToIndex)</code></th> <td> <p>Compares two <code>double</code> arrays lexicographically over the specified ranges.</p> </td> </tr> <tr id="i27"> <td><code>static int</code></td> <th scope="row"><code><a href="#compare(float%5B%5D,float%5B%5D)">compare</a>​(float[] a,
       float[] b)</code></th> <td> <p>Compares two <code>float</code> arrays lexicographically.</p> </td> </tr> <tr id="i28"> <td><code>static int</code></td> <th scope="row"><code><a href="#compare(float%5B%5D,int,int,float%5B%5D,int,int)">compare</a>​(float[] a,
       int aFromIndex,
       int aToIndex,
       float[] b,
       int bFromIndex,
       int bToIndex)</code></th> <td> <p>Compares two <code>float</code> arrays lexicographically over the specified ranges.</p> </td> </tr> <tr id="i29"> <td><code>static int</code></td> <th scope="row"><code><a href="#compare(int%5B%5D,int%5B%5D)">compare</a>​(int[] a,
       int[] b)</code></th> <td> <p>Compares two <code>int</code> arrays lexicographically.</p> </td> </tr> <tr id="i30"> <td><code>static int</code></td> <th scope="row"><code><a href="#compare(int%5B%5D,int,int,int%5B%5D,int,int)">compare</a>​(int[] a,
       int aFromIndex,
       int aToIndex,
       int[] b,
       int bFromIndex,
       int bToIndex)</code></th> <td> <p>Compares two <code>int</code> arrays lexicographically over the specified ranges.</p> </td> </tr> <tr id="i31"> <td><code>static int</code></td> <th scope="row"><code><a href="#compare(long%5B%5D,int,int,long%5B%5D,int,int)">compare</a>​(long[] a,
       int aFromIndex,
       int aToIndex,
       long[] b,
       int bFromIndex,
       int bToIndex)</code></th> <td> <p>Compares two <code>long</code> arrays lexicographically over the specified ranges.</p> </td> </tr> <tr id="i32"> <td><code>static int</code></td> <th scope="row"><code><a href="#compare(long%5B%5D,long%5B%5D)">compare</a>​(long[] a,
       long[] b)</code></th> <td> <p>Compares two <code>long</code> arrays lexicographically.</p> </td> </tr> <tr id="i33"> <td><code>static int</code></td> <th scope="row"><code><a href="#compare(short%5B%5D,int,int,short%5B%5D,int,int)">compare</a>​(short[] a,
       int aFromIndex,
       int aToIndex,
       short[] b,
       int bFromIndex,
       int bToIndex)</code></th> <td> <p>Compares two <code>short</code> arrays lexicographically over the specified ranges.</p> </td> </tr> <tr id="i34"> <td><code>static int</code></td> <th scope="row"><code><a href="#compare(short%5B%5D,short%5B%5D)">compare</a>​(short[] a,
       short[] b)</code></th> <td> <p>Compares two <code>short</code> arrays lexicographically.</p> </td> </tr> <tr id="i35"> <td><code>static &lt;T extends <a href="../lang/comparable">Comparable</a>&lt;? super T&gt;&gt;<br>int</code></td> <th scope="row"><code><a href="#compare(T%5B%5D,int,int,T%5B%5D,int,int)">compare</a>​(T[] a,
       int aFromIndex,
       int aToIndex,
       T[] b,
       int bFromIndex,
       int bToIndex)</code></th> <td> <p>Compares two <code>Object</code> arrays lexicographically over the specified ranges.</p> </td> </tr> <tr id="i36"> <td><code>static &lt;T&gt; int</code></td> <th scope="row"><code><a href="#compare(T%5B%5D,int,int,T%5B%5D,int,int,java.util.Comparator)">compare</a>​(T[] a,
       int aFromIndex,
       int aToIndex,
       T[] b,
       int bFromIndex,
       int bToIndex,
       <a href="comparator">Comparator</a>&lt;? super T&gt; cmp)</code></th> <td> <p>Compares two <code>Object</code> arrays lexicographically over the specified ranges.</p> </td> </tr> <tr id="i37"> <td><code>static &lt;T extends <a href="../lang/comparable">Comparable</a>&lt;? super T&gt;&gt;<br>int</code></td> <th scope="row"><code><a href="#compare(T%5B%5D,T%5B%5D)">compare</a>​(T[] a,
       T[] b)</code></th> <td> <p>Compares two <code>Object</code> arrays, within comparable elements, lexicographically.</p> </td> </tr> <tr id="i38"> <td><code>static &lt;T&gt; int</code></td> <th scope="row"><code><a href="#compare(T%5B%5D,T%5B%5D,java.util.Comparator)">compare</a>​(T[] a,
       T[] b,
       <a href="comparator">Comparator</a>&lt;? super T&gt; cmp)</code></th> <td> <p>Compares two <code>Object</code> arrays lexicographically using a specified comparator.</p> </td> </tr> <tr id="i39"> <td><code>static int</code></td> <th scope="row"><code><a href="#compareUnsigned(byte%5B%5D,byte%5B%5D)">compareUnsigned</a>​(byte[] a,
               byte[] b)</code></th> <td> <p>Compares two <code>byte</code> arrays lexicographically, numerically treating elements as unsigned.</p> </td> </tr> <tr id="i40"> <td><code>static int</code></td> <th scope="row"><code><a href="#compareUnsigned(byte%5B%5D,int,int,byte%5B%5D,int,int)">compareUnsigned</a>​(byte[] a,
               int aFromIndex,
               int aToIndex,
               byte[] b,
               int bFromIndex,
               int bToIndex)</code></th> <td> <p>Compares two <code>byte</code> arrays lexicographically over the specified ranges, numerically treating elements as unsigned.</p> </td> </tr> <tr id="i41"> <td><code>static int</code></td> <th scope="row"><code><a href="#compareUnsigned(int%5B%5D,int%5B%5D)">compareUnsigned</a>​(int[] a,
               int[] b)</code></th> <td> <p>Compares two <code>int</code> arrays lexicographically, numerically treating elements as unsigned.</p> </td> </tr> <tr id="i42"> <td><code>static int</code></td> <th scope="row"><code><a href="#compareUnsigned(int%5B%5D,int,int,int%5B%5D,int,int)">compareUnsigned</a>​(int[] a,
               int aFromIndex,
               int aToIndex,
               int[] b,
               int bFromIndex,
               int bToIndex)</code></th> <td> <p>Compares two <code>int</code> arrays lexicographically over the specified ranges, numerically treating elements as unsigned.</p> </td> </tr> <tr id="i43"> <td><code>static int</code></td> <th scope="row"><code><a href="#compareUnsigned(long%5B%5D,int,int,long%5B%5D,int,int)">compareUnsigned</a>​(long[] a,
               int aFromIndex,
               int aToIndex,
               long[] b,
               int bFromIndex,
               int bToIndex)</code></th> <td> <p>Compares two <code>long</code> arrays lexicographically over the specified ranges, numerically treating elements as unsigned.</p> </td> </tr> <tr id="i44"> <td><code>static int</code></td> <th scope="row"><code><a href="#compareUnsigned(long%5B%5D,long%5B%5D)">compareUnsigned</a>​(long[] a,
               long[] b)</code></th> <td> <p>Compares two <code>long</code> arrays lexicographically, numerically treating elements as unsigned.</p> </td> </tr> <tr id="i45"> <td><code>static int</code></td> <th scope="row"><code><a href="#compareUnsigned(short%5B%5D,int,int,short%5B%5D,int,int)">compareUnsigned</a>​(short[] a,
               int aFromIndex,
               int aToIndex,
               short[] b,
               int bFromIndex,
               int bToIndex)</code></th> <td> <p>Compares two <code>short</code> arrays lexicographically over the specified ranges, numerically treating elements as unsigned.</p> </td> </tr> <tr id="i46"> <td><code>static int</code></td> <th scope="row"><code><a href="#compareUnsigned(short%5B%5D,short%5B%5D)">compareUnsigned</a>​(short[] a,
               short[] b)</code></th> <td> <p>Compares two <code>short</code> arrays lexicographically, numerically treating elements as unsigned.</p> </td> </tr> <tr id="i47"> <td><code>static boolean[]</code></td> <th scope="row"><code><a href="#copyOf(boolean%5B%5D,int)">copyOf</a>​(boolean[] original,
      int newLength)</code></th> <td> <p>Copies the specified array, truncating or padding with <code>false</code> (if necessary) so the copy has the specified length.</p> </td> </tr> <tr id="i48"> <td><code>static byte[]</code></td> <th scope="row"><code><a href="#copyOf(byte%5B%5D,int)">copyOf</a>​(byte[] original,
      int newLength)</code></th> <td> <p>Copies the specified array, truncating or padding with zeros (if necessary) so the copy has the specified length.</p> </td> </tr> <tr id="i49"> <td><code>static char[]</code></td> <th scope="row"><code><a href="#copyOf(char%5B%5D,int)">copyOf</a>​(char[] original,
      int newLength)</code></th> <td> <p>Copies the specified array, truncating or padding with null characters (if necessary) so the copy has the specified length.</p> </td> </tr> <tr id="i50"> <td><code>static double[]</code></td> <th scope="row"><code><a href="#copyOf(double%5B%5D,int)">copyOf</a>​(double[] original,
      int newLength)</code></th> <td> <p>Copies the specified array, truncating or padding with zeros (if necessary) so the copy has the specified length.</p> </td> </tr> <tr id="i51"> <td><code>static float[]</code></td> <th scope="row"><code><a href="#copyOf(float%5B%5D,int)">copyOf</a>​(float[] original,
      int newLength)</code></th> <td> <p>Copies the specified array, truncating or padding with zeros (if necessary) so the copy has the specified length.</p> </td> </tr> <tr id="i52"> <td><code>static int[]</code></td> <th scope="row"><code><a href="#copyOf(int%5B%5D,int)">copyOf</a>​(int[] original,
      int newLength)</code></th> <td> <p>Copies the specified array, truncating or padding with zeros (if necessary) so the copy has the specified length.</p> </td> </tr> <tr id="i53"> <td><code>static long[]</code></td> <th scope="row"><code><a href="#copyOf(long%5B%5D,int)">copyOf</a>​(long[] original,
      int newLength)</code></th> <td> <p>Copies the specified array, truncating or padding with zeros (if necessary) so the copy has the specified length.</p> </td> </tr> <tr id="i54"> <td><code>static short[]</code></td> <th scope="row"><code><a href="#copyOf(short%5B%5D,int)">copyOf</a>​(short[] original,
      int newLength)</code></th> <td> <p>Copies the specified array, truncating or padding with zeros (if necessary) so the copy has the specified length.</p> </td> </tr> <tr id="i55"> <td><code>static &lt;T&gt; T[]</code></td> <th scope="row"><code><a href="#copyOf(T%5B%5D,int)">copyOf</a>​(T[] original,
      int newLength)</code></th> <td> <p>Copies the specified array, truncating or padding with nulls (if necessary) so the copy has the specified length.</p> </td> </tr> <tr id="i56"> <td><code>static &lt;T,​U&gt;<br>T[]</code></td> <th scope="row"><code><a href="#copyOf(U%5B%5D,int,java.lang.Class)">copyOf</a>​(U[] original,
      int newLength,
      <a href="../lang/class">Class</a>&lt;? extends T[]&gt; newType)</code></th> <td> <p>Copies the specified array, truncating or padding with nulls (if necessary) so the copy has the specified length.</p> </td> </tr> <tr id="i57"> <td><code>static boolean[]</code></td> <th scope="row"><code><a href="#copyOfRange(boolean%5B%5D,int,int)">copyOfRange</a>​(boolean[] original,
           int from,
           int to)</code></th> <td> <p>Copies the specified range of the specified array into a new array.</p> </td> </tr> <tr id="i58"> <td><code>static byte[]</code></td> <th scope="row"><code><a href="#copyOfRange(byte%5B%5D,int,int)">copyOfRange</a>​(byte[] original,
           int from,
           int to)</code></th> <td> <p>Copies the specified range of the specified array into a new array.</p> </td> </tr> <tr id="i59"> <td><code>static char[]</code></td> <th scope="row"><code><a href="#copyOfRange(char%5B%5D,int,int)">copyOfRange</a>​(char[] original,
           int from,
           int to)</code></th> <td> <p>Copies the specified range of the specified array into a new array.</p> </td> </tr> <tr id="i60"> <td><code>static double[]</code></td> <th scope="row"><code><a href="#copyOfRange(double%5B%5D,int,int)">copyOfRange</a>​(double[] original,
           int from,
           int to)</code></th> <td> <p>Copies the specified range of the specified array into a new array.</p> </td> </tr> <tr id="i61"> <td><code>static float[]</code></td> <th scope="row"><code><a href="#copyOfRange(float%5B%5D,int,int)">copyOfRange</a>​(float[] original,
           int from,
           int to)</code></th> <td> <p>Copies the specified range of the specified array into a new array.</p> </td> </tr> <tr id="i62"> <td><code>static int[]</code></td> <th scope="row"><code><a href="#copyOfRange(int%5B%5D,int,int)">copyOfRange</a>​(int[] original,
           int from,
           int to)</code></th> <td> <p>Copies the specified range of the specified array into a new array.</p> </td> </tr> <tr id="i63"> <td><code>static long[]</code></td> <th scope="row"><code><a href="#copyOfRange(long%5B%5D,int,int)">copyOfRange</a>​(long[] original,
           int from,
           int to)</code></th> <td> <p>Copies the specified range of the specified array into a new array.</p> </td> </tr> <tr id="i64"> <td><code>static short[]</code></td> <th scope="row"><code><a href="#copyOfRange(short%5B%5D,int,int)">copyOfRange</a>​(short[] original,
           int from,
           int to)</code></th> <td> <p>Copies the specified range of the specified array into a new array.</p> </td> </tr> <tr id="i65"> <td><code>static &lt;T&gt; T[]</code></td> <th scope="row"><code><a href="#copyOfRange(T%5B%5D,int,int)">copyOfRange</a>​(T[] original,
           int from,
           int to)</code></th> <td> <p>Copies the specified range of the specified array into a new array.</p> </td> </tr> <tr id="i66"> <td><code>static &lt;T,​U&gt;<br>T[]</code></td> <th scope="row"><code><a href="#copyOfRange(U%5B%5D,int,int,java.lang.Class)">copyOfRange</a>​(U[] original,
           int from,
           int to,
           <a href="../lang/class">Class</a>&lt;? extends T[]&gt; newType)</code></th> <td> <p>Copies the specified range of the specified array into a new array.</p> </td> </tr> <tr id="i67"> <td><code>static boolean</code></td> <th scope="row"><code><a href="#deepEquals(java.lang.Object%5B%5D,java.lang.Object%5B%5D)">deepEquals</a>​(<a href="../lang/object">Object</a>[] a1,
          <a href="../lang/object">Object</a>[] a2)</code></th> <td> <p>Returns <code>true</code> if the two specified arrays are <i>deeply equal</i> to one another.</p> </td> </tr> <tr id="i68"> <td><code>static int</code></td> <th scope="row"><code><a href="#deepHashCode(java.lang.Object%5B%5D)">deepHashCode</a>​(<a href="../lang/object">Object</a>[] a)</code></th> <td> <p>Returns a hash code based on the "deep contents" of the specified array.</p> </td> </tr> <tr id="i69"> <td><code>static <a href="../lang/string">String</a></code></td> <th scope="row"><code><a href="#deepToString(java.lang.Object%5B%5D)">deepToString</a>​(<a href="../lang/object">Object</a>[] a)</code></th> <td> <p>Returns a string representation of the "deep contents" of the specified array.</p> </td> </tr> <tr id="i70"> <td><code>static boolean</code></td> <th scope="row"><code><a href="#equals(boolean%5B%5D,boolean%5B%5D)">equals</a>​(boolean[] a,
      boolean[] a2)</code></th> <td> <p>Returns <code>true</code> if the two specified arrays of booleans are <i>equal</i> to one another.</p> </td> </tr> <tr id="i71"> <td><code>static boolean</code></td> <th scope="row"><code><a href="#equals(boolean%5B%5D,int,int,boolean%5B%5D,int,int)">equals</a>​(boolean[] a,
      int aFromIndex,
      int aToIndex,
      boolean[] b,
      int bFromIndex,
      int bToIndex)</code></th> <td> <p>Returns true if the two specified arrays of booleans, over the specified ranges, are <i>equal</i> to one another.</p> </td> </tr> <tr id="i72"> <td><code>static boolean</code></td> <th scope="row"><code><a href="#equals(byte%5B%5D,byte%5B%5D)">equals</a>​(byte[] a,
      byte[] a2)</code></th> <td> <p>Returns <code>true</code> if the two specified arrays of bytes are <i>equal</i> to one another.</p> </td> </tr> <tr id="i73"> <td><code>static boolean</code></td> <th scope="row"><code><a href="#equals(byte%5B%5D,int,int,byte%5B%5D,int,int)">equals</a>​(byte[] a,
      int aFromIndex,
      int aToIndex,
      byte[] b,
      int bFromIndex,
      int bToIndex)</code></th> <td> <p>Returns true if the two specified arrays of bytes, over the specified ranges, are <i>equal</i> to one another.</p> </td> </tr> <tr id="i74"> <td><code>static boolean</code></td> <th scope="row"><code><a href="#equals(char%5B%5D,char%5B%5D)">equals</a>​(char[] a,
      char[] a2)</code></th> <td> <p>Returns <code>true</code> if the two specified arrays of chars are <i>equal</i> to one another.</p> </td> </tr> <tr id="i75"> <td><code>static boolean</code></td> <th scope="row"><code><a href="#equals(char%5B%5D,int,int,char%5B%5D,int,int)">equals</a>​(char[] a,
      int aFromIndex,
      int aToIndex,
      char[] b,
      int bFromIndex,
      int bToIndex)</code></th> <td> <p>Returns true if the two specified arrays of chars, over the specified ranges, are <i>equal</i> to one another.</p> </td> </tr> <tr id="i76"> <td><code>static boolean</code></td> <th scope="row"><code><a href="#equals(double%5B%5D,double%5B%5D)">equals</a>​(double[] a,
      double[] a2)</code></th> <td> <p>Returns <code>true</code> if the two specified arrays of doubles are <i>equal</i> to one another.</p> </td> </tr> <tr id="i77"> <td><code>static boolean</code></td> <th scope="row"><code><a href="#equals(double%5B%5D,int,int,double%5B%5D,int,int)">equals</a>​(double[] a,
      int aFromIndex,
      int aToIndex,
      double[] b,
      int bFromIndex,
      int bToIndex)</code></th> <td> <p>Returns true if the two specified arrays of doubles, over the specified ranges, are <i>equal</i> to one another.</p> </td> </tr> <tr id="i78"> <td><code>static boolean</code></td> <th scope="row"><code><a href="#equals(float%5B%5D,float%5B%5D)">equals</a>​(float[] a,
      float[] a2)</code></th> <td> <p>Returns <code>true</code> if the two specified arrays of floats are <i>equal</i> to one another.</p> </td> </tr> <tr id="i79"> <td><code>static boolean</code></td> <th scope="row"><code><a href="#equals(float%5B%5D,int,int,float%5B%5D,int,int)">equals</a>​(float[] a,
      int aFromIndex,
      int aToIndex,
      float[] b,
      int bFromIndex,
      int bToIndex)</code></th> <td> <p>Returns true if the two specified arrays of floats, over the specified ranges, are <i>equal</i> to one another.</p> </td> </tr> <tr id="i80"> <td><code>static boolean</code></td> <th scope="row"><code><a href="#equals(int%5B%5D,int%5B%5D)">equals</a>​(int[] a,
      int[] a2)</code></th> <td> <p>Returns <code>true</code> if the two specified arrays of ints are <i>equal</i> to one another.</p> </td> </tr> <tr id="i81"> <td><code>static boolean</code></td> <th scope="row"><code><a href="#equals(int%5B%5D,int,int,int%5B%5D,int,int)">equals</a>​(int[] a,
      int aFromIndex,
      int aToIndex,
      int[] b,
      int bFromIndex,
      int bToIndex)</code></th> <td> <p>Returns true if the two specified arrays of ints, over the specified ranges, are <i>equal</i> to one another.</p> </td> </tr> <tr id="i82"> <td><code>static boolean</code></td> <th scope="row"><code><a href="#equals(long%5B%5D,int,int,long%5B%5D,int,int)">equals</a>​(long[] a,
      int aFromIndex,
      int aToIndex,
      long[] b,
      int bFromIndex,
      int bToIndex)</code></th> <td> <p>Returns true if the two specified arrays of longs, over the specified ranges, are <i>equal</i> to one another.</p> </td> </tr> <tr id="i83"> <td><code>static boolean</code></td> <th scope="row"><code><a href="#equals(long%5B%5D,long%5B%5D)">equals</a>​(long[] a,
      long[] a2)</code></th> <td> <p>Returns <code>true</code> if the two specified arrays of longs are <i>equal</i> to one another.</p> </td> </tr> <tr id="i84"> <td><code>static boolean</code></td> <th scope="row"><code><a href="#equals(short%5B%5D,int,int,short%5B%5D,int,int)">equals</a>​(short[] a,
      int aFromIndex,
      int aToIndex,
      short[] b,
      int bFromIndex,
      int bToIndex)</code></th> <td> <p>Returns true if the two specified arrays of shorts, over the specified ranges, are <i>equal</i> to one another.</p> </td> </tr> <tr id="i85"> <td><code>static boolean</code></td> <th scope="row"><code><a href="#equals(short%5B%5D,short%5B%5D)">equals</a>​(short[] a,
      short[] a2)</code></th> <td> <p>Returns <code>true</code> if the two specified arrays of shorts are <i>equal</i> to one another.</p> </td> </tr> <tr id="i86"> <td><code>static boolean</code></td> <th scope="row"><code><a href="#equals(java.lang.Object%5B%5D,int,int,java.lang.Object%5B%5D,int,int)">equals</a>​(<a href="../lang/object">Object</a>[] a,
      int aFromIndex,
      int aToIndex,
      <a href="../lang/object">Object</a>[] b,
      int bFromIndex,
      int bToIndex)</code></th> <td> <p>Returns true if the two specified arrays of Objects, over the specified ranges, are <i>equal</i> to one another.</p> </td> </tr> <tr id="i87"> <td><code>static boolean</code></td> <th scope="row"><code><a href="#equals(java.lang.Object%5B%5D,java.lang.Object%5B%5D)">equals</a>​(<a href="../lang/object">Object</a>[] a,
      <a href="../lang/object">Object</a>[] a2)</code></th> <td> <p>Returns <code>true</code> if the two specified arrays of Objects are <i>equal</i> to one another.</p> </td> </tr> <tr id="i88"> <td><code>static &lt;T&gt; boolean</code></td> <th scope="row"><code><a href="#equals(T%5B%5D,int,int,T%5B%5D,int,int,java.util.Comparator)">equals</a>​(T[] a,
      int aFromIndex,
      int aToIndex,
      T[] b,
      int bFromIndex,
      int bToIndex,
      <a href="comparator">Comparator</a>&lt;? super T&gt; cmp)</code></th> <td> <p>Returns true if the two specified arrays of Objects, over the specified ranges, are <i>equal</i> to one another.</p> </td> </tr> <tr id="i89"> <td><code>static &lt;T&gt; boolean</code></td> <th scope="row"><code><a href="#equals(T%5B%5D,T%5B%5D,java.util.Comparator)">equals</a>​(T[] a,
      T[] a2,
      <a href="comparator">Comparator</a>&lt;? super T&gt; cmp)</code></th> <td> <p>Returns <code>true</code> if the two specified arrays of Objects are <i>equal</i> to one another.</p> </td> </tr> <tr id="i90"> <td><code>static void</code></td> <th scope="row"><code><a href="#fill(boolean%5B%5D,boolean)">fill</a>​(boolean[] a,
    boolean val)</code></th> <td> <p>Assigns the specified boolean value to each element of the specified array of booleans.</p> </td> </tr> <tr id="i91"> <td><code>static void</code></td> <th scope="row"><code><a href="#fill(boolean%5B%5D,int,int,boolean)">fill</a>​(boolean[] a,
    int fromIndex,
    int toIndex,
    boolean val)</code></th> <td> <p>Assigns the specified boolean value to each element of the specified range of the specified array of booleans.</p> </td> </tr> <tr id="i92"> <td><code>static void</code></td> <th scope="row"><code><a href="#fill(byte%5B%5D,byte)">fill</a>​(byte[] a,
    byte val)</code></th> <td> <p>Assigns the specified byte value to each element of the specified array of bytes.</p> </td> </tr> <tr id="i93"> <td><code>static void</code></td> <th scope="row"><code><a href="#fill(byte%5B%5D,int,int,byte)">fill</a>​(byte[] a,
    int fromIndex,
    int toIndex,
    byte val)</code></th> <td> <p>Assigns the specified byte value to each element of the specified range of the specified array of bytes.</p> </td> </tr> <tr id="i94"> <td><code>static void</code></td> <th scope="row"><code><a href="#fill(char%5B%5D,char)">fill</a>​(char[] a,
    char val)</code></th> <td> <p>Assigns the specified char value to each element of the specified array of chars.</p> </td> </tr> <tr id="i95"> <td><code>static void</code></td> <th scope="row"><code><a href="#fill(char%5B%5D,int,int,char)">fill</a>​(char[] a,
    int fromIndex,
    int toIndex,
    char val)</code></th> <td> <p>Assigns the specified char value to each element of the specified range of the specified array of chars.</p> </td> </tr> <tr id="i96"> <td><code>static void</code></td> <th scope="row"><code><a href="#fill(double%5B%5D,double)">fill</a>​(double[] a,
    double val)</code></th> <td> <p>Assigns the specified double value to each element of the specified array of doubles.</p> </td> </tr> <tr id="i97"> <td><code>static void</code></td> <th scope="row"><code><a href="#fill(double%5B%5D,int,int,double)">fill</a>​(double[] a,
    int fromIndex,
    int toIndex,
    double val)</code></th> <td> <p>Assigns the specified double value to each element of the specified range of the specified array of doubles.</p> </td> </tr> <tr id="i98"> <td><code>static void</code></td> <th scope="row"><code><a href="#fill(float%5B%5D,float)">fill</a>​(float[] a,
    float val)</code></th> <td> <p>Assigns the specified float value to each element of the specified array of floats.</p> </td> </tr> <tr id="i99"> <td><code>static void</code></td> <th scope="row"><code><a href="#fill(float%5B%5D,int,int,float)">fill</a>​(float[] a,
    int fromIndex,
    int toIndex,
    float val)</code></th> <td> <p>Assigns the specified float value to each element of the specified range of the specified array of floats.</p> </td> </tr> <tr id="i100"> <td><code>static void</code></td> <th scope="row"><code><a href="#fill(int%5B%5D,int)">fill</a>​(int[] a,
    int val)</code></th> <td> <p>Assigns the specified int value to each element of the specified array of ints.</p> </td> </tr> <tr id="i101"> <td><code>static void</code></td> <th scope="row"><code><a href="#fill(int%5B%5D,int,int,int)">fill</a>​(int[] a,
    int fromIndex,
    int toIndex,
    int val)</code></th> <td> <p>Assigns the specified int value to each element of the specified range of the specified array of ints.</p> </td> </tr> <tr id="i102"> <td><code>static void</code></td> <th scope="row"><code><a href="#fill(long%5B%5D,int,int,long)">fill</a>​(long[] a,
    int fromIndex,
    int toIndex,
    long val)</code></th> <td> <p>Assigns the specified long value to each element of the specified range of the specified array of longs.</p> </td> </tr> <tr id="i103"> <td><code>static void</code></td> <th scope="row"><code><a href="#fill(long%5B%5D,long)">fill</a>​(long[] a,
    long val)</code></th> <td> <p>Assigns the specified long value to each element of the specified array of longs.</p> </td> </tr> <tr id="i104"> <td><code>static void</code></td> <th scope="row"><code><a href="#fill(short%5B%5D,int,int,short)">fill</a>​(short[] a,
    int fromIndex,
    int toIndex,
    short val)</code></th> <td> <p>Assigns the specified short value to each element of the specified range of the specified array of shorts.</p> </td> </tr> <tr id="i105"> <td><code>static void</code></td> <th scope="row"><code><a href="#fill(short%5B%5D,short)">fill</a>​(short[] a,
    short val)</code></th> <td> <p>Assigns the specified short value to each element of the specified array of shorts.</p> </td> </tr> <tr id="i106"> <td><code>static void</code></td> <th scope="row"><code><a href="#fill(java.lang.Object%5B%5D,int,int,java.lang.Object)">fill</a>​(<a href="../lang/object">Object</a>[] a,
    int fromIndex,
    int toIndex,
    <a href="../lang/object">Object</a> val)</code></th> <td> <p>Assigns the specified Object reference to each element of the specified range of the specified array of Objects.</p> </td> </tr> <tr id="i107"> <td><code>static void</code></td> <th scope="row"><code><a href="#fill(java.lang.Object%5B%5D,java.lang.Object)">fill</a>​(<a href="../lang/object">Object</a>[] a,
    <a href="../lang/object">Object</a> val)</code></th> <td> <p>Assigns the specified Object reference to each element of the specified array of Objects.</p> </td> </tr> <tr id="i108"> <td><code>static int</code></td> <th scope="row"><code><a href="#hashCode(boolean%5B%5D)">hashCode</a>​(boolean[] a)</code></th> <td> <p>Returns a hash code based on the contents of the specified array.</p> </td> </tr> <tr id="i109"> <td><code>static int</code></td> <th scope="row"><code><a href="#hashCode(byte%5B%5D)">hashCode</a>​(byte[] a)</code></th> <td> <p>Returns a hash code based on the contents of the specified array.</p> </td> </tr> <tr id="i110"> <td><code>static int</code></td> <th scope="row"><code><a href="#hashCode(char%5B%5D)">hashCode</a>​(char[] a)</code></th> <td> <p>Returns a hash code based on the contents of the specified array.</p> </td> </tr> <tr id="i111"> <td><code>static int</code></td> <th scope="row"><code><a href="#hashCode(double%5B%5D)">hashCode</a>​(double[] a)</code></th> <td> <p>Returns a hash code based on the contents of the specified array.</p> </td> </tr> <tr id="i112"> <td><code>static int</code></td> <th scope="row"><code><a href="#hashCode(float%5B%5D)">hashCode</a>​(float[] a)</code></th> <td> <p>Returns a hash code based on the contents of the specified array.</p> </td> </tr> <tr id="i113"> <td><code>static int</code></td> <th scope="row"><code><a href="#hashCode(int%5B%5D)">hashCode</a>​(int[] a)</code></th> <td> <p>Returns a hash code based on the contents of the specified array.</p> </td> </tr> <tr id="i114"> <td><code>static int</code></td> <th scope="row"><code><a href="#hashCode(long%5B%5D)">hashCode</a>​(long[] a)</code></th> <td> <p>Returns a hash code based on the contents of the specified array.</p> </td> </tr> <tr id="i115"> <td><code>static int</code></td> <th scope="row"><code><a href="#hashCode(short%5B%5D)">hashCode</a>​(short[] a)</code></th> <td> <p>Returns a hash code based on the contents of the specified array.</p> </td> </tr> <tr id="i116"> <td><code>static int</code></td> <th scope="row"><code><a href="#hashCode(java.lang.Object%5B%5D)">hashCode</a>​(<a href="../lang/object">Object</a>[] a)</code></th> <td> <p>Returns a hash code based on the contents of the specified array.</p> </td> </tr> <tr id="i117"> <td><code>static int</code></td> <th scope="row"><code><a href="#mismatch(boolean%5B%5D,boolean%5B%5D)">mismatch</a>​(boolean[] a,
        boolean[] b)</code></th> <td> <p>Finds and returns the index of the first mismatch between two <code>boolean</code> arrays, otherwise return -1 if no mismatch is found.</p> </td> </tr> <tr id="i118"> <td><code>static int</code></td> <th scope="row"><code><a href="#mismatch(boolean%5B%5D,int,int,boolean%5B%5D,int,int)">mismatch</a>​(boolean[] a,
        int aFromIndex,
        int aToIndex,
        boolean[] b,
        int bFromIndex,
        int bToIndex)</code></th> <td> <p>Finds and returns the relative index of the first mismatch between two <code>boolean</code> arrays over the specified ranges, otherwise return -1 if no mismatch is found.</p> </td> </tr> <tr id="i119"> <td><code>static int</code></td> <th scope="row"><code><a href="#mismatch(byte%5B%5D,byte%5B%5D)">mismatch</a>​(byte[] a,
        byte[] b)</code></th> <td> <p>Finds and returns the index of the first mismatch between two <code>byte</code> arrays, otherwise return -1 if no mismatch is found.</p> </td> </tr> <tr id="i120"> <td><code>static int</code></td> <th scope="row"><code><a href="#mismatch(byte%5B%5D,int,int,byte%5B%5D,int,int)">mismatch</a>​(byte[] a,
        int aFromIndex,
        int aToIndex,
        byte[] b,
        int bFromIndex,
        int bToIndex)</code></th> <td> <p>Finds and returns the relative index of the first mismatch between two <code>byte</code> arrays over the specified ranges, otherwise return -1 if no mismatch is found.</p> </td> </tr> <tr id="i121"> <td><code>static int</code></td> <th scope="row"><code><a href="#mismatch(char%5B%5D,char%5B%5D)">mismatch</a>​(char[] a,
        char[] b)</code></th> <td> <p>Finds and returns the index of the first mismatch between two <code>char</code> arrays, otherwise return -1 if no mismatch is found.</p> </td> </tr> <tr id="i122"> <td><code>static int</code></td> <th scope="row"><code><a href="#mismatch(char%5B%5D,int,int,char%5B%5D,int,int)">mismatch</a>​(char[] a,
        int aFromIndex,
        int aToIndex,
        char[] b,
        int bFromIndex,
        int bToIndex)</code></th> <td> <p>Finds and returns the relative index of the first mismatch between two <code>char</code> arrays over the specified ranges, otherwise return -1 if no mismatch is found.</p> </td> </tr> <tr id="i123"> <td><code>static int</code></td> <th scope="row"><code><a href="#mismatch(double%5B%5D,double%5B%5D)">mismatch</a>​(double[] a,
        double[] b)</code></th> <td> <p>Finds and returns the index of the first mismatch between two <code>double</code> arrays, otherwise return -1 if no mismatch is found.</p> </td> </tr> <tr id="i124"> <td><code>static int</code></td> <th scope="row"><code><a href="#mismatch(double%5B%5D,int,int,double%5B%5D,int,int)">mismatch</a>​(double[] a,
        int aFromIndex,
        int aToIndex,
        double[] b,
        int bFromIndex,
        int bToIndex)</code></th> <td> <p>Finds and returns the relative index of the first mismatch between two <code>double</code> arrays over the specified ranges, otherwise return -1 if no mismatch is found.</p> </td> </tr> <tr id="i125"> <td><code>static int</code></td> <th scope="row"><code><a href="#mismatch(float%5B%5D,float%5B%5D)">mismatch</a>​(float[] a,
        float[] b)</code></th> <td> <p>Finds and returns the index of the first mismatch between two <code>float</code> arrays, otherwise return -1 if no mismatch is found.</p> </td> </tr> <tr id="i126"> <td><code>static int</code></td> <th scope="row"><code><a href="#mismatch(float%5B%5D,int,int,float%5B%5D,int,int)">mismatch</a>​(float[] a,
        int aFromIndex,
        int aToIndex,
        float[] b,
        int bFromIndex,
        int bToIndex)</code></th> <td> <p>Finds and returns the relative index of the first mismatch between two <code>float</code> arrays over the specified ranges, otherwise return -1 if no mismatch is found.</p> </td> </tr> <tr id="i127"> <td><code>static int</code></td> <th scope="row"><code><a href="#mismatch(int%5B%5D,int%5B%5D)">mismatch</a>​(int[] a,
        int[] b)</code></th> <td> <p>Finds and returns the index of the first mismatch between two <code>int</code> arrays, otherwise return -1 if no mismatch is found.</p> </td> </tr> <tr id="i128"> <td><code>static int</code></td> <th scope="row"><code><a href="#mismatch(int%5B%5D,int,int,int%5B%5D,int,int)">mismatch</a>​(int[] a,
        int aFromIndex,
        int aToIndex,
        int[] b,
        int bFromIndex,
        int bToIndex)</code></th> <td> <p>Finds and returns the relative index of the first mismatch between two <code>int</code> arrays over the specified ranges, otherwise return -1 if no mismatch is found.</p> </td> </tr> <tr id="i129"> <td><code>static int</code></td> <th scope="row"><code><a href="#mismatch(long%5B%5D,int,int,long%5B%5D,int,int)">mismatch</a>​(long[] a,
        int aFromIndex,
        int aToIndex,
        long[] b,
        int bFromIndex,
        int bToIndex)</code></th> <td> <p>Finds and returns the relative index of the first mismatch between two <code>long</code> arrays over the specified ranges, otherwise return -1 if no mismatch is found.</p> </td> </tr> <tr id="i130"> <td><code>static int</code></td> <th scope="row"><code><a href="#mismatch(long%5B%5D,long%5B%5D)">mismatch</a>​(long[] a,
        long[] b)</code></th> <td> <p>Finds and returns the index of the first mismatch between two <code>long</code> arrays, otherwise return -1 if no mismatch is found.</p> </td> </tr> <tr id="i131"> <td><code>static int</code></td> <th scope="row"><code><a href="#mismatch(short%5B%5D,int,int,short%5B%5D,int,int)">mismatch</a>​(short[] a,
        int aFromIndex,
        int aToIndex,
        short[] b,
        int bFromIndex,
        int bToIndex)</code></th> <td> <p>Finds and returns the relative index of the first mismatch between two <code>short</code> arrays over the specified ranges, otherwise return -1 if no mismatch is found.</p> </td> </tr> <tr id="i132"> <td><code>static int</code></td> <th scope="row"><code><a href="#mismatch(short%5B%5D,short%5B%5D)">mismatch</a>​(short[] a,
        short[] b)</code></th> <td> <p>Finds and returns the index of the first mismatch between two <code>short</code> arrays, otherwise return -1 if no mismatch is found.</p> </td> </tr> <tr id="i133"> <td><code>static int</code></td> <th scope="row"><code><a href="#mismatch(java.lang.Object%5B%5D,int,int,java.lang.Object%5B%5D,int,int)">mismatch</a>​(<a href="../lang/object">Object</a>[] a,
        int aFromIndex,
        int aToIndex,
        <a href="../lang/object">Object</a>[] b,
        int bFromIndex,
        int bToIndex)</code></th> <td> <p>Finds and returns the relative index of the first mismatch between two <code>Object</code> arrays over the specified ranges, otherwise return -1 if no mismatch is found.</p> </td> </tr> <tr id="i134"> <td><code>static int</code></td> <th scope="row"><code><a href="#mismatch(java.lang.Object%5B%5D,java.lang.Object%5B%5D)">mismatch</a>​(<a href="../lang/object">Object</a>[] a,
        <a href="../lang/object">Object</a>[] b)</code></th> <td> <p>Finds and returns the index of the first mismatch between two <code>Object</code> arrays, otherwise return -1 if no mismatch is found.</p> </td> </tr> <tr id="i135"> <td><code>static &lt;T&gt; int</code></td> <th scope="row"><code><a href="#mismatch(T%5B%5D,int,int,T%5B%5D,int,int,java.util.Comparator)">mismatch</a>​(T[] a,
        int aFromIndex,
        int aToIndex,
        T[] b,
        int bFromIndex,
        int bToIndex,
        <a href="comparator">Comparator</a>&lt;? super T&gt; cmp)</code></th> <td> <p>Finds and returns the relative index of the first mismatch between two <code>Object</code> arrays over the specified ranges, otherwise return -1 if no mismatch is found.</p> </td> </tr> <tr id="i136"> <td><code>static &lt;T&gt; int</code></td> <th scope="row"><code><a href="#mismatch(T%5B%5D,T%5B%5D,java.util.Comparator)">mismatch</a>​(T[] a,
        T[] b,
        <a href="comparator">Comparator</a>&lt;? super T&gt; cmp)</code></th> <td> <p>Finds and returns the index of the first mismatch between two <code>Object</code> arrays, otherwise return -1 if no mismatch is found.</p> </td> </tr> <tr id="i137"> <td><code>static void</code></td> <th scope="row"><code><a href="#parallelPrefix(double%5B%5D,int,int,java.util.function.DoubleBinaryOperator)">parallelPrefix</a>​(double[] array,
              int fromIndex,
              int toIndex,
              <a href="function/doublebinaryoperator">DoubleBinaryOperator</a> op)</code></th> <td> <p>Performs <a href="#parallelPrefix(double%5B%5D,java.util.function.DoubleBinaryOperator)"><code>parallelPrefix(double[], DoubleBinaryOperator)</code></a> for the given subrange of the array.</p> </td> </tr> <tr id="i138"> <td><code>static void</code></td> <th scope="row"><code><a href="#parallelPrefix(double%5B%5D,java.util.function.DoubleBinaryOperator)">parallelPrefix</a>​(double[] array,
              <a href="function/doublebinaryoperator">DoubleBinaryOperator</a> op)</code></th> <td> <p>Cumulates, in parallel, each element of the given array in place, using the supplied function.</p> </td> </tr> <tr id="i139"> <td><code>static void</code></td> <th scope="row"><code><a href="#parallelPrefix(int%5B%5D,int,int,java.util.function.IntBinaryOperator)">parallelPrefix</a>​(int[] array,
              int fromIndex,
              int toIndex,
              <a href="function/intbinaryoperator">IntBinaryOperator</a> op)</code></th> <td> <p>Performs <a href="#parallelPrefix(int%5B%5D,java.util.function.IntBinaryOperator)"><code>parallelPrefix(int[], IntBinaryOperator)</code></a> for the given subrange of the array.</p> </td> </tr> <tr id="i140"> <td><code>static void</code></td> <th scope="row"><code><a href="#parallelPrefix(int%5B%5D,java.util.function.IntBinaryOperator)">parallelPrefix</a>​(int[] array,
              <a href="function/intbinaryoperator">IntBinaryOperator</a> op)</code></th> <td> <p>Cumulates, in parallel, each element of the given array in place, using the supplied function.</p> </td> </tr> <tr id="i141"> <td><code>static void</code></td> <th scope="row"><code><a href="#parallelPrefix(long%5B%5D,int,int,java.util.function.LongBinaryOperator)">parallelPrefix</a>​(long[] array,
              int fromIndex,
              int toIndex,
              <a href="function/longbinaryoperator">LongBinaryOperator</a> op)</code></th> <td> <p>Performs <a href="#parallelPrefix(long%5B%5D,java.util.function.LongBinaryOperator)"><code>parallelPrefix(long[], LongBinaryOperator)</code></a> for the given subrange of the array.</p> </td> </tr> <tr id="i142"> <td><code>static void</code></td> <th scope="row"><code><a href="#parallelPrefix(long%5B%5D,java.util.function.LongBinaryOperator)">parallelPrefix</a>​(long[] array,
              <a href="function/longbinaryoperator">LongBinaryOperator</a> op)</code></th> <td> <p>Cumulates, in parallel, each element of the given array in place, using the supplied function.</p> </td> </tr> <tr id="i143"> <td><code>static &lt;T&gt; void</code></td> <th scope="row"><code><a href="#parallelPrefix(T%5B%5D,int,int,java.util.function.BinaryOperator)">parallelPrefix</a>​(T[] array,
              int fromIndex,
              int toIndex,
              <a href="function/binaryoperator">BinaryOperator</a>&lt;T&gt; op)</code></th> <td> <p>Performs <a href="#parallelPrefix(T%5B%5D,java.util.function.BinaryOperator)"><code>parallelPrefix(Object[], BinaryOperator)</code></a> for the given subrange of the array.</p> </td> </tr> <tr id="i144"> <td><code>static &lt;T&gt; void</code></td> <th scope="row"><code><a href="#parallelPrefix(T%5B%5D,java.util.function.BinaryOperator)">parallelPrefix</a>​(T[] array,
              <a href="function/binaryoperator">BinaryOperator</a>&lt;T&gt; op)</code></th> <td> <p>Cumulates, in parallel, each element of the given array in place, using the supplied function.</p> </td> </tr> <tr id="i145"> <td><code>static void</code></td> <th scope="row"><code><a href="#parallelSetAll(double%5B%5D,java.util.function.IntToDoubleFunction)">parallelSetAll</a>​(double[] array,
              <a href="function/inttodoublefunction">IntToDoubleFunction</a> generator)</code></th> <td> <p>Set all elements of the specified array, in parallel, using the provided generator function to compute each element.</p> </td> </tr> <tr id="i146"> <td><code>static void</code></td> <th scope="row"><code><a href="#parallelSetAll(int%5B%5D,java.util.function.IntUnaryOperator)">parallelSetAll</a>​(int[] array,
              <a href="function/intunaryoperator">IntUnaryOperator</a> generator)</code></th> <td> <p>Set all elements of the specified array, in parallel, using the provided generator function to compute each element.</p> </td> </tr> <tr id="i147"> <td><code>static void</code></td> <th scope="row"><code><a href="#parallelSetAll(long%5B%5D,java.util.function.IntToLongFunction)">parallelSetAll</a>​(long[] array,
              <a href="function/inttolongfunction">IntToLongFunction</a> generator)</code></th> <td> <p>Set all elements of the specified array, in parallel, using the provided generator function to compute each element.</p> </td> </tr> <tr id="i148"> <td><code>static &lt;T&gt; void</code></td> <th scope="row"><code><a href="#parallelSetAll(T%5B%5D,java.util.function.IntFunction)">parallelSetAll</a>​(T[] array,
              <a href="function/intfunction">IntFunction</a>&lt;? extends T&gt; generator)</code></th> <td> <p>Set all elements of the specified array, in parallel, using the provided generator function to compute each element.</p> </td> </tr> <tr id="i149"> <td><code>static void</code></td> <th scope="row"><code><a href="#parallelSort(byte%5B%5D)">parallelSort</a>​(byte[] a)</code></th> <td> <p>Sorts the specified array into ascending numerical order.</p> </td> </tr> <tr id="i150"> <td><code>static void</code></td> <th scope="row"><code><a href="#parallelSort(byte%5B%5D,int,int)">parallelSort</a>​(byte[] a,
            int fromIndex,
            int toIndex)</code></th> <td> <p>Sorts the specified range of the array into ascending numerical order.</p> </td> </tr> <tr id="i151"> <td><code>static void</code></td> <th scope="row"><code><a href="#parallelSort(char%5B%5D)">parallelSort</a>​(char[] a)</code></th> <td> <p>Sorts the specified array into ascending numerical order.</p> </td> </tr> <tr id="i152"> <td><code>static void</code></td> <th scope="row"><code><a href="#parallelSort(char%5B%5D,int,int)">parallelSort</a>​(char[] a,
            int fromIndex,
            int toIndex)</code></th> <td> <p>Sorts the specified range of the array into ascending numerical order.</p> </td> </tr> <tr id="i153"> <td><code>static void</code></td> <th scope="row"><code><a href="#parallelSort(double%5B%5D)">parallelSort</a>​(double[] a)</code></th> <td> <p>Sorts the specified array into ascending numerical order.</p> </td> </tr> <tr id="i154"> <td><code>static void</code></td> <th scope="row"><code><a href="#parallelSort(double%5B%5D,int,int)">parallelSort</a>​(double[] a,
            int fromIndex,
            int toIndex)</code></th> <td> <p>Sorts the specified range of the array into ascending numerical order.</p> </td> </tr> <tr id="i155"> <td><code>static void</code></td> <th scope="row"><code><a href="#parallelSort(float%5B%5D)">parallelSort</a>​(float[] a)</code></th> <td> <p>Sorts the specified array into ascending numerical order.</p> </td> </tr> <tr id="i156"> <td><code>static void</code></td> <th scope="row"><code><a href="#parallelSort(float%5B%5D,int,int)">parallelSort</a>​(float[] a,
            int fromIndex,
            int toIndex)</code></th> <td> <p>Sorts the specified range of the array into ascending numerical order.</p> </td> </tr> <tr id="i157"> <td><code>static void</code></td> <th scope="row"><code><a href="#parallelSort(int%5B%5D)">parallelSort</a>​(int[] a)</code></th> <td> <p>Sorts the specified array into ascending numerical order.</p> </td> </tr> <tr id="i158"> <td><code>static void</code></td> <th scope="row"><code><a href="#parallelSort(int%5B%5D,int,int)">parallelSort</a>​(int[] a,
            int fromIndex,
            int toIndex)</code></th> <td> <p>Sorts the specified range of the array into ascending numerical order.</p> </td> </tr> <tr id="i159"> <td><code>static void</code></td> <th scope="row"><code><a href="#parallelSort(long%5B%5D)">parallelSort</a>​(long[] a)</code></th> <td> <p>Sorts the specified array into ascending numerical order.</p> </td> </tr> <tr id="i160"> <td><code>static void</code></td> <th scope="row"><code><a href="#parallelSort(long%5B%5D,int,int)">parallelSort</a>​(long[] a,
            int fromIndex,
            int toIndex)</code></th> <td> <p>Sorts the specified range of the array into ascending numerical order.</p> </td> </tr> <tr id="i161"> <td><code>static void</code></td> <th scope="row"><code><a href="#parallelSort(short%5B%5D)">parallelSort</a>​(short[] a)</code></th> <td> <p>Sorts the specified array into ascending numerical order.</p> </td> </tr> <tr id="i162"> <td><code>static void</code></td> <th scope="row"><code><a href="#parallelSort(short%5B%5D,int,int)">parallelSort</a>​(short[] a,
            int fromIndex,
            int toIndex)</code></th> <td> <p>Sorts the specified range of the array into ascending numerical order.</p> </td> </tr> <tr id="i163"> <td><code>static &lt;T extends <a href="../lang/comparable">Comparable</a>&lt;? super T&gt;&gt;<br>void</code></td> <th scope="row"><code><a href="#parallelSort(T%5B%5D)">parallelSort</a>​(T[] a)</code></th> <td> <p>Sorts the specified array of objects into ascending order, according to the <a href="../lang/comparable">natural ordering</a> of its elements.</p> </td> </tr> <tr id="i164"> <td><code>static &lt;T extends <a href="../lang/comparable">Comparable</a>&lt;? super T&gt;&gt;<br>void</code></td> <th scope="row"><code><a href="#parallelSort(T%5B%5D,int,int)">parallelSort</a>​(T[] a,
            int fromIndex,
            int toIndex)</code></th> <td> <p>Sorts the specified range of the specified array of objects into ascending order, according to the <a href="../lang/comparable">natural ordering</a> of its elements.</p> </td> </tr> <tr id="i165"> <td><code>static &lt;T&gt; void</code></td> <th scope="row"><code><a href="#parallelSort(T%5B%5D,int,int,java.util.Comparator)">parallelSort</a>​(T[] a,
            int fromIndex,
            int toIndex,
            <a href="comparator">Comparator</a>&lt;? super T&gt; cmp)</code></th> <td> <p>Sorts the specified range of the specified array of objects according to the order induced by the specified comparator.</p> </td> </tr> <tr id="i166"> <td><code>static &lt;T&gt; void</code></td> <th scope="row"><code><a href="#parallelSort(T%5B%5D,java.util.Comparator)">parallelSort</a>​(T[] a,
            <a href="comparator">Comparator</a>&lt;? super T&gt; cmp)</code></th> <td> <p>Sorts the specified array of objects according to the order induced by the specified comparator.</p> </td> </tr> <tr id="i167"> <td><code>static void</code></td> <th scope="row"><code><a href="#setAll(double%5B%5D,java.util.function.IntToDoubleFunction)">setAll</a>​(double[] array,
      <a href="function/inttodoublefunction">IntToDoubleFunction</a> generator)</code></th> <td> <p>Set all elements of the specified array, using the provided generator function to compute each element.</p> </td> </tr> <tr id="i168"> <td><code>static void</code></td> <th scope="row"><code><a href="#setAll(int%5B%5D,java.util.function.IntUnaryOperator)">setAll</a>​(int[] array,
      <a href="function/intunaryoperator">IntUnaryOperator</a> generator)</code></th> <td> <p>Set all elements of the specified array, using the provided generator function to compute each element.</p> </td> </tr> <tr id="i169"> <td><code>static void</code></td> <th scope="row"><code><a href="#setAll(long%5B%5D,java.util.function.IntToLongFunction)">setAll</a>​(long[] array,
      <a href="function/inttolongfunction">IntToLongFunction</a> generator)</code></th> <td> <p>Set all elements of the specified array, using the provided generator function to compute each element.</p> </td> </tr> <tr id="i170"> <td><code>static &lt;T&gt; void</code></td> <th scope="row"><code><a href="#setAll(T%5B%5D,java.util.function.IntFunction)">setAll</a>​(T[] array,
      <a href="function/intfunction">IntFunction</a>&lt;? extends T&gt; generator)</code></th> <td> <p>Set all elements of the specified array, using the provided generator function to compute each element.</p> </td> </tr> <tr id="i171"> <td><code>static void</code></td> <th scope="row"><code><a href="#sort(byte%5B%5D)">sort</a>​(byte[] a)</code></th> <td> <p>Sorts the specified array into ascending numerical order.</p> </td> </tr> <tr id="i172"> <td><code>static void</code></td> <th scope="row"><code><a href="#sort(byte%5B%5D,int,int)">sort</a>​(byte[] a,
    int fromIndex,
    int toIndex)</code></th> <td> <p>Sorts the specified range of the array into ascending order.</p> </td> </tr> <tr id="i173"> <td><code>static void</code></td> <th scope="row"><code><a href="#sort(char%5B%5D)">sort</a>​(char[] a)</code></th> <td> <p>Sorts the specified array into ascending numerical order.</p> </td> </tr> <tr id="i174"> <td><code>static void</code></td> <th scope="row"><code><a href="#sort(char%5B%5D,int,int)">sort</a>​(char[] a,
    int fromIndex,
    int toIndex)</code></th> <td> <p>Sorts the specified range of the array into ascending order.</p> </td> </tr> <tr id="i175"> <td><code>static void</code></td> <th scope="row"><code><a href="#sort(double%5B%5D)">sort</a>​(double[] a)</code></th> <td> <p>Sorts the specified array into ascending numerical order.</p> </td> </tr> <tr id="i176"> <td><code>static void</code></td> <th scope="row"><code><a href="#sort(double%5B%5D,int,int)">sort</a>​(double[] a,
    int fromIndex,
    int toIndex)</code></th> <td> <p>Sorts the specified range of the array into ascending order.</p> </td> </tr> <tr id="i177"> <td><code>static void</code></td> <th scope="row"><code><a href="#sort(float%5B%5D)">sort</a>​(float[] a)</code></th> <td> <p>Sorts the specified array into ascending numerical order.</p> </td> </tr> <tr id="i178"> <td><code>static void</code></td> <th scope="row"><code><a href="#sort(float%5B%5D,int,int)">sort</a>​(float[] a,
    int fromIndex,
    int toIndex)</code></th> <td> <p>Sorts the specified range of the array into ascending order.</p> </td> </tr> <tr id="i179"> <td><code>static void</code></td> <th scope="row"><code><a href="#sort(int%5B%5D)">sort</a>​(int[] a)</code></th> <td> <p>Sorts the specified array into ascending numerical order.</p> </td> </tr> <tr id="i180"> <td><code>static void</code></td> <th scope="row"><code><a href="#sort(int%5B%5D,int,int)">sort</a>​(int[] a,
    int fromIndex,
    int toIndex)</code></th> <td> <p>Sorts the specified range of the array into ascending order.</p> </td> </tr> <tr id="i181"> <td><code>static void</code></td> <th scope="row"><code><a href="#sort(long%5B%5D)">sort</a>​(long[] a)</code></th> <td> <p>Sorts the specified array into ascending numerical order.</p> </td> </tr> <tr id="i182"> <td><code>static void</code></td> <th scope="row"><code><a href="#sort(long%5B%5D,int,int)">sort</a>​(long[] a,
    int fromIndex,
    int toIndex)</code></th> <td> <p>Sorts the specified range of the array into ascending order.</p> </td> </tr> <tr id="i183"> <td><code>static void</code></td> <th scope="row"><code><a href="#sort(short%5B%5D)">sort</a>​(short[] a)</code></th> <td> <p>Sorts the specified array into ascending numerical order.</p> </td> </tr> <tr id="i184"> <td><code>static void</code></td> <th scope="row"><code><a href="#sort(short%5B%5D,int,int)">sort</a>​(short[] a,
    int fromIndex,
    int toIndex)</code></th> <td> <p>Sorts the specified range of the array into ascending order.</p> </td> </tr> <tr id="i185"> <td><code>static void</code></td> <th scope="row"><code><a href="#sort(java.lang.Object%5B%5D)">sort</a>​(<a href="../lang/object">Object</a>[] a)</code></th> <td> <p>Sorts the specified array of objects into ascending order, according to the <a href="../lang/comparable">natural ordering</a> of its elements.</p> </td> </tr> <tr id="i186"> <td><code>static void</code></td> <th scope="row"><code><a href="#sort(java.lang.Object%5B%5D,int,int)">sort</a>​(<a href="../lang/object">Object</a>[] a,
    int fromIndex,
    int toIndex)</code></th> <td> <p>Sorts the specified range of the specified array of objects into ascending order, according to the <a href="../lang/comparable">natural ordering</a> of its elements.</p> </td> </tr> <tr id="i187"> <td><code>static &lt;T&gt; void</code></td> <th scope="row"><code><a href="#sort(T%5B%5D,int,int,java.util.Comparator)">sort</a>​(T[] a,
    int fromIndex,
    int toIndex,
    <a href="comparator">Comparator</a>&lt;? super T&gt; c)</code></th> <td> <p>Sorts the specified range of the specified array of objects according to the order induced by the specified comparator.</p> </td> </tr> <tr id="i188"> <td><code>static &lt;T&gt; void</code></td> <th scope="row"><code><a href="#sort(T%5B%5D,java.util.Comparator)">sort</a>​(T[] a,
    <a href="comparator">Comparator</a>&lt;? super T&gt; c)</code></th> <td> <p>Sorts the specified array of objects according to the order induced by the specified comparator.</p> </td> </tr> <tr id="i189"> <td><code>static <a href="spliterator.ofdouble">Spliterator.OfDouble</a></code></td> <th scope="row"><code><a href="#spliterator(double%5B%5D)">spliterator</a>​(double[] array)</code></th> <td> <p>Returns a <a href="spliterator.ofdouble"><code>Spliterator.OfDouble</code></a> covering all of the specified array.</p> </td> </tr> <tr id="i190"> <td><code>static <a href="spliterator.ofdouble">Spliterator.OfDouble</a></code></td> <th scope="row"><code><a href="#spliterator(double%5B%5D,int,int)">spliterator</a>​(double[] array,
           int startInclusive,
           int endExclusive)</code></th> <td> <p>Returns a <a href="spliterator.ofdouble"><code>Spliterator.OfDouble</code></a> covering the specified range of the specified array.</p> </td> </tr> <tr id="i191"> <td><code>static <a href="spliterator.ofint">Spliterator.OfInt</a></code></td> <th scope="row"><code><a href="#spliterator(int%5B%5D)">spliterator</a>​(int[] array)</code></th> <td> <p>Returns a <a href="spliterator.ofint"><code>Spliterator.OfInt</code></a> covering all of the specified array.</p> </td> </tr> <tr id="i192"> <td><code>static <a href="spliterator.ofint">Spliterator.OfInt</a></code></td> <th scope="row"><code><a href="#spliterator(int%5B%5D,int,int)">spliterator</a>​(int[] array,
           int startInclusive,
           int endExclusive)</code></th> <td> <p>Returns a <a href="spliterator.ofint"><code>Spliterator.OfInt</code></a> covering the specified range of the specified array.</p> </td> </tr> <tr id="i193"> <td><code>static <a href="spliterator.oflong">Spliterator.OfLong</a></code></td> <th scope="row"><code><a href="#spliterator(long%5B%5D)">spliterator</a>​(long[] array)</code></th> <td> <p>Returns a <a href="spliterator.oflong"><code>Spliterator.OfLong</code></a> covering all of the specified array.</p> </td> </tr> <tr id="i194"> <td><code>static <a href="spliterator.oflong">Spliterator.OfLong</a></code></td> <th scope="row"><code><a href="#spliterator(long%5B%5D,int,int)">spliterator</a>​(long[] array,
           int startInclusive,
           int endExclusive)</code></th> <td> <p>Returns a <a href="spliterator.oflong"><code>Spliterator.OfLong</code></a> covering the specified range of the specified array.</p> </td> </tr> <tr id="i195"> <td><code>static &lt;T&gt; <a href="spliterator">Spliterator</a>&lt;T&gt;</code></td> <th scope="row"><code><a href="#spliterator(T%5B%5D)">spliterator</a>​(T[] array)</code></th> <td> <p>Returns a <a href="spliterator"><code>Spliterator</code></a> covering all of the specified array.</p> </td> </tr> <tr id="i196"> <td><code>static &lt;T&gt; <a href="spliterator">Spliterator</a>&lt;T&gt;</code></td> <th scope="row"><code><a href="#spliterator(T%5B%5D,int,int)">spliterator</a>​(T[] array,
           int startInclusive,
           int endExclusive)</code></th> <td> <p>Returns a <a href="spliterator"><code>Spliterator</code></a> covering the specified range of the specified array.</p> </td> </tr> <tr id="i197"> <td><code>static <a href="stream/doublestream">DoubleStream</a></code></td> <th scope="row"><code><a href="#stream(double%5B%5D)">stream</a>​(double[] array)</code></th> <td> <p>Returns a sequential <a href="stream/doublestream"><code>DoubleStream</code></a> with the specified array as its source.</p> </td> </tr> <tr id="i198"> <td><code>static <a href="stream/doublestream">DoubleStream</a></code></td> <th scope="row"><code><a href="#stream(double%5B%5D,int,int)">stream</a>​(double[] array,
      int startInclusive,
      int endExclusive)</code></th> <td> <p>Returns a sequential <a href="stream/doublestream"><code>DoubleStream</code></a> with the specified range of the specified array as its source.</p> </td> </tr> <tr id="i199"> <td><code>static <a href="stream/intstream">IntStream</a></code></td> <th scope="row"><code><a href="#stream(int%5B%5D)">stream</a>​(int[] array)</code></th> <td> <p>Returns a sequential <a href="stream/intstream"><code>IntStream</code></a> with the specified array as its source.</p> </td> </tr> <tr id="i200"> <td><code>static <a href="stream/intstream">IntStream</a></code></td> <th scope="row"><code><a href="#stream(int%5B%5D,int,int)">stream</a>​(int[] array,
      int startInclusive,
      int endExclusive)</code></th> <td> <p>Returns a sequential <a href="stream/intstream"><code>IntStream</code></a> with the specified range of the specified array as its source.</p> </td> </tr> <tr id="i201"> <td><code>static <a href="stream/longstream">LongStream</a></code></td> <th scope="row"><code><a href="#stream(long%5B%5D)">stream</a>​(long[] array)</code></th> <td> <p>Returns a sequential <a href="stream/longstream"><code>LongStream</code></a> with the specified array as its source.</p> </td> </tr> <tr id="i202"> <td><code>static <a href="stream/longstream">LongStream</a></code></td> <th scope="row"><code><a href="#stream(long%5B%5D,int,int)">stream</a>​(long[] array,
      int startInclusive,
      int endExclusive)</code></th> <td> <p>Returns a sequential <a href="stream/longstream"><code>LongStream</code></a> with the specified range of the specified array as its source.</p> </td> </tr> <tr id="i203"> <td><code>static &lt;T&gt; <a href="stream/stream">Stream</a>&lt;T&gt;</code></td> <th scope="row"><code><a href="#stream(T%5B%5D)">stream</a>​(T[] array)</code></th> <td> <p>Returns a sequential <a href="stream/stream"><code>Stream</code></a> with the specified array as its source.</p> </td> </tr> <tr id="i204"> <td><code>static &lt;T&gt; <a href="stream/stream">Stream</a>&lt;T&gt;</code></td> <th scope="row"><code><a href="#stream(T%5B%5D,int,int)">stream</a>​(T[] array,
      int startInclusive,
      int endExclusive)</code></th> <td> <p>Returns a sequential <a href="stream/stream"><code>Stream</code></a> with the specified range of the specified array as its source.</p> </td> </tr> <tr id="i205"> <td><code>static <a href="../lang/string">String</a></code></td> <th scope="row"><code><a href="#toString(boolean%5B%5D)">toString</a>​(boolean[] a)</code></th> <td> <p>Returns a string representation of the contents of the specified array.</p> </td> </tr> <tr id="i206"> <td><code>static <a href="../lang/string">String</a></code></td> <th scope="row"><code><a href="#toString(byte%5B%5D)">toString</a>​(byte[] a)</code></th> <td> <p>Returns a string representation of the contents of the specified array.</p> </td> </tr> <tr id="i207"> <td><code>static <a href="../lang/string">String</a></code></td> <th scope="row"><code><a href="#toString(char%5B%5D)">toString</a>​(char[] a)</code></th> <td> <p>Returns a string representation of the contents of the specified array.</p> </td> </tr> <tr id="i208"> <td><code>static <a href="../lang/string">String</a></code></td> <th scope="row"><code><a href="#toString(double%5B%5D)">toString</a>​(double[] a)</code></th> <td> <p>Returns a string representation of the contents of the specified array.</p> </td> </tr> <tr id="i209"> <td><code>static <a href="../lang/string">String</a></code></td> <th scope="row"><code><a href="#toString(float%5B%5D)">toString</a>​(float[] a)</code></th> <td> <p>Returns a string representation of the contents of the specified array.</p> </td> </tr> <tr id="i210"> <td><code>static <a href="../lang/string">String</a></code></td> <th scope="row"><code><a href="#toString(int%5B%5D)">toString</a>​(int[] a)</code></th> <td> <p>Returns a string representation of the contents of the specified array.</p> </td> </tr> <tr id="i211"> <td><code>static <a href="../lang/string">String</a></code></td> <th scope="row"><code><a href="#toString(long%5B%5D)">toString</a>​(long[] a)</code></th> <td> <p>Returns a string representation of the contents of the specified array.</p> </td> </tr> <tr id="i212"> <td><code>static <a href="../lang/string">String</a></code></td> <th scope="row"><code><a href="#toString(short%5B%5D)">toString</a>​(short[] a)</code></th> <td> <p>Returns a string representation of the contents of the specified array.</p> </td> </tr> <tr id="i213"> <td><code>static <a href="../lang/string">String</a></code></td> <th scope="row"><code><a href="#toString(java.lang.Object%5B%5D)">toString</a>​(<a href="../lang/object">Object</a>[] a)</code></th> <td> <p>Returns a string representation of the contents of the specified array.</p> </td> </tr> </table>  <h2 id="methods.inherited.from.class.java.lang.Object">Methods declared in class java.lang.<a href="../lang/object">Object</a>
</h2> <code><a href="../lang/object#clone()">clone</a>, <a href="../lang/object#equals(java.lang.Object)">equals</a>, <a href="../lang/object#finalize()">finalize</a>, <a href="../lang/object#getClass()">getClass</a>, <a href="../lang/object#hashCode()">hashCode</a>, <a href="../lang/object#notify()">notify</a>, <a href="../lang/object#notifyAll()">notifyAll</a>, <a href="../lang/object#toString()">toString</a>, <a href="../lang/object#wait()">wait</a>, <a href="../lang/object#wait(long)">wait</a>, <a href="../lang/object#wait(long,int)">wait</a></code>  </section>   <div>   <section role="region">  <h2 id="method.detail">Methods</h2>   <h3 id="sort(int[])">sort</h3> <pre data-language="java">public static void sort(int[] a)</pre> <div>
<p>Sorts the specified array into ascending numerical order. </p>
<p>Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the array to be sorted</dd> </dl>    <h3 id="sort(int[],int,int)">sort</h3> <pre data-language="java">public static void sort(int[] a,
                        int fromIndex,
                        int toIndex)</pre> <div>
<p>Sorts the specified range of the array into ascending order. The range to be sorted extends from the index <code>fromIndex</code>, inclusive, to the index <code>toIndex</code>, exclusive. If <code>fromIndex == toIndex</code>, the range to be sorted is empty. </p>
<p>Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the array to be sorted</dd> <dd>
<code>fromIndex</code> - the index of the first element, inclusive, to be sorted</dd> <dd>
<code>toIndex</code> - the index of the last element, exclusive, to be sorted</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - if <code>fromIndex &gt; toIndex</code>
</dd> <dd>
<code><a href="../lang/arrayindexoutofboundsexception">ArrayIndexOutOfBoundsException</a></code> - if <code>fromIndex &lt; 0</code> or <code>toIndex &gt; a.length</code>
</dd> </dl>    <h3 id="sort(long[])">sort</h3> <pre data-language="java">public static void sort(long[] a)</pre> <div>
<p>Sorts the specified array into ascending numerical order. </p>
<p>Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the array to be sorted</dd> </dl>    <h3 id="sort(long[],int,int)">sort</h3> <pre data-language="java">public static void sort(long[] a,
                        int fromIndex,
                        int toIndex)</pre> <div>
<p>Sorts the specified range of the array into ascending order. The range to be sorted extends from the index <code>fromIndex</code>, inclusive, to the index <code>toIndex</code>, exclusive. If <code>fromIndex == toIndex</code>, the range to be sorted is empty. </p>
<p>Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the array to be sorted</dd> <dd>
<code>fromIndex</code> - the index of the first element, inclusive, to be sorted</dd> <dd>
<code>toIndex</code> - the index of the last element, exclusive, to be sorted</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - if <code>fromIndex &gt; toIndex</code>
</dd> <dd>
<code><a href="../lang/arrayindexoutofboundsexception">ArrayIndexOutOfBoundsException</a></code> - if <code>fromIndex &lt; 0</code> or <code>toIndex &gt; a.length</code>
</dd> </dl>    <h3 id="sort(short[])">sort</h3> <pre data-language="java">public static void sort(short[] a)</pre> <div>
<p>Sorts the specified array into ascending numerical order. </p>
<p>Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the array to be sorted</dd> </dl>    <h3 id="sort(short[],int,int)">sort</h3> <pre data-language="java">public static void sort(short[] a,
                        int fromIndex,
                        int toIndex)</pre> <div>
<p>Sorts the specified range of the array into ascending order. The range to be sorted extends from the index <code>fromIndex</code>, inclusive, to the index <code>toIndex</code>, exclusive. If <code>fromIndex == toIndex</code>, the range to be sorted is empty. </p>
<p>Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the array to be sorted</dd> <dd>
<code>fromIndex</code> - the index of the first element, inclusive, to be sorted</dd> <dd>
<code>toIndex</code> - the index of the last element, exclusive, to be sorted</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - if <code>fromIndex &gt; toIndex</code>
</dd> <dd>
<code><a href="../lang/arrayindexoutofboundsexception">ArrayIndexOutOfBoundsException</a></code> - if <code>fromIndex &lt; 0</code> or <code>toIndex &gt; a.length</code>
</dd> </dl>    <h3 id="sort(char[])">sort</h3> <pre data-language="java">public static void sort(char[] a)</pre> <div>
<p>Sorts the specified array into ascending numerical order. </p>
<p>Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the array to be sorted</dd> </dl>    <h3 id="sort(char[],int,int)">sort</h3> <pre data-language="java">public static void sort(char[] a,
                        int fromIndex,
                        int toIndex)</pre> <div>
<p>Sorts the specified range of the array into ascending order. The range to be sorted extends from the index <code>fromIndex</code>, inclusive, to the index <code>toIndex</code>, exclusive. If <code>fromIndex == toIndex</code>, the range to be sorted is empty. </p>
<p>Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the array to be sorted</dd> <dd>
<code>fromIndex</code> - the index of the first element, inclusive, to be sorted</dd> <dd>
<code>toIndex</code> - the index of the last element, exclusive, to be sorted</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - if <code>fromIndex &gt; toIndex</code>
</dd> <dd>
<code><a href="../lang/arrayindexoutofboundsexception">ArrayIndexOutOfBoundsException</a></code> - if <code>fromIndex &lt; 0</code> or <code>toIndex &gt; a.length</code>
</dd> </dl>    <h3 id="sort(byte[])">sort</h3> <pre data-language="java">public static void sort(byte[] a)</pre> <div>
<p>Sorts the specified array into ascending numerical order. </p>
<p>Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the array to be sorted</dd> </dl>    <h3 id="sort(byte[],int,int)">sort</h3> <pre data-language="java">public static void sort(byte[] a,
                        int fromIndex,
                        int toIndex)</pre> <div>
<p>Sorts the specified range of the array into ascending order. The range to be sorted extends from the index <code>fromIndex</code>, inclusive, to the index <code>toIndex</code>, exclusive. If <code>fromIndex == toIndex</code>, the range to be sorted is empty. </p>
<p>Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the array to be sorted</dd> <dd>
<code>fromIndex</code> - the index of the first element, inclusive, to be sorted</dd> <dd>
<code>toIndex</code> - the index of the last element, exclusive, to be sorted</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - if <code>fromIndex &gt; toIndex</code>
</dd> <dd>
<code><a href="../lang/arrayindexoutofboundsexception">ArrayIndexOutOfBoundsException</a></code> - if <code>fromIndex &lt; 0</code> or <code>toIndex &gt; a.length</code>
</dd> </dl>    <h3 id="sort(float[])">sort</h3> <pre data-language="java">public static void sort(float[] a)</pre> <div>
<p>Sorts the specified array into ascending numerical order. </p>
<p>The <code>&lt;</code> relation does not provide a total order on all float values: <code>-0.0f == 0.0f</code> is <code>true</code> and a <code>Float.NaN</code> value compares neither less than, greater than, nor equal to any value, even itself. This method uses the total order imposed by the method <a href="../lang/float#compareTo(java.lang.Float)"><code>Float.compareTo(java.lang.Float)</code></a>: <code>-0.0f</code> is treated as less than value <code>0.0f</code> and <code>Float.NaN</code> is considered greater than any other value and all <code>Float.NaN</code> values are considered equal. </p>
<p>Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the array to be sorted</dd> </dl>    <h3 id="sort(float[],int,int)">sort</h3> <pre data-language="java">public static void sort(float[] a,
                        int fromIndex,
                        int toIndex)</pre> <div>
<p>Sorts the specified range of the array into ascending order. The range to be sorted extends from the index <code>fromIndex</code>, inclusive, to the index <code>toIndex</code>, exclusive. If <code>fromIndex == toIndex</code>, the range to be sorted is empty. </p>
<p>The <code>&lt;</code> relation does not provide a total order on all float values: <code>-0.0f == 0.0f</code> is <code>true</code> and a <code>Float.NaN</code> value compares neither less than, greater than, nor equal to any value, even itself. This method uses the total order imposed by the method <a href="../lang/float#compareTo(java.lang.Float)"><code>Float.compareTo(java.lang.Float)</code></a>: <code>-0.0f</code> is treated as less than value <code>0.0f</code> and <code>Float.NaN</code> is considered greater than any other value and all <code>Float.NaN</code> values are considered equal. </p>
<p>Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the array to be sorted</dd> <dd>
<code>fromIndex</code> - the index of the first element, inclusive, to be sorted</dd> <dd>
<code>toIndex</code> - the index of the last element, exclusive, to be sorted</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - if <code>fromIndex &gt; toIndex</code>
</dd> <dd>
<code><a href="../lang/arrayindexoutofboundsexception">ArrayIndexOutOfBoundsException</a></code> - if <code>fromIndex &lt; 0</code> or <code>toIndex &gt; a.length</code>
</dd> </dl>    <h3 id="sort(double[])">sort</h3> <pre data-language="java">public static void sort(double[] a)</pre> <div>
<p>Sorts the specified array into ascending numerical order. </p>
<p>The <code>&lt;</code> relation does not provide a total order on all double values: <code>-0.0d == 0.0d</code> is <code>true</code> and a <code>Double.NaN</code> value compares neither less than, greater than, nor equal to any value, even itself. This method uses the total order imposed by the method <a href="../lang/double#compareTo(java.lang.Double)"><code>Double.compareTo(java.lang.Double)</code></a>: <code>-0.0d</code> is treated as less than value <code>0.0d</code> and <code>Double.NaN</code> is considered greater than any other value and all <code>Double.NaN</code> values are considered equal. </p>
<p>Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the array to be sorted</dd> </dl>    <h3 id="sort(double[],int,int)">sort</h3> <pre data-language="java">public static void sort(double[] a,
                        int fromIndex,
                        int toIndex)</pre> <div>
<p>Sorts the specified range of the array into ascending order. The range to be sorted extends from the index <code>fromIndex</code>, inclusive, to the index <code>toIndex</code>, exclusive. If <code>fromIndex == toIndex</code>, the range to be sorted is empty. </p>
<p>The <code>&lt;</code> relation does not provide a total order on all double values: <code>-0.0d == 0.0d</code> is <code>true</code> and a <code>Double.NaN</code> value compares neither less than, greater than, nor equal to any value, even itself. This method uses the total order imposed by the method <a href="../lang/double#compareTo(java.lang.Double)"><code>Double.compareTo(java.lang.Double)</code></a>: <code>-0.0d</code> is treated as less than value <code>0.0d</code> and <code>Double.NaN</code> is considered greater than any other value and all <code>Double.NaN</code> values are considered equal. </p>
<p>Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the array to be sorted</dd> <dd>
<code>fromIndex</code> - the index of the first element, inclusive, to be sorted</dd> <dd>
<code>toIndex</code> - the index of the last element, exclusive, to be sorted</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - if <code>fromIndex &gt; toIndex</code>
</dd> <dd>
<code><a href="../lang/arrayindexoutofboundsexception">ArrayIndexOutOfBoundsException</a></code> - if <code>fromIndex &lt; 0</code> or <code>toIndex &gt; a.length</code>
</dd> </dl>    <h3 id="parallelSort(byte[])">parallelSort</h3> <pre data-language="java">public static void parallelSort(byte[] a)</pre> <p>Sorts the specified array into ascending numerical order.</p> <dl> <dt>Implementation Note:</dt> <dd>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate <a href="#sort(byte%5B%5D)"><code>Arrays.sort</code></a> method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate <a href="#sort(byte%5B%5D)"><code>Arrays.sort</code></a> method. The algorithm requires a working space no greater than the size of the original array. The <a href="concurrent/forkjoinpool#commonPool()"><code>ForkJoin common pool</code></a> is used to execute any parallel tasks.</dd> <dt>Parameters:</dt> <dd>
<code>a</code> - the array to be sorted</dd> <dt>Since:</dt> <dd>1.8</dd> </dl>    <h3 id="parallelSort(byte[],int,int)">parallelSort</h3> <pre data-language="java">public static void parallelSort(byte[] a,
                                int fromIndex,
                                int toIndex)</pre> <p>Sorts the specified range of the array into ascending numerical order. The range to be sorted extends from the index <code>fromIndex</code>, inclusive, to the index <code>toIndex</code>, exclusive. If <code>fromIndex == toIndex</code>, the range to be sorted is empty.</p> <dl> <dt>Implementation Note:</dt> <dd>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate <a href="#sort(byte%5B%5D)"><code>Arrays.sort</code></a> method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate <a href="#sort(byte%5B%5D)"><code>Arrays.sort</code></a> method. The algorithm requires a working space no greater than the size of the specified range of the original array. The <a href="concurrent/forkjoinpool#commonPool()"><code>ForkJoin common pool</code></a> is used to execute any parallel tasks.</dd> <dt>Parameters:</dt> <dd>
<code>a</code> - the array to be sorted</dd> <dd>
<code>fromIndex</code> - the index of the first element, inclusive, to be sorted</dd> <dd>
<code>toIndex</code> - the index of the last element, exclusive, to be sorted</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - if <code>fromIndex &gt; toIndex</code>
</dd> <dd>
<code><a href="../lang/arrayindexoutofboundsexception">ArrayIndexOutOfBoundsException</a></code> - if <code>fromIndex &lt; 0</code> or <code>toIndex &gt; a.length</code>
</dd> <dt>Since:</dt> <dd>1.8</dd> </dl>    <h3 id="parallelSort(char[])">parallelSort</h3> <pre data-language="java">public static void parallelSort(char[] a)</pre> <p>Sorts the specified array into ascending numerical order.</p> <dl> <dt>Implementation Note:</dt> <dd>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate <a href="#sort(char%5B%5D)"><code>Arrays.sort</code></a> method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate <a href="#sort(char%5B%5D)"><code>Arrays.sort</code></a> method. The algorithm requires a working space no greater than the size of the original array. The <a href="concurrent/forkjoinpool#commonPool()"><code>ForkJoin common pool</code></a> is used to execute any parallel tasks.</dd> <dt>Parameters:</dt> <dd>
<code>a</code> - the array to be sorted</dd> <dt>Since:</dt> <dd>1.8</dd> </dl>    <h3 id="parallelSort(char[],int,int)">parallelSort</h3> <pre data-language="java">public static void parallelSort(char[] a,
                                int fromIndex,
                                int toIndex)</pre> <p>Sorts the specified range of the array into ascending numerical order. The range to be sorted extends from the index <code>fromIndex</code>, inclusive, to the index <code>toIndex</code>, exclusive. If <code>fromIndex == toIndex</code>, the range to be sorted is empty.</p> <dl> <dt>Implementation Note:</dt> <dd>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate <a href="#sort(char%5B%5D)"><code>Arrays.sort</code></a> method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate <a href="#sort(char%5B%5D)"><code>Arrays.sort</code></a> method. The algorithm requires a working space no greater than the size of the specified range of the original array. The <a href="concurrent/forkjoinpool#commonPool()"><code>ForkJoin common pool</code></a> is used to execute any parallel tasks.</dd> <dt>Parameters:</dt> <dd>
<code>a</code> - the array to be sorted</dd> <dd>
<code>fromIndex</code> - the index of the first element, inclusive, to be sorted</dd> <dd>
<code>toIndex</code> - the index of the last element, exclusive, to be sorted</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - if <code>fromIndex &gt; toIndex</code>
</dd> <dd>
<code><a href="../lang/arrayindexoutofboundsexception">ArrayIndexOutOfBoundsException</a></code> - if <code>fromIndex &lt; 0</code> or <code>toIndex &gt; a.length</code>
</dd> <dt>Since:</dt> <dd>1.8</dd> </dl>    <h3 id="parallelSort(short[])">parallelSort</h3> <pre data-language="java">public static void parallelSort(short[] a)</pre> <p>Sorts the specified array into ascending numerical order.</p> <dl> <dt>Implementation Note:</dt> <dd>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate <a href="#sort(short%5B%5D)"><code>Arrays.sort</code></a> method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate <a href="#sort(short%5B%5D)"><code>Arrays.sort</code></a> method. The algorithm requires a working space no greater than the size of the original array. The <a href="concurrent/forkjoinpool#commonPool()"><code>ForkJoin common pool</code></a> is used to execute any parallel tasks.</dd> <dt>Parameters:</dt> <dd>
<code>a</code> - the array to be sorted</dd> <dt>Since:</dt> <dd>1.8</dd> </dl>    <h3 id="parallelSort(short[],int,int)">parallelSort</h3> <pre data-language="java">public static void parallelSort(short[] a,
                                int fromIndex,
                                int toIndex)</pre> <p>Sorts the specified range of the array into ascending numerical order. The range to be sorted extends from the index <code>fromIndex</code>, inclusive, to the index <code>toIndex</code>, exclusive. If <code>fromIndex == toIndex</code>, the range to be sorted is empty.</p> <dl> <dt>Implementation Note:</dt> <dd>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate <a href="#sort(short%5B%5D)"><code>Arrays.sort</code></a> method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate <a href="#sort(short%5B%5D)"><code>Arrays.sort</code></a> method. The algorithm requires a working space no greater than the size of the specified range of the original array. The <a href="concurrent/forkjoinpool#commonPool()"><code>ForkJoin common pool</code></a> is used to execute any parallel tasks.</dd> <dt>Parameters:</dt> <dd>
<code>a</code> - the array to be sorted</dd> <dd>
<code>fromIndex</code> - the index of the first element, inclusive, to be sorted</dd> <dd>
<code>toIndex</code> - the index of the last element, exclusive, to be sorted</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - if <code>fromIndex &gt; toIndex</code>
</dd> <dd>
<code><a href="../lang/arrayindexoutofboundsexception">ArrayIndexOutOfBoundsException</a></code> - if <code>fromIndex &lt; 0</code> or <code>toIndex &gt; a.length</code>
</dd> <dt>Since:</dt> <dd>1.8</dd> </dl>    <h3 id="parallelSort(int[])">parallelSort</h3> <pre data-language="java">public static void parallelSort(int[] a)</pre> <p>Sorts the specified array into ascending numerical order.</p> <dl> <dt>Implementation Note:</dt> <dd>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate <a href="#sort(int%5B%5D)"><code>Arrays.sort</code></a> method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate <a href="#sort(int%5B%5D)"><code>Arrays.sort</code></a> method. The algorithm requires a working space no greater than the size of the original array. The <a href="concurrent/forkjoinpool#commonPool()"><code>ForkJoin common pool</code></a> is used to execute any parallel tasks.</dd> <dt>Parameters:</dt> <dd>
<code>a</code> - the array to be sorted</dd> <dt>Since:</dt> <dd>1.8</dd> </dl>    <h3 id="parallelSort(int[],int,int)">parallelSort</h3> <pre data-language="java">public static void parallelSort(int[] a,
                                int fromIndex,
                                int toIndex)</pre> <p>Sorts the specified range of the array into ascending numerical order. The range to be sorted extends from the index <code>fromIndex</code>, inclusive, to the index <code>toIndex</code>, exclusive. If <code>fromIndex == toIndex</code>, the range to be sorted is empty.</p> <dl> <dt>Implementation Note:</dt> <dd>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate <a href="#sort(int%5B%5D)"><code>Arrays.sort</code></a> method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate <a href="#sort(int%5B%5D)"><code>Arrays.sort</code></a> method. The algorithm requires a working space no greater than the size of the specified range of the original array. The <a href="concurrent/forkjoinpool#commonPool()"><code>ForkJoin common pool</code></a> is used to execute any parallel tasks.</dd> <dt>Parameters:</dt> <dd>
<code>a</code> - the array to be sorted</dd> <dd>
<code>fromIndex</code> - the index of the first element, inclusive, to be sorted</dd> <dd>
<code>toIndex</code> - the index of the last element, exclusive, to be sorted</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - if <code>fromIndex &gt; toIndex</code>
</dd> <dd>
<code><a href="../lang/arrayindexoutofboundsexception">ArrayIndexOutOfBoundsException</a></code> - if <code>fromIndex &lt; 0</code> or <code>toIndex &gt; a.length</code>
</dd> <dt>Since:</dt> <dd>1.8</dd> </dl>    <h3 id="parallelSort(long[])">parallelSort</h3> <pre data-language="java">public static void parallelSort(long[] a)</pre> <p>Sorts the specified array into ascending numerical order.</p> <dl> <dt>Implementation Note:</dt> <dd>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate <a href="#sort(long%5B%5D)"><code>Arrays.sort</code></a> method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate <a href="#sort(long%5B%5D)"><code>Arrays.sort</code></a> method. The algorithm requires a working space no greater than the size of the original array. The <a href="concurrent/forkjoinpool#commonPool()"><code>ForkJoin common pool</code></a> is used to execute any parallel tasks.</dd> <dt>Parameters:</dt> <dd>
<code>a</code> - the array to be sorted</dd> <dt>Since:</dt> <dd>1.8</dd> </dl>    <h3 id="parallelSort(long[],int,int)">parallelSort</h3> <pre data-language="java">public static void parallelSort(long[] a,
                                int fromIndex,
                                int toIndex)</pre> <p>Sorts the specified range of the array into ascending numerical order. The range to be sorted extends from the index <code>fromIndex</code>, inclusive, to the index <code>toIndex</code>, exclusive. If <code>fromIndex == toIndex</code>, the range to be sorted is empty.</p> <dl> <dt>Implementation Note:</dt> <dd>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate <a href="#sort(long%5B%5D)"><code>Arrays.sort</code></a> method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate <a href="#sort(long%5B%5D)"><code>Arrays.sort</code></a> method. The algorithm requires a working space no greater than the size of the specified range of the original array. The <a href="concurrent/forkjoinpool#commonPool()"><code>ForkJoin common pool</code></a> is used to execute any parallel tasks.</dd> <dt>Parameters:</dt> <dd>
<code>a</code> - the array to be sorted</dd> <dd>
<code>fromIndex</code> - the index of the first element, inclusive, to be sorted</dd> <dd>
<code>toIndex</code> - the index of the last element, exclusive, to be sorted</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - if <code>fromIndex &gt; toIndex</code>
</dd> <dd>
<code><a href="../lang/arrayindexoutofboundsexception">ArrayIndexOutOfBoundsException</a></code> - if <code>fromIndex &lt; 0</code> or <code>toIndex &gt; a.length</code>
</dd> <dt>Since:</dt> <dd>1.8</dd> </dl>    <h3 id="parallelSort(float[])">parallelSort</h3> <pre data-language="java">public static void parallelSort(float[] a)</pre> <div>
<p>Sorts the specified array into ascending numerical order. </p>
<p>The <code>&lt;</code> relation does not provide a total order on all float values: <code>-0.0f == 0.0f</code> is <code>true</code> and a <code>Float.NaN</code> value compares neither less than, greater than, nor equal to any value, even itself. This method uses the total order imposed by the method <a href="../lang/float#compareTo(java.lang.Float)"><code>Float.compareTo(java.lang.Float)</code></a>: <code>-0.0f</code> is treated as less than value <code>0.0f</code> and <code>Float.NaN</code> is considered greater than any other value and all <code>Float.NaN</code> values are considered equal.</p>
</div> <dl> <dt>Implementation Note:</dt> <dd>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate <a href="#sort(float%5B%5D)"><code>Arrays.sort</code></a> method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate <a href="#sort(float%5B%5D)"><code>Arrays.sort</code></a> method. The algorithm requires a working space no greater than the size of the original array. The <a href="concurrent/forkjoinpool#commonPool()"><code>ForkJoin common pool</code></a> is used to execute any parallel tasks.</dd> <dt>Parameters:</dt> <dd>
<code>a</code> - the array to be sorted</dd> <dt>Since:</dt> <dd>1.8</dd> </dl>    <h3 id="parallelSort(float[],int,int)">parallelSort</h3> <pre data-language="java">public static void parallelSort(float[] a,
                                int fromIndex,
                                int toIndex)</pre> <div>
<p>Sorts the specified range of the array into ascending numerical order. The range to be sorted extends from the index <code>fromIndex</code>, inclusive, to the index <code>toIndex</code>, exclusive. If <code>fromIndex == toIndex</code>, the range to be sorted is empty. </p>
<p>The <code>&lt;</code> relation does not provide a total order on all float values: <code>-0.0f == 0.0f</code> is <code>true</code> and a <code>Float.NaN</code> value compares neither less than, greater than, nor equal to any value, even itself. This method uses the total order imposed by the method <a href="../lang/float#compareTo(java.lang.Float)"><code>Float.compareTo(java.lang.Float)</code></a>: <code>-0.0f</code> is treated as less than value <code>0.0f</code> and <code>Float.NaN</code> is considered greater than any other value and all <code>Float.NaN</code> values are considered equal.</p>
</div> <dl> <dt>Implementation Note:</dt> <dd>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate <a href="#sort(float%5B%5D)"><code>Arrays.sort</code></a> method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate <a href="#sort(float%5B%5D)"><code>Arrays.sort</code></a> method. The algorithm requires a working space no greater than the size of the specified range of the original array. The <a href="concurrent/forkjoinpool#commonPool()"><code>ForkJoin common pool</code></a> is used to execute any parallel tasks.</dd> <dt>Parameters:</dt> <dd>
<code>a</code> - the array to be sorted</dd> <dd>
<code>fromIndex</code> - the index of the first element, inclusive, to be sorted</dd> <dd>
<code>toIndex</code> - the index of the last element, exclusive, to be sorted</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - if <code>fromIndex &gt; toIndex</code>
</dd> <dd>
<code><a href="../lang/arrayindexoutofboundsexception">ArrayIndexOutOfBoundsException</a></code> - if <code>fromIndex &lt; 0</code> or <code>toIndex &gt; a.length</code>
</dd> <dt>Since:</dt> <dd>1.8</dd> </dl>    <h3 id="parallelSort(double[])">parallelSort</h3> <pre data-language="java">public static void parallelSort(double[] a)</pre> <div>
<p>Sorts the specified array into ascending numerical order. </p>
<p>The <code>&lt;</code> relation does not provide a total order on all double values: <code>-0.0d == 0.0d</code> is <code>true</code> and a <code>Double.NaN</code> value compares neither less than, greater than, nor equal to any value, even itself. This method uses the total order imposed by the method <a href="../lang/double#compareTo(java.lang.Double)"><code>Double.compareTo(java.lang.Double)</code></a>: <code>-0.0d</code> is treated as less than value <code>0.0d</code> and <code>Double.NaN</code> is considered greater than any other value and all <code>Double.NaN</code> values are considered equal.</p>
</div> <dl> <dt>Implementation Note:</dt> <dd>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate <a href="#sort(double%5B%5D)"><code>Arrays.sort</code></a> method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate <a href="#sort(double%5B%5D)"><code>Arrays.sort</code></a> method. The algorithm requires a working space no greater than the size of the original array. The <a href="concurrent/forkjoinpool#commonPool()"><code>ForkJoin common pool</code></a> is used to execute any parallel tasks.</dd> <dt>Parameters:</dt> <dd>
<code>a</code> - the array to be sorted</dd> <dt>Since:</dt> <dd>1.8</dd> </dl>    <h3 id="parallelSort(double[],int,int)">parallelSort</h3> <pre data-language="java">public static void parallelSort(double[] a,
                                int fromIndex,
                                int toIndex)</pre> <div>
<p>Sorts the specified range of the array into ascending numerical order. The range to be sorted extends from the index <code>fromIndex</code>, inclusive, to the index <code>toIndex</code>, exclusive. If <code>fromIndex == toIndex</code>, the range to be sorted is empty. </p>
<p>The <code>&lt;</code> relation does not provide a total order on all double values: <code>-0.0d == 0.0d</code> is <code>true</code> and a <code>Double.NaN</code> value compares neither less than, greater than, nor equal to any value, even itself. This method uses the total order imposed by the method <a href="../lang/double#compareTo(java.lang.Double)"><code>Double.compareTo(java.lang.Double)</code></a>: <code>-0.0d</code> is treated as less than value <code>0.0d</code> and <code>Double.NaN</code> is considered greater than any other value and all <code>Double.NaN</code> values are considered equal.</p>
</div> <dl> <dt>Implementation Note:</dt> <dd>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate <a href="#sort(double%5B%5D)"><code>Arrays.sort</code></a> method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate <a href="#sort(double%5B%5D)"><code>Arrays.sort</code></a> method. The algorithm requires a working space no greater than the size of the specified range of the original array. The <a href="concurrent/forkjoinpool#commonPool()"><code>ForkJoin common pool</code></a> is used to execute any parallel tasks.</dd> <dt>Parameters:</dt> <dd>
<code>a</code> - the array to be sorted</dd> <dd>
<code>fromIndex</code> - the index of the first element, inclusive, to be sorted</dd> <dd>
<code>toIndex</code> - the index of the last element, exclusive, to be sorted</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - if <code>fromIndex &gt; toIndex</code>
</dd> <dd>
<code><a href="../lang/arrayindexoutofboundsexception">ArrayIndexOutOfBoundsException</a></code> - if <code>fromIndex &lt; 0</code> or <code>toIndex &gt; a.length</code>
</dd> <dt>Since:</dt> <dd>1.8</dd> </dl>    <h3 id="parallelSort(java.lang.Comparable[])">parallelSort</h3> <pre data-language="java">public static &lt;T extends Comparable&lt;? super T&gt;&gt; void parallelSort(T[] a)</pre> <div>
<p>Sorts the specified array of objects into ascending order, according to the <a href="../lang/comparable">natural ordering</a> of its elements. All elements in the array must implement the <a href="../lang/comparable"><code>Comparable</code></a> interface. Furthermore, all elements in the array must be <i>mutually comparable</i> (that is, <code>e1.compareTo(e2)</code> must not throw a <code>ClassCastException</code> for any elements <code>e1</code> and <code>e2</code> in the array). </p>
<p>This sort is guaranteed to be <i>stable</i>: equal elements will not be reordered as a result of the sort.</p>
</div> <dl> <dt>Implementation Note:</dt> <dd>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate <a href="#sort(java.lang.Object%5B%5D)"><code>Arrays.sort</code></a> method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate <a href="#sort(java.lang.Object%5B%5D)"><code>Arrays.sort</code></a> method. The algorithm requires a working space no greater than the size of the original array. The <a href="concurrent/forkjoinpool#commonPool()"><code>ForkJoin common pool</code></a> is used to execute any parallel tasks.</dd> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the class of the objects to be sorted</dd> <dt>Parameters:</dt> <dd>
<code>a</code> - the array to be sorted</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/classcastexception">ClassCastException</a></code> - if the array contains elements that are not <i>mutually comparable</i> (for example, strings and integers)</dd> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - (optional) if the natural ordering of the array elements is found to violate the <a href="../lang/comparable"><code>Comparable</code></a> contract</dd> <dt>Since:</dt> <dd>1.8</dd> </dl>    <h3 id="parallelSort(java.lang.Comparable[],int,int)">parallelSort</h3> <pre data-language="java">public static &lt;T extends Comparable&lt;? super T&gt;&gt; void parallelSort(T[] a,
                                                                  int fromIndex,
                                                                  int toIndex)</pre> <div>
<p>Sorts the specified range of the specified array of objects into ascending order, according to the <a href="../lang/comparable">natural ordering</a> of its elements. The range to be sorted extends from index <code>fromIndex</code>, inclusive, to index <code>toIndex</code>, exclusive. (If <code>fromIndex==toIndex</code>, the range to be sorted is empty.) All elements in this range must implement the <a href="../lang/comparable"><code>Comparable</code></a> interface. Furthermore, all elements in this range must be <i>mutually comparable</i> (that is, <code>e1.compareTo(e2)</code> must not throw a <code>ClassCastException</code> for any elements <code>e1</code> and <code>e2</code> in the array). </p>
<p>This sort is guaranteed to be <i>stable</i>: equal elements will not be reordered as a result of the sort.</p>
</div> <dl> <dt>Implementation Note:</dt> <dd>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate <a href="#sort(java.lang.Object%5B%5D)"><code>Arrays.sort</code></a> method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate <a href="#sort(java.lang.Object%5B%5D)"><code>Arrays.sort</code></a> method. The algorithm requires a working space no greater than the size of the specified range of the original array. The <a href="concurrent/forkjoinpool#commonPool()"><code>ForkJoin common pool</code></a> is used to execute any parallel tasks.</dd> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the class of the objects to be sorted</dd> <dt>Parameters:</dt> <dd>
<code>a</code> - the array to be sorted</dd> <dd>
<code>fromIndex</code> - the index of the first element (inclusive) to be sorted</dd> <dd>
<code>toIndex</code> - the index of the last element (exclusive) to be sorted</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - if <code>fromIndex &gt; toIndex</code> or (optional) if the natural ordering of the array elements is found to violate the <a href="../lang/comparable"><code>Comparable</code></a> contract</dd> <dd>
<code><a href="../lang/arrayindexoutofboundsexception">ArrayIndexOutOfBoundsException</a></code> - if <code>fromIndex &lt; 0</code> or <code>toIndex &gt; a.length</code>
</dd> <dd>
<code><a href="../lang/classcastexception">ClassCastException</a></code> - if the array contains elements that are not <i>mutually comparable</i> (for example, strings and integers).</dd> <dt>Since:</dt> <dd>1.8</dd> </dl>    <h3 id="parallelSort(java.lang.Object[],java.util.Comparator)">parallelSort</h3> <pre data-language="java">public static &lt;T&gt; void parallelSort(T[] a,
                                    Comparator&lt;? super T&gt; cmp)</pre> <div>
<p>Sorts the specified array of objects according to the order induced by the specified comparator. All elements in the array must be <i>mutually comparable</i> by the specified comparator (that is, <code>c.compare(e1, e2)</code> must not throw a <code>ClassCastException</code> for any elements <code>e1</code> and <code>e2</code> in the array). </p>
<p>This sort is guaranteed to be <i>stable</i>: equal elements will not be reordered as a result of the sort.</p>
</div> <dl> <dt>Implementation Note:</dt> <dd>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate <a href="#sort(java.lang.Object%5B%5D)"><code>Arrays.sort</code></a> method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate <a href="#sort(java.lang.Object%5B%5D)"><code>Arrays.sort</code></a> method. The algorithm requires a working space no greater than the size of the original array. The <a href="concurrent/forkjoinpool#commonPool()"><code>ForkJoin common pool</code></a> is used to execute any parallel tasks.</dd> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the class of the objects to be sorted</dd> <dt>Parameters:</dt> <dd>
<code>a</code> - the array to be sorted</dd> <dd>
<code>cmp</code> - the comparator to determine the order of the array. A <code>null</code> value indicates that the elements' <a href="../lang/comparable">natural ordering</a> should be used.</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/classcastexception">ClassCastException</a></code> - if the array contains elements that are not <i>mutually comparable</i> using the specified comparator</dd> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - (optional) if the comparator is found to violate the <a href="comparator"><code>Comparator</code></a> contract</dd> <dt>Since:</dt> <dd>1.8</dd> </dl>    <h3 id="parallelSort(java.lang.Object[],int,int,java.util.Comparator)">parallelSort</h3> <pre data-language="java">public static &lt;T&gt; void parallelSort(T[] a,
                                    int fromIndex,
                                    int toIndex,
                                    Comparator&lt;? super T&gt; cmp)</pre> <div>
<p>Sorts the specified range of the specified array of objects according to the order induced by the specified comparator. The range to be sorted extends from index <code>fromIndex</code>, inclusive, to index <code>toIndex</code>, exclusive. (If <code>fromIndex==toIndex</code>, the range to be sorted is empty.) All elements in the range must be <i>mutually comparable</i> by the specified comparator (that is, <code>c.compare(e1, e2)</code> must not throw a <code>ClassCastException</code> for any elements <code>e1</code> and <code>e2</code> in the range). </p>
<p>This sort is guaranteed to be <i>stable</i>: equal elements will not be reordered as a result of the sort.</p>
</div> <dl> <dt>Implementation Note:</dt> <dd>The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate <a href="#sort(java.lang.Object%5B%5D)"><code>Arrays.sort</code></a> method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate <a href="#sort(java.lang.Object%5B%5D)"><code>Arrays.sort</code></a> method. The algorithm requires a working space no greater than the size of the specified range of the original array. The <a href="concurrent/forkjoinpool#commonPool()"><code>ForkJoin common pool</code></a> is used to execute any parallel tasks.</dd> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the class of the objects to be sorted</dd> <dt>Parameters:</dt> <dd>
<code>a</code> - the array to be sorted</dd> <dd>
<code>fromIndex</code> - the index of the first element (inclusive) to be sorted</dd> <dd>
<code>toIndex</code> - the index of the last element (exclusive) to be sorted</dd> <dd>
<code>cmp</code> - the comparator to determine the order of the array. A <code>null</code> value indicates that the elements' <a href="../lang/comparable">natural ordering</a> should be used.</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - if <code>fromIndex &gt; toIndex</code> or (optional) if the natural ordering of the array elements is found to violate the <a href="../lang/comparable"><code>Comparable</code></a> contract</dd> <dd>
<code><a href="../lang/arrayindexoutofboundsexception">ArrayIndexOutOfBoundsException</a></code> - if <code>fromIndex &lt; 0</code> or <code>toIndex &gt; a.length</code>
</dd> <dd>
<code><a href="../lang/classcastexception">ClassCastException</a></code> - if the array contains elements that are not <i>mutually comparable</i> (for example, strings and integers).</dd> <dt>Since:</dt> <dd>1.8</dd> </dl>    <h3 id="sort(java.lang.Object[])">sort</h3> <pre data-language="java">public static void sort(Object[] a)</pre> <div>
<p>Sorts the specified array of objects into ascending order, according to the <a href="../lang/comparable">natural ordering</a> of its elements. All elements in the array must implement the <a href="../lang/comparable"><code>Comparable</code></a> interface. Furthermore, all elements in the array must be <i>mutually comparable</i> (that is, <code>e1.compareTo(e2)</code> must not throw a <code>ClassCastException</code> for any elements <code>e1</code> and <code>e2</code> in the array). </p>
<p>This sort is guaranteed to be <i>stable</i>: equal elements will not be reordered as a result of the sort. </p>
<p>Implementation note: This implementation is a stable, adaptive, iterative mergesort that requires far fewer than n lg(n) comparisons when the input array is partially sorted, while offering the performance of a traditional mergesort when the input array is randomly ordered. If the input array is nearly sorted, the implementation requires approximately n comparisons. Temporary storage requirements vary from a small constant for nearly sorted input arrays to n/2 object references for randomly ordered input arrays. </p>
<p>The implementation takes equal advantage of ascending and descending order in its input array, and can take advantage of ascending and descending order in different parts of the same input array. It is well-suited to merging two or more sorted arrays: simply concatenate the arrays and sort the resulting array. </p>
<p>The implementation was adapted from Tim Peters's list sort for Python (<a href="http://svn.python.org/projects/python/trunk/Objects/listsort.txt"> TimSort</a>). It uses techniques from Peter McIlroy's "Optimistic Sorting and Information Theoretic Complexity", in Proceedings of the Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474, January 1993.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the array to be sorted</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/classcastexception">ClassCastException</a></code> - if the array contains elements that are not <i>mutually comparable</i> (for example, strings and integers)</dd> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - (optional) if the natural ordering of the array elements is found to violate the <a href="../lang/comparable"><code>Comparable</code></a> contract</dd> </dl>    <h3 id="sort(java.lang.Object[],int,int)">sort</h3> <pre data-language="java">public static void sort(Object[] a,
                        int fromIndex,
                        int toIndex)</pre> <div>
<p>Sorts the specified range of the specified array of objects into ascending order, according to the <a href="../lang/comparable">natural ordering</a> of its elements. The range to be sorted extends from index <code>fromIndex</code>, inclusive, to index <code>toIndex</code>, exclusive. (If <code>fromIndex==toIndex</code>, the range to be sorted is empty.) All elements in this range must implement the <a href="../lang/comparable"><code>Comparable</code></a> interface. Furthermore, all elements in this range must be <i>mutually comparable</i> (that is, <code>e1.compareTo(e2)</code> must not throw a <code>ClassCastException</code> for any elements <code>e1</code> and <code>e2</code> in the array). </p>
<p>This sort is guaranteed to be <i>stable</i>: equal elements will not be reordered as a result of the sort. </p>
<p>Implementation note: This implementation is a stable, adaptive, iterative mergesort that requires far fewer than n lg(n) comparisons when the input array is partially sorted, while offering the performance of a traditional mergesort when the input array is randomly ordered. If the input array is nearly sorted, the implementation requires approximately n comparisons. Temporary storage requirements vary from a small constant for nearly sorted input arrays to n/2 object references for randomly ordered input arrays. </p>
<p>The implementation takes equal advantage of ascending and descending order in its input array, and can take advantage of ascending and descending order in different parts of the same input array. It is well-suited to merging two or more sorted arrays: simply concatenate the arrays and sort the resulting array. </p>
<p>The implementation was adapted from Tim Peters's list sort for Python (<a href="http://svn.python.org/projects/python/trunk/Objects/listsort.txt"> TimSort</a>). It uses techniques from Peter McIlroy's "Optimistic Sorting and Information Theoretic Complexity", in Proceedings of the Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474, January 1993.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the array to be sorted</dd> <dd>
<code>fromIndex</code> - the index of the first element (inclusive) to be sorted</dd> <dd>
<code>toIndex</code> - the index of the last element (exclusive) to be sorted</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - if <code>fromIndex &gt; toIndex</code> or (optional) if the natural ordering of the array elements is found to violate the <a href="../lang/comparable"><code>Comparable</code></a> contract</dd> <dd>
<code><a href="../lang/arrayindexoutofboundsexception">ArrayIndexOutOfBoundsException</a></code> - if <code>fromIndex &lt; 0</code> or <code>toIndex &gt; a.length</code>
</dd> <dd>
<code><a href="../lang/classcastexception">ClassCastException</a></code> - if the array contains elements that are not <i>mutually comparable</i> (for example, strings and integers).</dd> </dl>    <h3 id="sort(java.lang.Object[],java.util.Comparator)">sort</h3> <pre data-language="java">public static &lt;T&gt; void sort(T[] a,
                            Comparator&lt;? super T&gt; c)</pre> <div>
<p>Sorts the specified array of objects according to the order induced by the specified comparator. All elements in the array must be <i>mutually comparable</i> by the specified comparator (that is, <code>c.compare(e1, e2)</code> must not throw a <code>ClassCastException</code> for any elements <code>e1</code> and <code>e2</code> in the array). </p>
<p>This sort is guaranteed to be <i>stable</i>: equal elements will not be reordered as a result of the sort. </p>
<p>Implementation note: This implementation is a stable, adaptive, iterative mergesort that requires far fewer than n lg(n) comparisons when the input array is partially sorted, while offering the performance of a traditional mergesort when the input array is randomly ordered. If the input array is nearly sorted, the implementation requires approximately n comparisons. Temporary storage requirements vary from a small constant for nearly sorted input arrays to n/2 object references for randomly ordered input arrays. </p>
<p>The implementation takes equal advantage of ascending and descending order in its input array, and can take advantage of ascending and descending order in different parts of the same input array. It is well-suited to merging two or more sorted arrays: simply concatenate the arrays and sort the resulting array. </p>
<p>The implementation was adapted from Tim Peters's list sort for Python (<a href="http://svn.python.org/projects/python/trunk/Objects/listsort.txt"> TimSort</a>). It uses techniques from Peter McIlroy's "Optimistic Sorting and Information Theoretic Complexity", in Proceedings of the Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474, January 1993.</p>
</div> <dl> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the class of the objects to be sorted</dd> <dt>Parameters:</dt> <dd>
<code>a</code> - the array to be sorted</dd> <dd>
<code>c</code> - the comparator to determine the order of the array. A <code>null</code> value indicates that the elements' <a href="../lang/comparable">natural ordering</a> should be used.</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/classcastexception">ClassCastException</a></code> - if the array contains elements that are not <i>mutually comparable</i> using the specified comparator</dd> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - (optional) if the comparator is found to violate the <a href="comparator"><code>Comparator</code></a> contract</dd> </dl>    <h3 id="sort(java.lang.Object[],int,int,java.util.Comparator)">sort</h3> <pre data-language="java">public static &lt;T&gt; void sort(T[] a,
                            int fromIndex,
                            int toIndex,
                            Comparator&lt;? super T&gt; c)</pre> <div>
<p>Sorts the specified range of the specified array of objects according to the order induced by the specified comparator. The range to be sorted extends from index <code>fromIndex</code>, inclusive, to index <code>toIndex</code>, exclusive. (If <code>fromIndex==toIndex</code>, the range to be sorted is empty.) All elements in the range must be <i>mutually comparable</i> by the specified comparator (that is, <code>c.compare(e1, e2)</code> must not throw a <code>ClassCastException</code> for any elements <code>e1</code> and <code>e2</code> in the range). </p>
<p>This sort is guaranteed to be <i>stable</i>: equal elements will not be reordered as a result of the sort. </p>
<p>Implementation note: This implementation is a stable, adaptive, iterative mergesort that requires far fewer than n lg(n) comparisons when the input array is partially sorted, while offering the performance of a traditional mergesort when the input array is randomly ordered. If the input array is nearly sorted, the implementation requires approximately n comparisons. Temporary storage requirements vary from a small constant for nearly sorted input arrays to n/2 object references for randomly ordered input arrays. </p>
<p>The implementation takes equal advantage of ascending and descending order in its input array, and can take advantage of ascending and descending order in different parts of the same input array. It is well-suited to merging two or more sorted arrays: simply concatenate the arrays and sort the resulting array. </p>
<p>The implementation was adapted from Tim Peters's list sort for Python (<a href="http://svn.python.org/projects/python/trunk/Objects/listsort.txt"> TimSort</a>). It uses techniques from Peter McIlroy's "Optimistic Sorting and Information Theoretic Complexity", in Proceedings of the Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474, January 1993.</p>
</div> <dl> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the class of the objects to be sorted</dd> <dt>Parameters:</dt> <dd>
<code>a</code> - the array to be sorted</dd> <dd>
<code>fromIndex</code> - the index of the first element (inclusive) to be sorted</dd> <dd>
<code>toIndex</code> - the index of the last element (exclusive) to be sorted</dd> <dd>
<code>c</code> - the comparator to determine the order of the array. A <code>null</code> value indicates that the elements' <a href="../lang/comparable">natural ordering</a> should be used.</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/classcastexception">ClassCastException</a></code> - if the array contains elements that are not <i>mutually comparable</i> using the specified comparator.</dd> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - if <code>fromIndex &gt; toIndex</code> or (optional) if the comparator is found to violate the <a href="comparator"><code>Comparator</code></a> contract</dd> <dd>
<code><a href="../lang/arrayindexoutofboundsexception">ArrayIndexOutOfBoundsException</a></code> - if <code>fromIndex &lt; 0</code> or <code>toIndex &gt; a.length</code>
</dd> </dl>    <h3 id="parallelPrefix(java.lang.Object[],java.util.function.BinaryOperator)">parallelPrefix</h3> <pre data-language="java">public static &lt;T&gt; void parallelPrefix(T[] array,
                                      BinaryOperator&lt;T&gt; op)</pre> <p>Cumulates, in parallel, each element of the given array in place, using the supplied function. For example if the array initially holds <code>[2, 1, 0, 3]</code> and the operation performs addition, then upon return the array holds <code>[2, 3, 3, 6]</code>. Parallel prefix computation is usually more efficient than sequential loops for large arrays.</p> <dl> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the class of the objects in the array</dd> <dt>Parameters:</dt> <dd>
<code>array</code> - the array, which is modified in-place by this method</dd> <dd>
<code>op</code> - a side-effect-free, associative function to perform the cumulation</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/nullpointerexception">NullPointerException</a></code> - if the specified array or function is null</dd> <dt>Since:</dt> <dd>1.8</dd> </dl>    <h3 id="parallelPrefix(java.lang.Object[],int,int,java.util.function.BinaryOperator)">parallelPrefix</h3> <pre data-language="java">public static &lt;T&gt; void parallelPrefix(T[] array,
                                      int fromIndex,
                                      int toIndex,
                                      BinaryOperator&lt;T&gt; op)</pre> <p>Performs <a href="#parallelPrefix(T%5B%5D,java.util.function.BinaryOperator)"><code>parallelPrefix(Object[], BinaryOperator)</code></a> for the given subrange of the array.</p> <dl> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the class of the objects in the array</dd> <dt>Parameters:</dt> <dd>
<code>array</code> - the array</dd> <dd>
<code>fromIndex</code> - the index of the first element, inclusive</dd> <dd>
<code>toIndex</code> - the index of the last element, exclusive</dd> <dd>
<code>op</code> - a side-effect-free, associative function to perform the cumulation</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - if <code>fromIndex &gt; toIndex</code>
</dd> <dd>
<code><a href="../lang/arrayindexoutofboundsexception">ArrayIndexOutOfBoundsException</a></code> - if <code>fromIndex &lt; 0</code> or <code>toIndex &gt; array.length</code>
</dd> <dd>
<code><a href="../lang/nullpointerexception">NullPointerException</a></code> - if the specified array or function is null</dd> <dt>Since:</dt> <dd>1.8</dd> </dl>    <h3 id="parallelPrefix(long[],java.util.function.LongBinaryOperator)">parallelPrefix</h3> <pre data-language="java">public static void parallelPrefix(long[] array,
                                  LongBinaryOperator op)</pre> <p>Cumulates, in parallel, each element of the given array in place, using the supplied function. For example if the array initially holds <code>[2, 1, 0, 3]</code> and the operation performs addition, then upon return the array holds <code>[2, 3, 3, 6]</code>. Parallel prefix computation is usually more efficient than sequential loops for large arrays.</p> <dl> <dt>Parameters:</dt> <dd>
<code>array</code> - the array, which is modified in-place by this method</dd> <dd>
<code>op</code> - a side-effect-free, associative function to perform the cumulation</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/nullpointerexception">NullPointerException</a></code> - if the specified array or function is null</dd> <dt>Since:</dt> <dd>1.8</dd> </dl>    <h3 id="parallelPrefix(long[],int,int,java.util.function.LongBinaryOperator)">parallelPrefix</h3> <pre data-language="java">public static void parallelPrefix(long[] array,
                                  int fromIndex,
                                  int toIndex,
                                  LongBinaryOperator op)</pre> <p>Performs <a href="#parallelPrefix(long%5B%5D,java.util.function.LongBinaryOperator)"><code>parallelPrefix(long[], LongBinaryOperator)</code></a> for the given subrange of the array.</p> <dl> <dt>Parameters:</dt> <dd>
<code>array</code> - the array</dd> <dd>
<code>fromIndex</code> - the index of the first element, inclusive</dd> <dd>
<code>toIndex</code> - the index of the last element, exclusive</dd> <dd>
<code>op</code> - a side-effect-free, associative function to perform the cumulation</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - if <code>fromIndex &gt; toIndex</code>
</dd> <dd>
<code><a href="../lang/arrayindexoutofboundsexception">ArrayIndexOutOfBoundsException</a></code> - if <code>fromIndex &lt; 0</code> or <code>toIndex &gt; array.length</code>
</dd> <dd>
<code><a href="../lang/nullpointerexception">NullPointerException</a></code> - if the specified array or function is null</dd> <dt>Since:</dt> <dd>1.8</dd> </dl>    <h3 id="parallelPrefix(double[],java.util.function.DoubleBinaryOperator)">parallelPrefix</h3> <pre data-language="java">public static void parallelPrefix(double[] array,
                                  DoubleBinaryOperator op)</pre> <div>
<p>Cumulates, in parallel, each element of the given array in place, using the supplied function. For example if the array initially holds <code>[2.0, 1.0, 0.0, 3.0]</code> and the operation performs addition, then upon return the array holds <code>[2.0, 3.0, 3.0, 6.0]</code>. Parallel prefix computation is usually more efficient than sequential loops for large arrays. </p>
<p> Because floating-point operations may not be strictly associative, the returned result may not be identical to the value that would be obtained if the operation was performed sequentially.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>array</code> - the array, which is modified in-place by this method</dd> <dd>
<code>op</code> - a side-effect-free function to perform the cumulation</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/nullpointerexception">NullPointerException</a></code> - if the specified array or function is null</dd> <dt>Since:</dt> <dd>1.8</dd> </dl>    <h3 id="parallelPrefix(double[],int,int,java.util.function.DoubleBinaryOperator)">parallelPrefix</h3> <pre data-language="java">public static void parallelPrefix(double[] array,
                                  int fromIndex,
                                  int toIndex,
                                  DoubleBinaryOperator op)</pre> <p>Performs <a href="#parallelPrefix(double%5B%5D,java.util.function.DoubleBinaryOperator)"><code>parallelPrefix(double[], DoubleBinaryOperator)</code></a> for the given subrange of the array.</p> <dl> <dt>Parameters:</dt> <dd>
<code>array</code> - the array</dd> <dd>
<code>fromIndex</code> - the index of the first element, inclusive</dd> <dd>
<code>toIndex</code> - the index of the last element, exclusive</dd> <dd>
<code>op</code> - a side-effect-free, associative function to perform the cumulation</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - if <code>fromIndex &gt; toIndex</code>
</dd> <dd>
<code><a href="../lang/arrayindexoutofboundsexception">ArrayIndexOutOfBoundsException</a></code> - if <code>fromIndex &lt; 0</code> or <code>toIndex &gt; array.length</code>
</dd> <dd>
<code><a href="../lang/nullpointerexception">NullPointerException</a></code> - if the specified array or function is null</dd> <dt>Since:</dt> <dd>1.8</dd> </dl>    <h3 id="parallelPrefix(int[],java.util.function.IntBinaryOperator)">parallelPrefix</h3> <pre data-language="java">public static void parallelPrefix(int[] array,
                                  IntBinaryOperator op)</pre> <p>Cumulates, in parallel, each element of the given array in place, using the supplied function. For example if the array initially holds <code>[2, 1, 0, 3]</code> and the operation performs addition, then upon return the array holds <code>[2, 3, 3, 6]</code>. Parallel prefix computation is usually more efficient than sequential loops for large arrays.</p> <dl> <dt>Parameters:</dt> <dd>
<code>array</code> - the array, which is modified in-place by this method</dd> <dd>
<code>op</code> - a side-effect-free, associative function to perform the cumulation</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/nullpointerexception">NullPointerException</a></code> - if the specified array or function is null</dd> <dt>Since:</dt> <dd>1.8</dd> </dl>    <h3 id="parallelPrefix(int[],int,int,java.util.function.IntBinaryOperator)">parallelPrefix</h3> <pre data-language="java">public static void parallelPrefix(int[] array,
                                  int fromIndex,
                                  int toIndex,
                                  IntBinaryOperator op)</pre> <p>Performs <a href="#parallelPrefix(int%5B%5D,java.util.function.IntBinaryOperator)"><code>parallelPrefix(int[], IntBinaryOperator)</code></a> for the given subrange of the array.</p> <dl> <dt>Parameters:</dt> <dd>
<code>array</code> - the array</dd> <dd>
<code>fromIndex</code> - the index of the first element, inclusive</dd> <dd>
<code>toIndex</code> - the index of the last element, exclusive</dd> <dd>
<code>op</code> - a side-effect-free, associative function to perform the cumulation</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - if <code>fromIndex &gt; toIndex</code>
</dd> <dd>
<code><a href="../lang/arrayindexoutofboundsexception">ArrayIndexOutOfBoundsException</a></code> - if <code>fromIndex &lt; 0</code> or <code>toIndex &gt; array.length</code>
</dd> <dd>
<code><a href="../lang/nullpointerexception">NullPointerException</a></code> - if the specified array or function is null</dd> <dt>Since:</dt> <dd>1.8</dd> </dl>    <h3 id="binarySearch(long[],long)">binarySearch</h3> <pre data-language="java">public static int binarySearch(long[] a,
                               long key)</pre> <p>Searches the specified array of longs for the specified value using the binary search algorithm. The array must be sorted (as by the <a href="#sort(long%5B%5D)"><code>sort(long[])</code></a> method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.</p> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the array to be searched</dd> <dd>
<code>key</code> - the value to be searched for</dd> <dt>Returns:</dt> <dd>index of the search key, if it is contained in the array; otherwise, <code>(-(<i>insertion point</i>) - 1)</code>. The <i>insertion point</i> is defined as the point at which the key would be inserted into the array: the index of the first element greater than the key, or <code>a.length</code> if all elements in the array are less than the specified key. Note that this guarantees that the return value will be &gt;= 0 if and only if the key is found.</dd> </dl>    <h3 id="binarySearch(long[],int,int,long)">binarySearch</h3> <pre data-language="java">public static int binarySearch(long[] a,
                               int fromIndex,
                               int toIndex,
                               long key)</pre> <p>Searches a range of the specified array of longs for the specified value using the binary search algorithm. The range must be sorted (as by the <a href="#sort(long%5B%5D,int,int)"><code>sort(long[], int, int)</code></a> method) prior to making this call. If it is not sorted, the results are undefined. If the range contains multiple elements with the specified value, there is no guarantee which one will be found.</p> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the array to be searched</dd> <dd>
<code>fromIndex</code> - the index of the first element (inclusive) to be searched</dd> <dd>
<code>toIndex</code> - the index of the last element (exclusive) to be searched</dd> <dd>
<code>key</code> - the value to be searched for</dd> <dt>Returns:</dt> <dd>index of the search key, if it is contained in the array within the specified range; otherwise, <code>(-(<i>insertion point</i>) - 1)</code>. The <i>insertion point</i> is defined as the point at which the key would be inserted into the array: the index of the first element in the range greater than the key, or <code>toIndex</code> if all elements in the range are less than the specified key. Note that this guarantees that the return value will be &gt;= 0 if and only if the key is found.</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - if <code>fromIndex &gt; toIndex</code>
</dd> <dd>
<code><a href="../lang/arrayindexoutofboundsexception">ArrayIndexOutOfBoundsException</a></code> - if <code>fromIndex &lt; 0 or toIndex &gt; a.length</code>
</dd> <dt>Since:</dt> <dd>1.6</dd> </dl>    <h3 id="binarySearch(int[],int)">binarySearch</h3> <pre data-language="java">public static int binarySearch(int[] a,
                               int key)</pre> <p>Searches the specified array of ints for the specified value using the binary search algorithm. The array must be sorted (as by the <a href="#sort(int%5B%5D)"><code>sort(int[])</code></a> method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.</p> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the array to be searched</dd> <dd>
<code>key</code> - the value to be searched for</dd> <dt>Returns:</dt> <dd>index of the search key, if it is contained in the array; otherwise, <code>(-(<i>insertion point</i>) - 1)</code>. The <i>insertion point</i> is defined as the point at which the key would be inserted into the array: the index of the first element greater than the key, or <code>a.length</code> if all elements in the array are less than the specified key. Note that this guarantees that the return value will be &gt;= 0 if and only if the key is found.</dd> </dl>    <h3 id="binarySearch(int[],int,int,int)">binarySearch</h3> <pre data-language="java">public static int binarySearch(int[] a,
                               int fromIndex,
                               int toIndex,
                               int key)</pre> <p>Searches a range of the specified array of ints for the specified value using the binary search algorithm. The range must be sorted (as by the <a href="#sort(int%5B%5D,int,int)"><code>sort(int[], int, int)</code></a> method) prior to making this call. If it is not sorted, the results are undefined. If the range contains multiple elements with the specified value, there is no guarantee which one will be found.</p> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the array to be searched</dd> <dd>
<code>fromIndex</code> - the index of the first element (inclusive) to be searched</dd> <dd>
<code>toIndex</code> - the index of the last element (exclusive) to be searched</dd> <dd>
<code>key</code> - the value to be searched for</dd> <dt>Returns:</dt> <dd>index of the search key, if it is contained in the array within the specified range; otherwise, <code>(-(<i>insertion point</i>) - 1)</code>. The <i>insertion point</i> is defined as the point at which the key would be inserted into the array: the index of the first element in the range greater than the key, or <code>toIndex</code> if all elements in the range are less than the specified key. Note that this guarantees that the return value will be &gt;= 0 if and only if the key is found.</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - if <code>fromIndex &gt; toIndex</code>
</dd> <dd>
<code><a href="../lang/arrayindexoutofboundsexception">ArrayIndexOutOfBoundsException</a></code> - if <code>fromIndex &lt; 0 or toIndex &gt; a.length</code>
</dd> <dt>Since:</dt> <dd>1.6</dd> </dl>    <h3 id="binarySearch(short[],short)">binarySearch</h3> <pre data-language="java">public static int binarySearch(short[] a,
                               short key)</pre> <p>Searches the specified array of shorts for the specified value using the binary search algorithm. The array must be sorted (as by the <a href="#sort(short%5B%5D)"><code>sort(short[])</code></a> method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.</p> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the array to be searched</dd> <dd>
<code>key</code> - the value to be searched for</dd> <dt>Returns:</dt> <dd>index of the search key, if it is contained in the array; otherwise, <code>(-(<i>insertion point</i>) - 1)</code>. The <i>insertion point</i> is defined as the point at which the key would be inserted into the array: the index of the first element greater than the key, or <code>a.length</code> if all elements in the array are less than the specified key. Note that this guarantees that the return value will be &gt;= 0 if and only if the key is found.</dd> </dl>    <h3 id="binarySearch(short[],int,int,short)">binarySearch</h3> <pre data-language="java">public static int binarySearch(short[] a,
                               int fromIndex,
                               int toIndex,
                               short key)</pre> <p>Searches a range of the specified array of shorts for the specified value using the binary search algorithm. The range must be sorted (as by the <a href="#sort(short%5B%5D,int,int)"><code>sort(short[], int, int)</code></a> method) prior to making this call. If it is not sorted, the results are undefined. If the range contains multiple elements with the specified value, there is no guarantee which one will be found.</p> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the array to be searched</dd> <dd>
<code>fromIndex</code> - the index of the first element (inclusive) to be searched</dd> <dd>
<code>toIndex</code> - the index of the last element (exclusive) to be searched</dd> <dd>
<code>key</code> - the value to be searched for</dd> <dt>Returns:</dt> <dd>index of the search key, if it is contained in the array within the specified range; otherwise, <code>(-(<i>insertion point</i>) - 1)</code>. The <i>insertion point</i> is defined as the point at which the key would be inserted into the array: the index of the first element in the range greater than the key, or <code>toIndex</code> if all elements in the range are less than the specified key. Note that this guarantees that the return value will be &gt;= 0 if and only if the key is found.</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - if <code>fromIndex &gt; toIndex</code>
</dd> <dd>
<code><a href="../lang/arrayindexoutofboundsexception">ArrayIndexOutOfBoundsException</a></code> - if <code>fromIndex &lt; 0 or toIndex &gt; a.length</code>
</dd> <dt>Since:</dt> <dd>1.6</dd> </dl>    <h3 id="binarySearch(char[],char)">binarySearch</h3> <pre data-language="java">public static int binarySearch(char[] a,
                               char key)</pre> <p>Searches the specified array of chars for the specified value using the binary search algorithm. The array must be sorted (as by the <a href="#sort(char%5B%5D)"><code>sort(char[])</code></a> method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.</p> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the array to be searched</dd> <dd>
<code>key</code> - the value to be searched for</dd> <dt>Returns:</dt> <dd>index of the search key, if it is contained in the array; otherwise, <code>(-(<i>insertion point</i>) - 1)</code>. The <i>insertion point</i> is defined as the point at which the key would be inserted into the array: the index of the first element greater than the key, or <code>a.length</code> if all elements in the array are less than the specified key. Note that this guarantees that the return value will be &gt;= 0 if and only if the key is found.</dd> </dl>    <h3 id="binarySearch(char[],int,int,char)">binarySearch</h3> <pre data-language="java">public static int binarySearch(char[] a,
                               int fromIndex,
                               int toIndex,
                               char key)</pre> <p>Searches a range of the specified array of chars for the specified value using the binary search algorithm. The range must be sorted (as by the <a href="#sort(char%5B%5D,int,int)"><code>sort(char[], int, int)</code></a> method) prior to making this call. If it is not sorted, the results are undefined. If the range contains multiple elements with the specified value, there is no guarantee which one will be found.</p> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the array to be searched</dd> <dd>
<code>fromIndex</code> - the index of the first element (inclusive) to be searched</dd> <dd>
<code>toIndex</code> - the index of the last element (exclusive) to be searched</dd> <dd>
<code>key</code> - the value to be searched for</dd> <dt>Returns:</dt> <dd>index of the search key, if it is contained in the array within the specified range; otherwise, <code>(-(<i>insertion point</i>) - 1)</code>. The <i>insertion point</i> is defined as the point at which the key would be inserted into the array: the index of the first element in the range greater than the key, or <code>toIndex</code> if all elements in the range are less than the specified key. Note that this guarantees that the return value will be &gt;= 0 if and only if the key is found.</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - if <code>fromIndex &gt; toIndex</code>
</dd> <dd>
<code><a href="../lang/arrayindexoutofboundsexception">ArrayIndexOutOfBoundsException</a></code> - if <code>fromIndex &lt; 0 or toIndex &gt; a.length</code>
</dd> <dt>Since:</dt> <dd>1.6</dd> </dl>    <h3 id="binarySearch(byte[],byte)">binarySearch</h3> <pre data-language="java">public static int binarySearch(byte[] a,
                               byte key)</pre> <p>Searches the specified array of bytes for the specified value using the binary search algorithm. The array must be sorted (as by the <a href="#sort(byte%5B%5D)"><code>sort(byte[])</code></a> method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.</p> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the array to be searched</dd> <dd>
<code>key</code> - the value to be searched for</dd> <dt>Returns:</dt> <dd>index of the search key, if it is contained in the array; otherwise, <code>(-(<i>insertion point</i>) - 1)</code>. The <i>insertion point</i> is defined as the point at which the key would be inserted into the array: the index of the first element greater than the key, or <code>a.length</code> if all elements in the array are less than the specified key. Note that this guarantees that the return value will be &gt;= 0 if and only if the key is found.</dd> </dl>    <h3 id="binarySearch(byte[],int,int,byte)">binarySearch</h3> <pre data-language="java">public static int binarySearch(byte[] a,
                               int fromIndex,
                               int toIndex,
                               byte key)</pre> <p>Searches a range of the specified array of bytes for the specified value using the binary search algorithm. The range must be sorted (as by the <a href="#sort(byte%5B%5D,int,int)"><code>sort(byte[], int, int)</code></a> method) prior to making this call. If it is not sorted, the results are undefined. If the range contains multiple elements with the specified value, there is no guarantee which one will be found.</p> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the array to be searched</dd> <dd>
<code>fromIndex</code> - the index of the first element (inclusive) to be searched</dd> <dd>
<code>toIndex</code> - the index of the last element (exclusive) to be searched</dd> <dd>
<code>key</code> - the value to be searched for</dd> <dt>Returns:</dt> <dd>index of the search key, if it is contained in the array within the specified range; otherwise, <code>(-(<i>insertion point</i>) - 1)</code>. The <i>insertion point</i> is defined as the point at which the key would be inserted into the array: the index of the first element in the range greater than the key, or <code>toIndex</code> if all elements in the range are less than the specified key. Note that this guarantees that the return value will be &gt;= 0 if and only if the key is found.</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - if <code>fromIndex &gt; toIndex</code>
</dd> <dd>
<code><a href="../lang/arrayindexoutofboundsexception">ArrayIndexOutOfBoundsException</a></code> - if <code>fromIndex &lt; 0 or toIndex &gt; a.length</code>
</dd> <dt>Since:</dt> <dd>1.6</dd> </dl>    <h3 id="binarySearch(double[],double)">binarySearch</h3> <pre data-language="java">public static int binarySearch(double[] a,
                               double key)</pre> <p>Searches the specified array of doubles for the specified value using the binary search algorithm. The array must be sorted (as by the <a href="#sort(double%5B%5D)"><code>sort(double[])</code></a> method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.</p> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the array to be searched</dd> <dd>
<code>key</code> - the value to be searched for</dd> <dt>Returns:</dt> <dd>index of the search key, if it is contained in the array; otherwise, <code>(-(<i>insertion point</i>) - 1)</code>. The <i>insertion point</i> is defined as the point at which the key would be inserted into the array: the index of the first element greater than the key, or <code>a.length</code> if all elements in the array are less than the specified key. Note that this guarantees that the return value will be &gt;= 0 if and only if the key is found.</dd> </dl>    <h3 id="binarySearch(double[],int,int,double)">binarySearch</h3> <pre data-language="java">public static int binarySearch(double[] a,
                               int fromIndex,
                               int toIndex,
                               double key)</pre> <p>Searches a range of the specified array of doubles for the specified value using the binary search algorithm. The range must be sorted (as by the <a href="#sort(double%5B%5D,int,int)"><code>sort(double[], int, int)</code></a> method) prior to making this call. If it is not sorted, the results are undefined. If the range contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.</p> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the array to be searched</dd> <dd>
<code>fromIndex</code> - the index of the first element (inclusive) to be searched</dd> <dd>
<code>toIndex</code> - the index of the last element (exclusive) to be searched</dd> <dd>
<code>key</code> - the value to be searched for</dd> <dt>Returns:</dt> <dd>index of the search key, if it is contained in the array within the specified range; otherwise, <code>(-(<i>insertion point</i>) - 1)</code>. The <i>insertion point</i> is defined as the point at which the key would be inserted into the array: the index of the first element in the range greater than the key, or <code>toIndex</code> if all elements in the range are less than the specified key. Note that this guarantees that the return value will be &gt;= 0 if and only if the key is found.</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - if <code>fromIndex &gt; toIndex</code>
</dd> <dd>
<code><a href="../lang/arrayindexoutofboundsexception">ArrayIndexOutOfBoundsException</a></code> - if <code>fromIndex &lt; 0 or toIndex &gt; a.length</code>
</dd> <dt>Since:</dt> <dd>1.6</dd> </dl>    <h3 id="binarySearch(float[],float)">binarySearch</h3> <pre data-language="java">public static int binarySearch(float[] a,
                               float key)</pre> <p>Searches the specified array of floats for the specified value using the binary search algorithm. The array must be sorted (as by the <a href="#sort(float%5B%5D)"><code>sort(float[])</code></a> method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.</p> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the array to be searched</dd> <dd>
<code>key</code> - the value to be searched for</dd> <dt>Returns:</dt> <dd>index of the search key, if it is contained in the array; otherwise, <code>(-(<i>insertion point</i>) - 1)</code>. The <i>insertion point</i> is defined as the point at which the key would be inserted into the array: the index of the first element greater than the key, or <code>a.length</code> if all elements in the array are less than the specified key. Note that this guarantees that the return value will be &gt;= 0 if and only if the key is found.</dd> </dl>    <h3 id="binarySearch(float[],int,int,float)">binarySearch</h3> <pre data-language="java">public static int binarySearch(float[] a,
                               int fromIndex,
                               int toIndex,
                               float key)</pre> <p>Searches a range of the specified array of floats for the specified value using the binary search algorithm. The range must be sorted (as by the <a href="#sort(float%5B%5D,int,int)"><code>sort(float[], int, int)</code></a> method) prior to making this call. If it is not sorted, the results are undefined. If the range contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.</p> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the array to be searched</dd> <dd>
<code>fromIndex</code> - the index of the first element (inclusive) to be searched</dd> <dd>
<code>toIndex</code> - the index of the last element (exclusive) to be searched</dd> <dd>
<code>key</code> - the value to be searched for</dd> <dt>Returns:</dt> <dd>index of the search key, if it is contained in the array within the specified range; otherwise, <code>(-(<i>insertion point</i>) - 1)</code>. The <i>insertion point</i> is defined as the point at which the key would be inserted into the array: the index of the first element in the range greater than the key, or <code>toIndex</code> if all elements in the range are less than the specified key. Note that this guarantees that the return value will be &gt;= 0 if and only if the key is found.</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - if <code>fromIndex &gt; toIndex</code>
</dd> <dd>
<code><a href="../lang/arrayindexoutofboundsexception">ArrayIndexOutOfBoundsException</a></code> - if <code>fromIndex &lt; 0 or toIndex &gt; a.length</code>
</dd> <dt>Since:</dt> <dd>1.6</dd> </dl>    <h3 id="binarySearch(java.lang.Object[],java.lang.Object)">binarySearch</h3> <pre data-language="java">public static int binarySearch(Object[] a,
                               Object key)</pre> <p>Searches the specified array for the specified object using the binary search algorithm. The array must be sorted into ascending order according to the <a href="../lang/comparable">natural ordering</a> of its elements (as by the <a href="#sort(java.lang.Object%5B%5D)"><code>sort(Object[])</code></a> method) prior to making this call. If it is not sorted, the results are undefined. (If the array contains elements that are not mutually comparable (for example, strings and integers), it <i>cannot</i> be sorted according to the natural ordering of its elements, hence results are undefined.) If the array contains multiple elements equal to the specified object, there is no guarantee which one will be found.</p> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the array to be searched</dd> <dd>
<code>key</code> - the value to be searched for</dd> <dt>Returns:</dt> <dd>index of the search key, if it is contained in the array; otherwise, <code>(-(<i>insertion point</i>) - 1)</code>. The <i>insertion point</i> is defined as the point at which the key would be inserted into the array: the index of the first element greater than the key, or <code>a.length</code> if all elements in the array are less than the specified key. Note that this guarantees that the return value will be &gt;= 0 if and only if the key is found.</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/classcastexception">ClassCastException</a></code> - if the search key is not comparable to the elements of the array.</dd> </dl>    <h3 id="binarySearch(java.lang.Object[],int,int,java.lang.Object)">binarySearch</h3> <pre data-language="java">public static int binarySearch(Object[] a,
                               int fromIndex,
                               int toIndex,
                               Object key)</pre> <p>Searches a range of the specified array for the specified object using the binary search algorithm. The range must be sorted into ascending order according to the <a href="../lang/comparable">natural ordering</a> of its elements (as by the <a href="#sort(java.lang.Object%5B%5D,int,int)"><code>sort(Object[], int, int)</code></a> method) prior to making this call. If it is not sorted, the results are undefined. (If the range contains elements that are not mutually comparable (for example, strings and integers), it <i>cannot</i> be sorted according to the natural ordering of its elements, hence results are undefined.) If the range contains multiple elements equal to the specified object, there is no guarantee which one will be found.</p> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the array to be searched</dd> <dd>
<code>fromIndex</code> - the index of the first element (inclusive) to be searched</dd> <dd>
<code>toIndex</code> - the index of the last element (exclusive) to be searched</dd> <dd>
<code>key</code> - the value to be searched for</dd> <dt>Returns:</dt> <dd>index of the search key, if it is contained in the array within the specified range; otherwise, <code>(-(<i>insertion point</i>) - 1)</code>. The <i>insertion point</i> is defined as the point at which the key would be inserted into the array: the index of the first element in the range greater than the key, or <code>toIndex</code> if all elements in the range are less than the specified key. Note that this guarantees that the return value will be &gt;= 0 if and only if the key is found.</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/classcastexception">ClassCastException</a></code> - if the search key is not comparable to the elements of the array within the specified range.</dd> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - if <code>fromIndex &gt; toIndex</code>
</dd> <dd>
<code><a href="../lang/arrayindexoutofboundsexception">ArrayIndexOutOfBoundsException</a></code> - if <code>fromIndex &lt; 0 or toIndex &gt; a.length</code>
</dd> <dt>Since:</dt> <dd>1.6</dd> </dl>    <h3 id="binarySearch(java.lang.Object[],java.lang.Object,java.util.Comparator)">binarySearch</h3> <pre data-language="java">public static &lt;T&gt; int binarySearch(T[] a,
                                   T key,
                                   Comparator&lt;? super T&gt; c)</pre> <p>Searches the specified array for the specified object using the binary search algorithm. The array must be sorted into ascending order according to the specified comparator (as by the <a href="#sort(T%5B%5D,java.util.Comparator)"><code>sort(T[], Comparator)</code></a> method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements equal to the specified object, there is no guarantee which one will be found.</p> <dl> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the class of the objects in the array</dd> <dt>Parameters:</dt> <dd>
<code>a</code> - the array to be searched</dd> <dd>
<code>key</code> - the value to be searched for</dd> <dd>
<code>c</code> - the comparator by which the array is ordered. A <code>null</code> value indicates that the elements' <a href="../lang/comparable">natural ordering</a> should be used.</dd> <dt>Returns:</dt> <dd>index of the search key, if it is contained in the array; otherwise, <code>(-(<i>insertion point</i>) - 1)</code>. The <i>insertion point</i> is defined as the point at which the key would be inserted into the array: the index of the first element greater than the key, or <code>a.length</code> if all elements in the array are less than the specified key. Note that this guarantees that the return value will be &gt;= 0 if and only if the key is found.</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/classcastexception">ClassCastException</a></code> - if the array contains elements that are not <i>mutually comparable</i> using the specified comparator, or the search key is not comparable to the elements of the array using this comparator.</dd> </dl>    <h3 id="binarySearch(java.lang.Object[],int,int,java.lang.Object,java.util.Comparator)">binarySearch</h3> <pre data-language="java">public static &lt;T&gt; int binarySearch(T[] a,
                                   int fromIndex,
                                   int toIndex,
                                   T key,
                                   Comparator&lt;? super T&gt; c)</pre> <p>Searches a range of the specified array for the specified object using the binary search algorithm. The range must be sorted into ascending order according to the specified comparator (as by the <a href="#sort(T%5B%5D,int,int,java.util.Comparator)"><code>sort(T[], int, int, Comparator)</code></a> method) prior to making this call. If it is not sorted, the results are undefined. If the range contains multiple elements equal to the specified object, there is no guarantee which one will be found.</p> <dl> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the class of the objects in the array</dd> <dt>Parameters:</dt> <dd>
<code>a</code> - the array to be searched</dd> <dd>
<code>fromIndex</code> - the index of the first element (inclusive) to be searched</dd> <dd>
<code>toIndex</code> - the index of the last element (exclusive) to be searched</dd> <dd>
<code>key</code> - the value to be searched for</dd> <dd>
<code>c</code> - the comparator by which the array is ordered. A <code>null</code> value indicates that the elements' <a href="../lang/comparable">natural ordering</a> should be used.</dd> <dt>Returns:</dt> <dd>index of the search key, if it is contained in the array within the specified range; otherwise, <code>(-(<i>insertion point</i>) - 1)</code>. The <i>insertion point</i> is defined as the point at which the key would be inserted into the array: the index of the first element in the range greater than the key, or <code>toIndex</code> if all elements in the range are less than the specified key. Note that this guarantees that the return value will be &gt;= 0 if and only if the key is found.</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/classcastexception">ClassCastException</a></code> - if the range contains elements that are not <i>mutually comparable</i> using the specified comparator, or the search key is not comparable to the elements in the range using this comparator.</dd> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - if <code>fromIndex &gt; toIndex</code>
</dd> <dd>
<code><a href="../lang/arrayindexoutofboundsexception">ArrayIndexOutOfBoundsException</a></code> - if <code>fromIndex &lt; 0 or toIndex &gt; a.length</code>
</dd> <dt>Since:</dt> <dd>1.6</dd> </dl>    <h3 id="equals(long[],long[])">equals</h3> <pre data-language="java">public static boolean equals(long[] a,
                             long[] a2)</pre> <p>Returns <code>true</code> if the two specified arrays of longs are <i>equal</i> to one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are <code>null</code>.</p> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - one array to be tested for equality</dd> <dd>
<code>a2</code> - the other array to be tested for equality</dd> <dt>Returns:</dt> <dd>
<code>true</code> if the two arrays are equal</dd> </dl>    <h3 id="equals(long[],int,int,long[],int,int)">equals</h3> <pre data-language="java">public static boolean equals(long[] a,
                             int aFromIndex,
                             int aToIndex,
                             long[] b,
                             int bFromIndex,
                             int bToIndex)</pre> <div>
<p>Returns true if the two specified arrays of longs, over the specified ranges, are <i>equal</i> to one another. </p>
<p>Two arrays are considered equal if the number of elements covered by each range is the same, and all corresponding pairs of elements over the specified ranges in the two arrays are equal. In other words, two arrays are equal if they contain, over the specified ranges, the same elements in the same order.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the first array to be tested for equality</dd> <dd>
<code>aFromIndex</code> - the index (inclusive) of the first element in the first array to be tested</dd> <dd>
<code>aToIndex</code> - the index (exclusive) of the last element in the first array to be tested</dd> <dd>
<code>b</code> - the second array to be tested fro equality</dd> <dd>
<code>bFromIndex</code> - the index (inclusive) of the first element in the second array to be tested</dd> <dd>
<code>bToIndex</code> - the index (exclusive) of the last element in the second array to be tested</dd> <dt>Returns:</dt> <dd>
<code>true</code> if the two arrays, over the specified ranges, are equal</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - if <code>aFromIndex &gt; aToIndex</code> or if <code>bFromIndex &gt; bToIndex</code>
</dd> <dd>
<code><a href="../lang/arrayindexoutofboundsexception">ArrayIndexOutOfBoundsException</a></code> - if <code>aFromIndex &lt; 0 or aToIndex &gt; a.length</code> or if <code>bFromIndex &lt; 0 or bToIndex &gt; b.length</code>
</dd> <dd>
<code><a href="../lang/nullpointerexception">NullPointerException</a></code> - if either array is <code>null</code>
</dd> <dt>Since:</dt> <dd>9</dd> </dl>    <h3 id="equals(int[],int[])">equals</h3> <pre data-language="java">public static boolean equals(int[] a,
                             int[] a2)</pre> <p>Returns <code>true</code> if the two specified arrays of ints are <i>equal</i> to one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are <code>null</code>.</p> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - one array to be tested for equality</dd> <dd>
<code>a2</code> - the other array to be tested for equality</dd> <dt>Returns:</dt> <dd>
<code>true</code> if the two arrays are equal</dd> </dl>    <h3 id="equals(int[],int,int,int[],int,int)">equals</h3> <pre data-language="java">public static boolean equals(int[] a,
                             int aFromIndex,
                             int aToIndex,
                             int[] b,
                             int bFromIndex,
                             int bToIndex)</pre> <div>
<p>Returns true if the two specified arrays of ints, over the specified ranges, are <i>equal</i> to one another. </p>
<p>Two arrays are considered equal if the number of elements covered by each range is the same, and all corresponding pairs of elements over the specified ranges in the two arrays are equal. In other words, two arrays are equal if they contain, over the specified ranges, the same elements in the same order.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the first array to be tested for equality</dd> <dd>
<code>aFromIndex</code> - the index (inclusive) of the first element in the first array to be tested</dd> <dd>
<code>aToIndex</code> - the index (exclusive) of the last element in the first array to be tested</dd> <dd>
<code>b</code> - the second array to be tested fro equality</dd> <dd>
<code>bFromIndex</code> - the index (inclusive) of the first element in the second array to be tested</dd> <dd>
<code>bToIndex</code> - the index (exclusive) of the last element in the second array to be tested</dd> <dt>Returns:</dt> <dd>
<code>true</code> if the two arrays, over the specified ranges, are equal</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - if <code>aFromIndex &gt; aToIndex</code> or if <code>bFromIndex &gt; bToIndex</code>
</dd> <dd>
<code><a href="../lang/arrayindexoutofboundsexception">ArrayIndexOutOfBoundsException</a></code> - if <code>aFromIndex &lt; 0 or aToIndex &gt; a.length</code> or if <code>bFromIndex &lt; 0 or bToIndex &gt; b.length</code>
</dd> <dd>
<code><a href="../lang/nullpointerexception">NullPointerException</a></code> - if either array is <code>null</code>
</dd> <dt>Since:</dt> <dd>9</dd> </dl>    <h3 id="equals(short[],short[])">equals</h3> <pre data-language="java">public static boolean equals(short[] a,
                             short[] a2)</pre> <p>Returns <code>true</code> if the two specified arrays of shorts are <i>equal</i> to one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are <code>null</code>.</p> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - one array to be tested for equality</dd> <dd>
<code>a2</code> - the other array to be tested for equality</dd> <dt>Returns:</dt> <dd>
<code>true</code> if the two arrays are equal</dd> </dl>    <h3 id="equals(short[],int,int,short[],int,int)">equals</h3> <pre data-language="java">public static boolean equals(short[] a,
                             int aFromIndex,
                             int aToIndex,
                             short[] b,
                             int bFromIndex,
                             int bToIndex)</pre> <div>
<p>Returns true if the two specified arrays of shorts, over the specified ranges, are <i>equal</i> to one another. </p>
<p>Two arrays are considered equal if the number of elements covered by each range is the same, and all corresponding pairs of elements over the specified ranges in the two arrays are equal. In other words, two arrays are equal if they contain, over the specified ranges, the same elements in the same order.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the first array to be tested for equality</dd> <dd>
<code>aFromIndex</code> - the index (inclusive) of the first element in the first array to be tested</dd> <dd>
<code>aToIndex</code> - the index (exclusive) of the last element in the first array to be tested</dd> <dd>
<code>b</code> - the second array to be tested fro equality</dd> <dd>
<code>bFromIndex</code> - the index (inclusive) of the first element in the second array to be tested</dd> <dd>
<code>bToIndex</code> - the index (exclusive) of the last element in the second array to be tested</dd> <dt>Returns:</dt> <dd>
<code>true</code> if the two arrays, over the specified ranges, are equal</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - if <code>aFromIndex &gt; aToIndex</code> or if <code>bFromIndex &gt; bToIndex</code>
</dd> <dd>
<code><a href="../lang/arrayindexoutofboundsexception">ArrayIndexOutOfBoundsException</a></code> - if <code>aFromIndex &lt; 0 or aToIndex &gt; a.length</code> or if <code>bFromIndex &lt; 0 or bToIndex &gt; b.length</code>
</dd> <dd>
<code><a href="../lang/nullpointerexception">NullPointerException</a></code> - if either array is <code>null</code>
</dd> <dt>Since:</dt> <dd>9</dd> </dl>    <h3 id="equals(char[],char[])">equals</h3> <pre data-language="java">public static boolean equals(char[] a,
                             char[] a2)</pre> <p>Returns <code>true</code> if the two specified arrays of chars are <i>equal</i> to one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are <code>null</code>.</p> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - one array to be tested for equality</dd> <dd>
<code>a2</code> - the other array to be tested for equality</dd> <dt>Returns:</dt> <dd>
<code>true</code> if the two arrays are equal</dd> </dl>    <h3 id="equals(char[],int,int,char[],int,int)">equals</h3> <pre data-language="java">public static boolean equals(char[] a,
                             int aFromIndex,
                             int aToIndex,
                             char[] b,
                             int bFromIndex,
                             int bToIndex)</pre> <div>
<p>Returns true if the two specified arrays of chars, over the specified ranges, are <i>equal</i> to one another. </p>
<p>Two arrays are considered equal if the number of elements covered by each range is the same, and all corresponding pairs of elements over the specified ranges in the two arrays are equal. In other words, two arrays are equal if they contain, over the specified ranges, the same elements in the same order.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the first array to be tested for equality</dd> <dd>
<code>aFromIndex</code> - the index (inclusive) of the first element in the first array to be tested</dd> <dd>
<code>aToIndex</code> - the index (exclusive) of the last element in the first array to be tested</dd> <dd>
<code>b</code> - the second array to be tested fro equality</dd> <dd>
<code>bFromIndex</code> - the index (inclusive) of the first element in the second array to be tested</dd> <dd>
<code>bToIndex</code> - the index (exclusive) of the last element in the second array to be tested</dd> <dt>Returns:</dt> <dd>
<code>true</code> if the two arrays, over the specified ranges, are equal</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - if <code>aFromIndex &gt; aToIndex</code> or if <code>bFromIndex &gt; bToIndex</code>
</dd> <dd>
<code><a href="../lang/arrayindexoutofboundsexception">ArrayIndexOutOfBoundsException</a></code> - if <code>aFromIndex &lt; 0 or aToIndex &gt; a.length</code> or if <code>bFromIndex &lt; 0 or bToIndex &gt; b.length</code>
</dd> <dd>
<code><a href="../lang/nullpointerexception">NullPointerException</a></code> - if either array is <code>null</code>
</dd> <dt>Since:</dt> <dd>9</dd> </dl>    <h3 id="equals(byte[],byte[])">equals</h3> <pre data-language="java">public static boolean equals(byte[] a,
                             byte[] a2)</pre> <p>Returns <code>true</code> if the two specified arrays of bytes are <i>equal</i> to one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are <code>null</code>.</p> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - one array to be tested for equality</dd> <dd>
<code>a2</code> - the other array to be tested for equality</dd> <dt>Returns:</dt> <dd>
<code>true</code> if the two arrays are equal</dd> </dl>    <h3 id="equals(byte[],int,int,byte[],int,int)">equals</h3> <pre data-language="java">public static boolean equals(byte[] a,
                             int aFromIndex,
                             int aToIndex,
                             byte[] b,
                             int bFromIndex,
                             int bToIndex)</pre> <div>
<p>Returns true if the two specified arrays of bytes, over the specified ranges, are <i>equal</i> to one another. </p>
<p>Two arrays are considered equal if the number of elements covered by each range is the same, and all corresponding pairs of elements over the specified ranges in the two arrays are equal. In other words, two arrays are equal if they contain, over the specified ranges, the same elements in the same order.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the first array to be tested for equality</dd> <dd>
<code>aFromIndex</code> - the index (inclusive) of the first element in the first array to be tested</dd> <dd>
<code>aToIndex</code> - the index (exclusive) of the last element in the first array to be tested</dd> <dd>
<code>b</code> - the second array to be tested fro equality</dd> <dd>
<code>bFromIndex</code> - the index (inclusive) of the first element in the second array to be tested</dd> <dd>
<code>bToIndex</code> - the index (exclusive) of the last element in the second array to be tested</dd> <dt>Returns:</dt> <dd>
<code>true</code> if the two arrays, over the specified ranges, are equal</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - if <code>aFromIndex &gt; aToIndex</code> or if <code>bFromIndex &gt; bToIndex</code>
</dd> <dd>
<code><a href="../lang/arrayindexoutofboundsexception">ArrayIndexOutOfBoundsException</a></code> - if <code>aFromIndex &lt; 0 or aToIndex &gt; a.length</code> or if <code>bFromIndex &lt; 0 or bToIndex &gt; b.length</code>
</dd> <dd>
<code><a href="../lang/nullpointerexception">NullPointerException</a></code> - if either array is <code>null</code>
</dd> <dt>Since:</dt> <dd>9</dd> </dl>    <h3 id="equals(boolean[],boolean[])">equals</h3> <pre data-language="java">public static boolean equals(boolean[] a,
                             boolean[] a2)</pre> <p>Returns <code>true</code> if the two specified arrays of booleans are <i>equal</i> to one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are <code>null</code>.</p> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - one array to be tested for equality</dd> <dd>
<code>a2</code> - the other array to be tested for equality</dd> <dt>Returns:</dt> <dd>
<code>true</code> if the two arrays are equal</dd> </dl>    <h3 id="equals(boolean[],int,int,boolean[],int,int)">equals</h3> <pre data-language="java">public static boolean equals(boolean[] a,
                             int aFromIndex,
                             int aToIndex,
                             boolean[] b,
                             int bFromIndex,
                             int bToIndex)</pre> <div>
<p>Returns true if the two specified arrays of booleans, over the specified ranges, are <i>equal</i> to one another. </p>
<p>Two arrays are considered equal if the number of elements covered by each range is the same, and all corresponding pairs of elements over the specified ranges in the two arrays are equal. In other words, two arrays are equal if they contain, over the specified ranges, the same elements in the same order.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the first array to be tested for equality</dd> <dd>
<code>aFromIndex</code> - the index (inclusive) of the first element in the first array to be tested</dd> <dd>
<code>aToIndex</code> - the index (exclusive) of the last element in the first array to be tested</dd> <dd>
<code>b</code> - the second array to be tested fro equality</dd> <dd>
<code>bFromIndex</code> - the index (inclusive) of the first element in the second array to be tested</dd> <dd>
<code>bToIndex</code> - the index (exclusive) of the last element in the second array to be tested</dd> <dt>Returns:</dt> <dd>
<code>true</code> if the two arrays, over the specified ranges, are equal</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - if <code>aFromIndex &gt; aToIndex</code> or if <code>bFromIndex &gt; bToIndex</code>
</dd> <dd>
<code><a href="../lang/arrayindexoutofboundsexception">ArrayIndexOutOfBoundsException</a></code> - if <code>aFromIndex &lt; 0 or aToIndex &gt; a.length</code> or if <code>bFromIndex &lt; 0 or bToIndex &gt; b.length</code>
</dd> <dd>
<code><a href="../lang/nullpointerexception">NullPointerException</a></code> - if either array is <code>null</code>
</dd> <dt>Since:</dt> <dd>9</dd> </dl>    <h3 id="equals(double[],double[])">equals</h3> <pre data-language="java">public static boolean equals(double[] a,
                             double[] a2)</pre> <p>Returns <code>true</code> if the two specified arrays of doubles are <i>equal</i> to one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are <code>null</code>. Two doubles <code>d1</code> and <code>d2</code> are considered equal if: <pre data-language="java">new Double(d1).equals(new Double(d2))</pre> (Unlike the <code>==</code> operator, this method considers <code>NaN</code> equals to itself, and 0.0d unequal to -0.0d.)</p> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - one array to be tested for equality</dd> <dd>
<code>a2</code> - the other array to be tested for equality</dd> <dt>Returns:</dt> <dd>
<code>true</code> if the two arrays are equal</dd> <dt>See Also:</dt> <dd><a href="../lang/double#equals(java.lang.Object)"><code>Double.equals(Object)</code></a></dd> </dl>    <h3 id="equals(double[],int,int,double[],int,int)">equals</h3> <pre data-language="java">public static boolean equals(double[] a,
                             int aFromIndex,
                             int aToIndex,
                             double[] b,
                             int bFromIndex,
                             int bToIndex)</pre> <div>
<p>Returns true if the two specified arrays of doubles, over the specified ranges, are <i>equal</i> to one another. </p>
<p>Two arrays are considered equal if the number of elements covered by each range is the same, and all corresponding pairs of elements over the specified ranges in the two arrays are equal. In other words, two arrays are equal if they contain, over the specified ranges, the same elements in the same order. </p>
<p>Two doubles <code>d1</code> and <code>d2</code> are considered equal if: </p>
<pre data-language="java">new Double(d1).equals(new Double(d2))</pre> (Unlike the <code>==</code> operator, this method considers <code>NaN</code> equals to itself, and 0.0d unequal to -0.0d.)</div> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the first array to be tested for equality</dd> <dd>
<code>aFromIndex</code> - the index (inclusive) of the first element in the first array to be tested</dd> <dd>
<code>aToIndex</code> - the index (exclusive) of the last element in the first array to be tested</dd> <dd>
<code>b</code> - the second array to be tested fro equality</dd> <dd>
<code>bFromIndex</code> - the index (inclusive) of the first element in the second array to be tested</dd> <dd>
<code>bToIndex</code> - the index (exclusive) of the last element in the second array to be tested</dd> <dt>Returns:</dt> <dd>
<code>true</code> if the two arrays, over the specified ranges, are equal</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - if <code>aFromIndex &gt; aToIndex</code> or if <code>bFromIndex &gt; bToIndex</code>
</dd> <dd>
<code><a href="../lang/arrayindexoutofboundsexception">ArrayIndexOutOfBoundsException</a></code> - if <code>aFromIndex &lt; 0 or aToIndex &gt; a.length</code> or if <code>bFromIndex &lt; 0 or bToIndex &gt; b.length</code>
</dd> <dd>
<code><a href="../lang/nullpointerexception">NullPointerException</a></code> - if either array is <code>null</code>
</dd> <dt>Since:</dt> <dd>9</dd> <dt>See Also:</dt> <dd><a href="../lang/double#equals(java.lang.Object)"><code>Double.equals(Object)</code></a></dd> </dl>    <h3 id="equals(float[],float[])">equals</h3> <pre data-language="java">public static boolean equals(float[] a,
                             float[] a2)</pre> <p>Returns <code>true</code> if the two specified arrays of floats are <i>equal</i> to one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are <code>null</code>. Two floats <code>f1</code> and <code>f2</code> are considered equal if: <pre data-language="java">new Float(f1).equals(new Float(f2))</pre> (Unlike the <code>==</code> operator, this method considers <code>NaN</code> equals to itself, and 0.0f unequal to -0.0f.)</p> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - one array to be tested for equality</dd> <dd>
<code>a2</code> - the other array to be tested for equality</dd> <dt>Returns:</dt> <dd>
<code>true</code> if the two arrays are equal</dd> <dt>See Also:</dt> <dd><a href="../lang/float#equals(java.lang.Object)"><code>Float.equals(Object)</code></a></dd> </dl>    <h3 id="equals(float[],int,int,float[],int,int)">equals</h3> <pre data-language="java">public static boolean equals(float[] a,
                             int aFromIndex,
                             int aToIndex,
                             float[] b,
                             int bFromIndex,
                             int bToIndex)</pre> <div>
<p>Returns true if the two specified arrays of floats, over the specified ranges, are <i>equal</i> to one another. </p>
<p>Two arrays are considered equal if the number of elements covered by each range is the same, and all corresponding pairs of elements over the specified ranges in the two arrays are equal. In other words, two arrays are equal if they contain, over the specified ranges, the same elements in the same order. </p>
<p>Two floats <code>f1</code> and <code>f2</code> are considered equal if: </p>
<pre data-language="java">new Float(f1).equals(new Float(f2))</pre> (Unlike the <code>==</code> operator, this method considers <code>NaN</code> equals to itself, and 0.0f unequal to -0.0f.)</div> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the first array to be tested for equality</dd> <dd>
<code>aFromIndex</code> - the index (inclusive) of the first element in the first array to be tested</dd> <dd>
<code>aToIndex</code> - the index (exclusive) of the last element in the first array to be tested</dd> <dd>
<code>b</code> - the second array to be tested fro equality</dd> <dd>
<code>bFromIndex</code> - the index (inclusive) of the first element in the second array to be tested</dd> <dd>
<code>bToIndex</code> - the index (exclusive) of the last element in the second array to be tested</dd> <dt>Returns:</dt> <dd>
<code>true</code> if the two arrays, over the specified ranges, are equal</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - if <code>aFromIndex &gt; aToIndex</code> or if <code>bFromIndex &gt; bToIndex</code>
</dd> <dd>
<code><a href="../lang/arrayindexoutofboundsexception">ArrayIndexOutOfBoundsException</a></code> - if <code>aFromIndex &lt; 0 or aToIndex &gt; a.length</code> or if <code>bFromIndex &lt; 0 or bToIndex &gt; b.length</code>
</dd> <dd>
<code><a href="../lang/nullpointerexception">NullPointerException</a></code> - if either array is <code>null</code>
</dd> <dt>Since:</dt> <dd>9</dd> <dt>See Also:</dt> <dd><a href="../lang/float#equals(java.lang.Object)"><code>Float.equals(Object)</code></a></dd> </dl>    <h3 id="equals(java.lang.Object[],java.lang.Object[])">equals</h3> <pre data-language="java">public static boolean equals(Object[] a,
                             Object[] a2)</pre> <p>Returns <code>true</code> if the two specified arrays of Objects are <i>equal</i> to one another. The two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. Two objects <code>e1</code> and <code>e2</code> are considered <i>equal</i> if <code>Objects.equals(e1, e2)</code>. In other words, the two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are <code>null</code>.</p> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - one array to be tested for equality</dd> <dd>
<code>a2</code> - the other array to be tested for equality</dd> <dt>Returns:</dt> <dd>
<code>true</code> if the two arrays are equal</dd> </dl>    <h3 id="equals(java.lang.Object[],int,int,java.lang.Object[],int,int)">equals</h3> <pre data-language="java">public static boolean equals(Object[] a,
                             int aFromIndex,
                             int aToIndex,
                             Object[] b,
                             int bFromIndex,
                             int bToIndex)</pre> <div>
<p>Returns true if the two specified arrays of Objects, over the specified ranges, are <i>equal</i> to one another. </p>
<p>Two arrays are considered equal if the number of elements covered by each range is the same, and all corresponding pairs of elements over the specified ranges in the two arrays are equal. In other words, two arrays are equal if they contain, over the specified ranges, the same elements in the same order. </p>
<p>Two objects <code>e1</code> and <code>e2</code> are considered <i>equal</i> if <code>Objects.equals(e1, e2)</code>.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the first array to be tested for equality</dd> <dd>
<code>aFromIndex</code> - the index (inclusive) of the first element in the first array to be tested</dd> <dd>
<code>aToIndex</code> - the index (exclusive) of the last element in the first array to be tested</dd> <dd>
<code>b</code> - the second array to be tested fro equality</dd> <dd>
<code>bFromIndex</code> - the index (inclusive) of the first element in the second array to be tested</dd> <dd>
<code>bToIndex</code> - the index (exclusive) of the last element in the second array to be tested</dd> <dt>Returns:</dt> <dd>
<code>true</code> if the two arrays, over the specified ranges, are equal</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - if <code>aFromIndex &gt; aToIndex</code> or if <code>bFromIndex &gt; bToIndex</code>
</dd> <dd>
<code><a href="../lang/arrayindexoutofboundsexception">ArrayIndexOutOfBoundsException</a></code> - if <code>aFromIndex &lt; 0 or aToIndex &gt; a.length</code> or if <code>bFromIndex &lt; 0 or bToIndex &gt; b.length</code>
</dd> <dd>
<code><a href="../lang/nullpointerexception">NullPointerException</a></code> - if either array is <code>null</code>
</dd> <dt>Since:</dt> <dd>9</dd> </dl>    <h3 id="equals(java.lang.Object[],java.lang.Object[],java.util.Comparator)">equals</h3> <pre data-language="java">public static &lt;T&gt; boolean equals(T[] a,
                                 T[] a2,
                                 Comparator&lt;? super T&gt; cmp)</pre> <div>
<p>Returns <code>true</code> if the two specified arrays of Objects are <i>equal</i> to one another. </p>
<p>Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, the two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are <code>null</code>. </p>
<p>Two objects <code>e1</code> and <code>e2</code> are considered <i>equal</i> if, given the specified comparator, <code>cmp.compare(e1, e2) == 0</code>.</p>
</div> <dl> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the type of array elements</dd> <dt>Parameters:</dt> <dd>
<code>a</code> - one array to be tested for equality</dd> <dd>
<code>a2</code> - the other array to be tested for equality</dd> <dd>
<code>cmp</code> - the comparator to compare array elements</dd> <dt>Returns:</dt> <dd>
<code>true</code> if the two arrays are equal</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/nullpointerexception">NullPointerException</a></code> - if the comparator is <code>null</code>
</dd> <dt>Since:</dt> <dd>9</dd> </dl>    <h3 id="equals(java.lang.Object[],int,int,java.lang.Object[],int,int,java.util.Comparator)">equals</h3> <pre data-language="java">public static &lt;T&gt; boolean equals(T[] a,
                                 int aFromIndex,
                                 int aToIndex,
                                 T[] b,
                                 int bFromIndex,
                                 int bToIndex,
                                 Comparator&lt;? super T&gt; cmp)</pre> <div>
<p>Returns true if the two specified arrays of Objects, over the specified ranges, are <i>equal</i> to one another. </p>
<p>Two arrays are considered equal if the number of elements covered by each range is the same, and all corresponding pairs of elements over the specified ranges in the two arrays are equal. In other words, two arrays are equal if they contain, over the specified ranges, the same elements in the same order. </p>
<p>Two objects <code>e1</code> and <code>e2</code> are considered <i>equal</i> if, given the specified comparator, <code>cmp.compare(e1, e2) == 0</code>.</p>
</div> <dl> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the type of array elements</dd> <dt>Parameters:</dt> <dd>
<code>a</code> - the first array to be tested for equality</dd> <dd>
<code>aFromIndex</code> - the index (inclusive) of the first element in the first array to be tested</dd> <dd>
<code>aToIndex</code> - the index (exclusive) of the last element in the first array to be tested</dd> <dd>
<code>b</code> - the second array to be tested fro equality</dd> <dd>
<code>bFromIndex</code> - the index (inclusive) of the first element in the second array to be tested</dd> <dd>
<code>bToIndex</code> - the index (exclusive) of the last element in the second array to be tested</dd> <dd>
<code>cmp</code> - the comparator to compare array elements</dd> <dt>Returns:</dt> <dd>
<code>true</code> if the two arrays, over the specified ranges, are equal</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - if <code>aFromIndex &gt; aToIndex</code> or if <code>bFromIndex &gt; bToIndex</code>
</dd> <dd>
<code><a href="../lang/arrayindexoutofboundsexception">ArrayIndexOutOfBoundsException</a></code> - if <code>aFromIndex &lt; 0 or aToIndex &gt; a.length</code> or if <code>bFromIndex &lt; 0 or bToIndex &gt; b.length</code>
</dd> <dd>
<code><a href="../lang/nullpointerexception">NullPointerException</a></code> - if either array or the comparator is <code>null</code>
</dd> <dt>Since:</dt> <dd>9</dd> </dl>    <h3 id="fill(long[],long)">fill</h3> <pre data-language="java">public static void fill(long[] a,
                        long val)</pre> <p>Assigns the specified long value to each element of the specified array of longs.</p> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the array to be filled</dd> <dd>
<code>val</code> - the value to be stored in all elements of the array</dd> </dl>    <h3 id="fill(long[],int,int,long)">fill</h3> <pre data-language="java">public static void fill(long[] a,
                        int fromIndex,
                        int toIndex,
                        long val)</pre> <p>Assigns the specified long value to each element of the specified range of the specified array of longs. The range to be filled extends from index <code>fromIndex</code>, inclusive, to index <code>toIndex</code>, exclusive. (If <code>fromIndex==toIndex</code>, the range to be filled is empty.)</p> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the array to be filled</dd> <dd>
<code>fromIndex</code> - the index of the first element (inclusive) to be filled with the specified value</dd> <dd>
<code>toIndex</code> - the index of the last element (exclusive) to be filled with the specified value</dd> <dd>
<code>val</code> - the value to be stored in all elements of the array</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - if <code>fromIndex &gt; toIndex</code>
</dd> <dd>
<code><a href="../lang/arrayindexoutofboundsexception">ArrayIndexOutOfBoundsException</a></code> - if <code>fromIndex &lt; 0</code> or <code>toIndex &gt; a.length</code>
</dd> </dl>    <h3 id="fill(int[],int)">fill</h3> <pre data-language="java">public static void fill(int[] a,
                        int val)</pre> <p>Assigns the specified int value to each element of the specified array of ints.</p> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the array to be filled</dd> <dd>
<code>val</code> - the value to be stored in all elements of the array</dd> </dl>    <h3 id="fill(int[],int,int,int)">fill</h3> <pre data-language="java">public static void fill(int[] a,
                        int fromIndex,
                        int toIndex,
                        int val)</pre> <p>Assigns the specified int value to each element of the specified range of the specified array of ints. The range to be filled extends from index <code>fromIndex</code>, inclusive, to index <code>toIndex</code>, exclusive. (If <code>fromIndex==toIndex</code>, the range to be filled is empty.)</p> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the array to be filled</dd> <dd>
<code>fromIndex</code> - the index of the first element (inclusive) to be filled with the specified value</dd> <dd>
<code>toIndex</code> - the index of the last element (exclusive) to be filled with the specified value</dd> <dd>
<code>val</code> - the value to be stored in all elements of the array</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - if <code>fromIndex &gt; toIndex</code>
</dd> <dd>
<code><a href="../lang/arrayindexoutofboundsexception">ArrayIndexOutOfBoundsException</a></code> - if <code>fromIndex &lt; 0</code> or <code>toIndex &gt; a.length</code>
</dd> </dl>    <h3 id="fill(short[],short)">fill</h3> <pre data-language="java">public static void fill(short[] a,
                        short val)</pre> <p>Assigns the specified short value to each element of the specified array of shorts.</p> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the array to be filled</dd> <dd>
<code>val</code> - the value to be stored in all elements of the array</dd> </dl>    <h3 id="fill(short[],int,int,short)">fill</h3> <pre data-language="java">public static void fill(short[] a,
                        int fromIndex,
                        int toIndex,
                        short val)</pre> <p>Assigns the specified short value to each element of the specified range of the specified array of shorts. The range to be filled extends from index <code>fromIndex</code>, inclusive, to index <code>toIndex</code>, exclusive. (If <code>fromIndex==toIndex</code>, the range to be filled is empty.)</p> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the array to be filled</dd> <dd>
<code>fromIndex</code> - the index of the first element (inclusive) to be filled with the specified value</dd> <dd>
<code>toIndex</code> - the index of the last element (exclusive) to be filled with the specified value</dd> <dd>
<code>val</code> - the value to be stored in all elements of the array</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - if <code>fromIndex &gt; toIndex</code>
</dd> <dd>
<code><a href="../lang/arrayindexoutofboundsexception">ArrayIndexOutOfBoundsException</a></code> - if <code>fromIndex &lt; 0</code> or <code>toIndex &gt; a.length</code>
</dd> </dl>    <h3 id="fill(char[],char)">fill</h3> <pre data-language="java">public static void fill(char[] a,
                        char val)</pre> <p>Assigns the specified char value to each element of the specified array of chars.</p> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the array to be filled</dd> <dd>
<code>val</code> - the value to be stored in all elements of the array</dd> </dl>    <h3 id="fill(char[],int,int,char)">fill</h3> <pre data-language="java">public static void fill(char[] a,
                        int fromIndex,
                        int toIndex,
                        char val)</pre> <p>Assigns the specified char value to each element of the specified range of the specified array of chars. The range to be filled extends from index <code>fromIndex</code>, inclusive, to index <code>toIndex</code>, exclusive. (If <code>fromIndex==toIndex</code>, the range to be filled is empty.)</p> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the array to be filled</dd> <dd>
<code>fromIndex</code> - the index of the first element (inclusive) to be filled with the specified value</dd> <dd>
<code>toIndex</code> - the index of the last element (exclusive) to be filled with the specified value</dd> <dd>
<code>val</code> - the value to be stored in all elements of the array</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - if <code>fromIndex &gt; toIndex</code>
</dd> <dd>
<code><a href="../lang/arrayindexoutofboundsexception">ArrayIndexOutOfBoundsException</a></code> - if <code>fromIndex &lt; 0</code> or <code>toIndex &gt; a.length</code>
</dd> </dl>    <h3 id="fill(byte[],byte)">fill</h3> <pre data-language="java">public static void fill(byte[] a,
                        byte val)</pre> <p>Assigns the specified byte value to each element of the specified array of bytes.</p> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the array to be filled</dd> <dd>
<code>val</code> - the value to be stored in all elements of the array</dd> </dl>    <h3 id="fill(byte[],int,int,byte)">fill</h3> <pre data-language="java">public static void fill(byte[] a,
                        int fromIndex,
                        int toIndex,
                        byte val)</pre> <p>Assigns the specified byte value to each element of the specified range of the specified array of bytes. The range to be filled extends from index <code>fromIndex</code>, inclusive, to index <code>toIndex</code>, exclusive. (If <code>fromIndex==toIndex</code>, the range to be filled is empty.)</p> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the array to be filled</dd> <dd>
<code>fromIndex</code> - the index of the first element (inclusive) to be filled with the specified value</dd> <dd>
<code>toIndex</code> - the index of the last element (exclusive) to be filled with the specified value</dd> <dd>
<code>val</code> - the value to be stored in all elements of the array</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - if <code>fromIndex &gt; toIndex</code>
</dd> <dd>
<code><a href="../lang/arrayindexoutofboundsexception">ArrayIndexOutOfBoundsException</a></code> - if <code>fromIndex &lt; 0</code> or <code>toIndex &gt; a.length</code>
</dd> </dl>    <h3 id="fill(boolean[],boolean)">fill</h3> <pre data-language="java">public static void fill(boolean[] a,
                        boolean val)</pre> <p>Assigns the specified boolean value to each element of the specified array of booleans.</p> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the array to be filled</dd> <dd>
<code>val</code> - the value to be stored in all elements of the array</dd> </dl>    <h3 id="fill(boolean[],int,int,boolean)">fill</h3> <pre data-language="java">public static void fill(boolean[] a,
                        int fromIndex,
                        int toIndex,
                        boolean val)</pre> <p>Assigns the specified boolean value to each element of the specified range of the specified array of booleans. The range to be filled extends from index <code>fromIndex</code>, inclusive, to index <code>toIndex</code>, exclusive. (If <code>fromIndex==toIndex</code>, the range to be filled is empty.)</p> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the array to be filled</dd> <dd>
<code>fromIndex</code> - the index of the first element (inclusive) to be filled with the specified value</dd> <dd>
<code>toIndex</code> - the index of the last element (exclusive) to be filled with the specified value</dd> <dd>
<code>val</code> - the value to be stored in all elements of the array</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - if <code>fromIndex &gt; toIndex</code>
</dd> <dd>
<code><a href="../lang/arrayindexoutofboundsexception">ArrayIndexOutOfBoundsException</a></code> - if <code>fromIndex &lt; 0</code> or <code>toIndex &gt; a.length</code>
</dd> </dl>    <h3 id="fill(double[],double)">fill</h3> <pre data-language="java">public static void fill(double[] a,
                        double val)</pre> <p>Assigns the specified double value to each element of the specified array of doubles.</p> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the array to be filled</dd> <dd>
<code>val</code> - the value to be stored in all elements of the array</dd> </dl>    <h3 id="fill(double[],int,int,double)">fill</h3> <pre data-language="java">public static void fill(double[] a,
                        int fromIndex,
                        int toIndex,
                        double val)</pre> <p>Assigns the specified double value to each element of the specified range of the specified array of doubles. The range to be filled extends from index <code>fromIndex</code>, inclusive, to index <code>toIndex</code>, exclusive. (If <code>fromIndex==toIndex</code>, the range to be filled is empty.)</p> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the array to be filled</dd> <dd>
<code>fromIndex</code> - the index of the first element (inclusive) to be filled with the specified value</dd> <dd>
<code>toIndex</code> - the index of the last element (exclusive) to be filled with the specified value</dd> <dd>
<code>val</code> - the value to be stored in all elements of the array</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - if <code>fromIndex &gt; toIndex</code>
</dd> <dd>
<code><a href="../lang/arrayindexoutofboundsexception">ArrayIndexOutOfBoundsException</a></code> - if <code>fromIndex &lt; 0</code> or <code>toIndex &gt; a.length</code>
</dd> </dl>    <h3 id="fill(float[],float)">fill</h3> <pre data-language="java">public static void fill(float[] a,
                        float val)</pre> <p>Assigns the specified float value to each element of the specified array of floats.</p> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the array to be filled</dd> <dd>
<code>val</code> - the value to be stored in all elements of the array</dd> </dl>    <h3 id="fill(float[],int,int,float)">fill</h3> <pre data-language="java">public static void fill(float[] a,
                        int fromIndex,
                        int toIndex,
                        float val)</pre> <p>Assigns the specified float value to each element of the specified range of the specified array of floats. The range to be filled extends from index <code>fromIndex</code>, inclusive, to index <code>toIndex</code>, exclusive. (If <code>fromIndex==toIndex</code>, the range to be filled is empty.)</p> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the array to be filled</dd> <dd>
<code>fromIndex</code> - the index of the first element (inclusive) to be filled with the specified value</dd> <dd>
<code>toIndex</code> - the index of the last element (exclusive) to be filled with the specified value</dd> <dd>
<code>val</code> - the value to be stored in all elements of the array</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - if <code>fromIndex &gt; toIndex</code>
</dd> <dd>
<code><a href="../lang/arrayindexoutofboundsexception">ArrayIndexOutOfBoundsException</a></code> - if <code>fromIndex &lt; 0</code> or <code>toIndex &gt; a.length</code>
</dd> </dl>    <h3 id="fill(java.lang.Object[],java.lang.Object)">fill</h3> <pre data-language="java">public static void fill(Object[] a,
                        Object val)</pre> <p>Assigns the specified Object reference to each element of the specified array of Objects.</p> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the array to be filled</dd> <dd>
<code>val</code> - the value to be stored in all elements of the array</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/arraystoreexception">ArrayStoreException</a></code> - if the specified value is not of a runtime type that can be stored in the specified array</dd> </dl>    <h3 id="fill(java.lang.Object[],int,int,java.lang.Object)">fill</h3> <pre data-language="java">public static void fill(Object[] a,
                        int fromIndex,
                        int toIndex,
                        Object val)</pre> <p>Assigns the specified Object reference to each element of the specified range of the specified array of Objects. The range to be filled extends from index <code>fromIndex</code>, inclusive, to index <code>toIndex</code>, exclusive. (If <code>fromIndex==toIndex</code>, the range to be filled is empty.)</p> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the array to be filled</dd> <dd>
<code>fromIndex</code> - the index of the first element (inclusive) to be filled with the specified value</dd> <dd>
<code>toIndex</code> - the index of the last element (exclusive) to be filled with the specified value</dd> <dd>
<code>val</code> - the value to be stored in all elements of the array</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - if <code>fromIndex &gt; toIndex</code>
</dd> <dd>
<code><a href="../lang/arrayindexoutofboundsexception">ArrayIndexOutOfBoundsException</a></code> - if <code>fromIndex &lt; 0</code> or <code>toIndex &gt; a.length</code>
</dd> <dd>
<code><a href="../lang/arraystoreexception">ArrayStoreException</a></code> - if the specified value is not of a runtime type that can be stored in the specified array</dd> </dl>    <h3 id="copyOf(java.lang.Object[],int)">copyOf</h3> <pre data-language="java">public static &lt;T&gt; T[] copyOf(T[] original,
                             int newLength)</pre> <p>Copies the specified array, truncating or padding with nulls (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain <code>null</code>. Such indices will exist if and only if the specified length is greater than that of the original array. The resulting array is of exactly the same class as the original array.</p> <dl> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the class of the objects in the array</dd> <dt>Parameters:</dt> <dd>
<code>original</code> - the array to be copied</dd> <dd>
<code>newLength</code> - the length of the copy to be returned</dd> <dt>Returns:</dt> <dd>a copy of the original array, truncated or padded with nulls to obtain the specified length</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/negativearraysizeexception">NegativeArraySizeException</a></code> - if <code>newLength</code> is negative</dd> <dd>
<code><a href="../lang/nullpointerexception">NullPointerException</a></code> - if <code>original</code> is null</dd> <dt>Since:</dt> <dd>1.6</dd> </dl>    <h3 id="copyOf(java.lang.Object[],int,java.lang.Class)">copyOf</h3> <pre data-language="java">public static &lt;T,U&gt; T[] copyOf​(U[] original,
                                     int newLength,
                                     Class&lt;? extends T[]&gt; newType)</pre> <p>Copies the specified array, truncating or padding with nulls (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain <code>null</code>. Such indices will exist if and only if the specified length is greater than that of the original array. The resulting array is of the class <code>newType</code>.</p> <dl> <dt>Type Parameters:</dt> <dd>
<code>U</code> - the class of the objects in the original array</dd> <dd>
<code>T</code> - the class of the objects in the returned array</dd> <dt>Parameters:</dt> <dd>
<code>original</code> - the array to be copied</dd> <dd>
<code>newLength</code> - the length of the copy to be returned</dd> <dd>
<code>newType</code> - the class of the copy to be returned</dd> <dt>Returns:</dt> <dd>a copy of the original array, truncated or padded with nulls to obtain the specified length</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/negativearraysizeexception">NegativeArraySizeException</a></code> - if <code>newLength</code> is negative</dd> <dd>
<code><a href="../lang/nullpointerexception">NullPointerException</a></code> - if <code>original</code> is null</dd> <dd>
<code><a href="../lang/arraystoreexception">ArrayStoreException</a></code> - if an element copied from <code>original</code> is not of a runtime type that can be stored in an array of class <code>newType</code>
</dd> <dt>Since:</dt> <dd>1.6</dd> </dl>    <h3 id="copyOf(byte[],int)">copyOf</h3> <pre data-language="java">public static byte[] copyOf(byte[] original,
                            int newLength)</pre> <p>Copies the specified array, truncating or padding with zeros (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain <code>(byte)0</code>. Such indices will exist if and only if the specified length is greater than that of the original array.</p> <dl> <dt>Parameters:</dt> <dd>
<code>original</code> - the array to be copied</dd> <dd>
<code>newLength</code> - the length of the copy to be returned</dd> <dt>Returns:</dt> <dd>a copy of the original array, truncated or padded with zeros to obtain the specified length</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/negativearraysizeexception">NegativeArraySizeException</a></code> - if <code>newLength</code> is negative</dd> <dd>
<code><a href="../lang/nullpointerexception">NullPointerException</a></code> - if <code>original</code> is null</dd> <dt>Since:</dt> <dd>1.6</dd> </dl>    <h3 id="copyOf(short[],int)">copyOf</h3> <pre data-language="java">public static short[] copyOf(short[] original,
                             int newLength)</pre> <p>Copies the specified array, truncating or padding with zeros (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain <code>(short)0</code>. Such indices will exist if and only if the specified length is greater than that of the original array.</p> <dl> <dt>Parameters:</dt> <dd>
<code>original</code> - the array to be copied</dd> <dd>
<code>newLength</code> - the length of the copy to be returned</dd> <dt>Returns:</dt> <dd>a copy of the original array, truncated or padded with zeros to obtain the specified length</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/negativearraysizeexception">NegativeArraySizeException</a></code> - if <code>newLength</code> is negative</dd> <dd>
<code><a href="../lang/nullpointerexception">NullPointerException</a></code> - if <code>original</code> is null</dd> <dt>Since:</dt> <dd>1.6</dd> </dl>    <h3 id="copyOf(int[],int)">copyOf</h3> <pre data-language="java">public static int[] copyOf(int[] original,
                           int newLength)</pre> <p>Copies the specified array, truncating or padding with zeros (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain <code>0</code>. Such indices will exist if and only if the specified length is greater than that of the original array.</p> <dl> <dt>Parameters:</dt> <dd>
<code>original</code> - the array to be copied</dd> <dd>
<code>newLength</code> - the length of the copy to be returned</dd> <dt>Returns:</dt> <dd>a copy of the original array, truncated or padded with zeros to obtain the specified length</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/negativearraysizeexception">NegativeArraySizeException</a></code> - if <code>newLength</code> is negative</dd> <dd>
<code><a href="../lang/nullpointerexception">NullPointerException</a></code> - if <code>original</code> is null</dd> <dt>Since:</dt> <dd>1.6</dd> </dl>    <h3 id="copyOf(long[],int)">copyOf</h3> <pre data-language="java">public static long[] copyOf(long[] original,
                            int newLength)</pre> <p>Copies the specified array, truncating or padding with zeros (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain <code>0L</code>. Such indices will exist if and only if the specified length is greater than that of the original array.</p> <dl> <dt>Parameters:</dt> <dd>
<code>original</code> - the array to be copied</dd> <dd>
<code>newLength</code> - the length of the copy to be returned</dd> <dt>Returns:</dt> <dd>a copy of the original array, truncated or padded with zeros to obtain the specified length</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/negativearraysizeexception">NegativeArraySizeException</a></code> - if <code>newLength</code> is negative</dd> <dd>
<code><a href="../lang/nullpointerexception">NullPointerException</a></code> - if <code>original</code> is null</dd> <dt>Since:</dt> <dd>1.6</dd> </dl>    <h3 id="copyOf(char[],int)">copyOf</h3> <pre data-language="java">public static char[] copyOf(char[] original,
                            int newLength)</pre> <p>Copies the specified array, truncating or padding with null characters (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain <code>'\\u000'</code>. Such indices will exist if and only if the specified length is greater than that of the original array.</p> <dl> <dt>Parameters:</dt> <dd>
<code>original</code> - the array to be copied</dd> <dd>
<code>newLength</code> - the length of the copy to be returned</dd> <dt>Returns:</dt> <dd>a copy of the original array, truncated or padded with null characters to obtain the specified length</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/negativearraysizeexception">NegativeArraySizeException</a></code> - if <code>newLength</code> is negative</dd> <dd>
<code><a href="../lang/nullpointerexception">NullPointerException</a></code> - if <code>original</code> is null</dd> <dt>Since:</dt> <dd>1.6</dd> </dl>    <h3 id="copyOf(float[],int)">copyOf</h3> <pre data-language="java">public static float[] copyOf(float[] original,
                             int newLength)</pre> <p>Copies the specified array, truncating or padding with zeros (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain <code>0f</code>. Such indices will exist if and only if the specified length is greater than that of the original array.</p> <dl> <dt>Parameters:</dt> <dd>
<code>original</code> - the array to be copied</dd> <dd>
<code>newLength</code> - the length of the copy to be returned</dd> <dt>Returns:</dt> <dd>a copy of the original array, truncated or padded with zeros to obtain the specified length</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/negativearraysizeexception">NegativeArraySizeException</a></code> - if <code>newLength</code> is negative</dd> <dd>
<code><a href="../lang/nullpointerexception">NullPointerException</a></code> - if <code>original</code> is null</dd> <dt>Since:</dt> <dd>1.6</dd> </dl>    <h3 id="copyOf(double[],int)">copyOf</h3> <pre data-language="java">public static double[] copyOf(double[] original,
                              int newLength)</pre> <p>Copies the specified array, truncating or padding with zeros (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain <code>0d</code>. Such indices will exist if and only if the specified length is greater than that of the original array.</p> <dl> <dt>Parameters:</dt> <dd>
<code>original</code> - the array to be copied</dd> <dd>
<code>newLength</code> - the length of the copy to be returned</dd> <dt>Returns:</dt> <dd>a copy of the original array, truncated or padded with zeros to obtain the specified length</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/negativearraysizeexception">NegativeArraySizeException</a></code> - if <code>newLength</code> is negative</dd> <dd>
<code><a href="../lang/nullpointerexception">NullPointerException</a></code> - if <code>original</code> is null</dd> <dt>Since:</dt> <dd>1.6</dd> </dl>    <h3 id="copyOf(boolean[],int)">copyOf</h3> <pre data-language="java">public static boolean[] copyOf(boolean[] original,
                               int newLength)</pre> <p>Copies the specified array, truncating or padding with <code>false</code> (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain <code>false</code>. Such indices will exist if and only if the specified length is greater than that of the original array.</p> <dl> <dt>Parameters:</dt> <dd>
<code>original</code> - the array to be copied</dd> <dd>
<code>newLength</code> - the length of the copy to be returned</dd> <dt>Returns:</dt> <dd>a copy of the original array, truncated or padded with false elements to obtain the specified length</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/negativearraysizeexception">NegativeArraySizeException</a></code> - if <code>newLength</code> is negative</dd> <dd>
<code><a href="../lang/nullpointerexception">NullPointerException</a></code> - if <code>original</code> is null</dd> <dt>Since:</dt> <dd>1.6</dd> </dl>    <h3 id="copyOfRange(java.lang.Object[],int,int)">copyOfRange</h3> <pre data-language="java">public static &lt;T&gt; T[] copyOfRange(T[] original,
                                  int from,
                                  int to)</pre> <div>
<p>Copies the specified range of the specified array into a new array. The initial index of the range (<code>from</code>) must lie between zero and <code>original.length</code>, inclusive. The value at <code>original[from]</code> is placed into the initial element of the copy (unless <code>from == original.length</code> or <code>from == to</code>). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range (<code>to</code>), which must be greater than or equal to <code>from</code>, may be greater than <code>original.length</code>, in which case <code>null</code> is placed in all elements of the copy whose index is greater than or equal to <code>original.length - from</code>. The length of the returned array will be <code>to - from</code>. </p>
<p> The resulting array is of exactly the same class as the original array.</p>
</div> <dl> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the class of the objects in the array</dd> <dt>Parameters:</dt> <dd>
<code>original</code> - the array from which a range is to be copied</dd> <dd>
<code>from</code> - the initial index of the range to be copied, inclusive</dd> <dd>
<code>to</code> - the final index of the range to be copied, exclusive. (This index may lie outside the array.)</dd> <dt>Returns:</dt> <dd>a new array containing the specified range from the original array, truncated or padded with nulls to obtain the required length</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/arrayindexoutofboundsexception">ArrayIndexOutOfBoundsException</a></code> - if <code>from &lt; 0</code> or <code>from &gt; original.length</code>
</dd> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - if <code>from &gt; to</code>
</dd> <dd>
<code><a href="../lang/nullpointerexception">NullPointerException</a></code> - if <code>original</code> is null</dd> <dt>Since:</dt> <dd>1.6</dd> </dl>    <h3 id="copyOfRange(java.lang.Object[],int,int,java.lang.Class)">copyOfRange</h3> <pre data-language="java">public static &lt;T,U&gt; T[] copyOfRange​(U[] original,
                                          int from,
                                          int to,
                                          Class&lt;? extends T[]&gt; newType)</pre> <p>Copies the specified range of the specified array into a new array. The initial index of the range (<code>from</code>) must lie between zero and <code>original.length</code>, inclusive. The value at <code>original[from]</code> is placed into the initial element of the copy (unless <code>from == original.length</code> or <code>from == to</code>). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range (<code>to</code>), which must be greater than or equal to <code>from</code>, may be greater than <code>original.length</code>, in which case <code>null</code> is placed in all elements of the copy whose index is greater than or equal to <code>original.length - from</code>. The length of the returned array will be <code>to - from</code>. The resulting array is of the class <code>newType</code>.</p> <dl> <dt>Type Parameters:</dt> <dd>
<code>U</code> - the class of the objects in the original array</dd> <dd>
<code>T</code> - the class of the objects in the returned array</dd> <dt>Parameters:</dt> <dd>
<code>original</code> - the array from which a range is to be copied</dd> <dd>
<code>from</code> - the initial index of the range to be copied, inclusive</dd> <dd>
<code>to</code> - the final index of the range to be copied, exclusive. (This index may lie outside the array.)</dd> <dd>
<code>newType</code> - the class of the copy to be returned</dd> <dt>Returns:</dt> <dd>a new array containing the specified range from the original array, truncated or padded with nulls to obtain the required length</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/arrayindexoutofboundsexception">ArrayIndexOutOfBoundsException</a></code> - if <code>from &lt; 0</code> or <code>from &gt; original.length</code>
</dd> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - if <code>from &gt; to</code>
</dd> <dd>
<code><a href="../lang/nullpointerexception">NullPointerException</a></code> - if <code>original</code> is null</dd> <dd>
<code><a href="../lang/arraystoreexception">ArrayStoreException</a></code> - if an element copied from <code>original</code> is not of a runtime type that can be stored in an array of class <code>newType</code>.</dd> <dt>Since:</dt> <dd>1.6</dd> </dl>    <h3 id="copyOfRange(byte[],int,int)">copyOfRange</h3> <pre data-language="java">public static byte[] copyOfRange(byte[] original,
                                 int from,
                                 int to)</pre> <p>Copies the specified range of the specified array into a new array. The initial index of the range (<code>from</code>) must lie between zero and <code>original.length</code>, inclusive. The value at <code>original[from]</code> is placed into the initial element of the copy (unless <code>from == original.length</code> or <code>from == to</code>). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range (<code>to</code>), which must be greater than or equal to <code>from</code>, may be greater than <code>original.length</code>, in which case <code>(byte)0</code> is placed in all elements of the copy whose index is greater than or equal to <code>original.length - from</code>. The length of the returned array will be <code>to - from</code>.</p> <dl> <dt>Parameters:</dt> <dd>
<code>original</code> - the array from which a range is to be copied</dd> <dd>
<code>from</code> - the initial index of the range to be copied, inclusive</dd> <dd>
<code>to</code> - the final index of the range to be copied, exclusive. (This index may lie outside the array.)</dd> <dt>Returns:</dt> <dd>a new array containing the specified range from the original array, truncated or padded with zeros to obtain the required length</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/arrayindexoutofboundsexception">ArrayIndexOutOfBoundsException</a></code> - if <code>from &lt; 0</code> or <code>from &gt; original.length</code>
</dd> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - if <code>from &gt; to</code>
</dd> <dd>
<code><a href="../lang/nullpointerexception">NullPointerException</a></code> - if <code>original</code> is null</dd> <dt>Since:</dt> <dd>1.6</dd> </dl>    <h3 id="copyOfRange(short[],int,int)">copyOfRange</h3> <pre data-language="java">public static short[] copyOfRange(short[] original,
                                  int from,
                                  int to)</pre> <p>Copies the specified range of the specified array into a new array. The initial index of the range (<code>from</code>) must lie between zero and <code>original.length</code>, inclusive. The value at <code>original[from]</code> is placed into the initial element of the copy (unless <code>from == original.length</code> or <code>from == to</code>). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range (<code>to</code>), which must be greater than or equal to <code>from</code>, may be greater than <code>original.length</code>, in which case <code>(short)0</code> is placed in all elements of the copy whose index is greater than or equal to <code>original.length - from</code>. The length of the returned array will be <code>to - from</code>.</p> <dl> <dt>Parameters:</dt> <dd>
<code>original</code> - the array from which a range is to be copied</dd> <dd>
<code>from</code> - the initial index of the range to be copied, inclusive</dd> <dd>
<code>to</code> - the final index of the range to be copied, exclusive. (This index may lie outside the array.)</dd> <dt>Returns:</dt> <dd>a new array containing the specified range from the original array, truncated or padded with zeros to obtain the required length</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/arrayindexoutofboundsexception">ArrayIndexOutOfBoundsException</a></code> - if <code>from &lt; 0</code> or <code>from &gt; original.length</code>
</dd> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - if <code>from &gt; to</code>
</dd> <dd>
<code><a href="../lang/nullpointerexception">NullPointerException</a></code> - if <code>original</code> is null</dd> <dt>Since:</dt> <dd>1.6</dd> </dl>    <h3 id="copyOfRange(int[],int,int)">copyOfRange</h3> <pre data-language="java">public static int[] copyOfRange(int[] original,
                                int from,
                                int to)</pre> <p>Copies the specified range of the specified array into a new array. The initial index of the range (<code>from</code>) must lie between zero and <code>original.length</code>, inclusive. The value at <code>original[from]</code> is placed into the initial element of the copy (unless <code>from == original.length</code> or <code>from == to</code>). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range (<code>to</code>), which must be greater than or equal to <code>from</code>, may be greater than <code>original.length</code>, in which case <code>0</code> is placed in all elements of the copy whose index is greater than or equal to <code>original.length - from</code>. The length of the returned array will be <code>to - from</code>.</p> <dl> <dt>Parameters:</dt> <dd>
<code>original</code> - the array from which a range is to be copied</dd> <dd>
<code>from</code> - the initial index of the range to be copied, inclusive</dd> <dd>
<code>to</code> - the final index of the range to be copied, exclusive. (This index may lie outside the array.)</dd> <dt>Returns:</dt> <dd>a new array containing the specified range from the original array, truncated or padded with zeros to obtain the required length</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/arrayindexoutofboundsexception">ArrayIndexOutOfBoundsException</a></code> - if <code>from &lt; 0</code> or <code>from &gt; original.length</code>
</dd> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - if <code>from &gt; to</code>
</dd> <dd>
<code><a href="../lang/nullpointerexception">NullPointerException</a></code> - if <code>original</code> is null</dd> <dt>Since:</dt> <dd>1.6</dd> </dl>    <h3 id="copyOfRange(long[],int,int)">copyOfRange</h3> <pre data-language="java">public static long[] copyOfRange(long[] original,
                                 int from,
                                 int to)</pre> <p>Copies the specified range of the specified array into a new array. The initial index of the range (<code>from</code>) must lie between zero and <code>original.length</code>, inclusive. The value at <code>original[from]</code> is placed into the initial element of the copy (unless <code>from == original.length</code> or <code>from == to</code>). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range (<code>to</code>), which must be greater than or equal to <code>from</code>, may be greater than <code>original.length</code>, in which case <code>0L</code> is placed in all elements of the copy whose index is greater than or equal to <code>original.length - from</code>. The length of the returned array will be <code>to - from</code>.</p> <dl> <dt>Parameters:</dt> <dd>
<code>original</code> - the array from which a range is to be copied</dd> <dd>
<code>from</code> - the initial index of the range to be copied, inclusive</dd> <dd>
<code>to</code> - the final index of the range to be copied, exclusive. (This index may lie outside the array.)</dd> <dt>Returns:</dt> <dd>a new array containing the specified range from the original array, truncated or padded with zeros to obtain the required length</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/arrayindexoutofboundsexception">ArrayIndexOutOfBoundsException</a></code> - if <code>from &lt; 0</code> or <code>from &gt; original.length</code>
</dd> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - if <code>from &gt; to</code>
</dd> <dd>
<code><a href="../lang/nullpointerexception">NullPointerException</a></code> - if <code>original</code> is null</dd> <dt>Since:</dt> <dd>1.6</dd> </dl>    <h3 id="copyOfRange(char[],int,int)">copyOfRange</h3> <pre data-language="java">public static char[] copyOfRange(char[] original,
                                 int from,
                                 int to)</pre> <p>Copies the specified range of the specified array into a new array. The initial index of the range (<code>from</code>) must lie between zero and <code>original.length</code>, inclusive. The value at <code>original[from]</code> is placed into the initial element of the copy (unless <code>from == original.length</code> or <code>from == to</code>). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range (<code>to</code>), which must be greater than or equal to <code>from</code>, may be greater than <code>original.length</code>, in which case <code>'\\u000'</code> is placed in all elements of the copy whose index is greater than or equal to <code>original.length - from</code>. The length of the returned array will be <code>to - from</code>.</p> <dl> <dt>Parameters:</dt> <dd>
<code>original</code> - the array from which a range is to be copied</dd> <dd>
<code>from</code> - the initial index of the range to be copied, inclusive</dd> <dd>
<code>to</code> - the final index of the range to be copied, exclusive. (This index may lie outside the array.)</dd> <dt>Returns:</dt> <dd>a new array containing the specified range from the original array, truncated or padded with null characters to obtain the required length</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/arrayindexoutofboundsexception">ArrayIndexOutOfBoundsException</a></code> - if <code>from &lt; 0</code> or <code>from &gt; original.length</code>
</dd> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - if <code>from &gt; to</code>
</dd> <dd>
<code><a href="../lang/nullpointerexception">NullPointerException</a></code> - if <code>original</code> is null</dd> <dt>Since:</dt> <dd>1.6</dd> </dl>    <h3 id="copyOfRange(float[],int,int)">copyOfRange</h3> <pre data-language="java">public static float[] copyOfRange(float[] original,
                                  int from,
                                  int to)</pre> <p>Copies the specified range of the specified array into a new array. The initial index of the range (<code>from</code>) must lie between zero and <code>original.length</code>, inclusive. The value at <code>original[from]</code> is placed into the initial element of the copy (unless <code>from == original.length</code> or <code>from == to</code>). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range (<code>to</code>), which must be greater than or equal to <code>from</code>, may be greater than <code>original.length</code>, in which case <code>0f</code> is placed in all elements of the copy whose index is greater than or equal to <code>original.length - from</code>. The length of the returned array will be <code>to - from</code>.</p> <dl> <dt>Parameters:</dt> <dd>
<code>original</code> - the array from which a range is to be copied</dd> <dd>
<code>from</code> - the initial index of the range to be copied, inclusive</dd> <dd>
<code>to</code> - the final index of the range to be copied, exclusive. (This index may lie outside the array.)</dd> <dt>Returns:</dt> <dd>a new array containing the specified range from the original array, truncated or padded with zeros to obtain the required length</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/arrayindexoutofboundsexception">ArrayIndexOutOfBoundsException</a></code> - if <code>from &lt; 0</code> or <code>from &gt; original.length</code>
</dd> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - if <code>from &gt; to</code>
</dd> <dd>
<code><a href="../lang/nullpointerexception">NullPointerException</a></code> - if <code>original</code> is null</dd> <dt>Since:</dt> <dd>1.6</dd> </dl>    <h3 id="copyOfRange(double[],int,int)">copyOfRange</h3> <pre data-language="java">public static double[] copyOfRange(double[] original,
                                   int from,
                                   int to)</pre> <p>Copies the specified range of the specified array into a new array. The initial index of the range (<code>from</code>) must lie between zero and <code>original.length</code>, inclusive. The value at <code>original[from]</code> is placed into the initial element of the copy (unless <code>from == original.length</code> or <code>from == to</code>). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range (<code>to</code>), which must be greater than or equal to <code>from</code>, may be greater than <code>original.length</code>, in which case <code>0d</code> is placed in all elements of the copy whose index is greater than or equal to <code>original.length - from</code>. The length of the returned array will be <code>to - from</code>.</p> <dl> <dt>Parameters:</dt> <dd>
<code>original</code> - the array from which a range is to be copied</dd> <dd>
<code>from</code> - the initial index of the range to be copied, inclusive</dd> <dd>
<code>to</code> - the final index of the range to be copied, exclusive. (This index may lie outside the array.)</dd> <dt>Returns:</dt> <dd>a new array containing the specified range from the original array, truncated or padded with zeros to obtain the required length</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/arrayindexoutofboundsexception">ArrayIndexOutOfBoundsException</a></code> - if <code>from &lt; 0</code> or <code>from &gt; original.length</code>
</dd> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - if <code>from &gt; to</code>
</dd> <dd>
<code><a href="../lang/nullpointerexception">NullPointerException</a></code> - if <code>original</code> is null</dd> <dt>Since:</dt> <dd>1.6</dd> </dl>    <h3 id="copyOfRange(boolean[],int,int)">copyOfRange</h3> <pre data-language="java">public static boolean[] copyOfRange(boolean[] original,
                                    int from,
                                    int to)</pre> <p>Copies the specified range of the specified array into a new array. The initial index of the range (<code>from</code>) must lie between zero and <code>original.length</code>, inclusive. The value at <code>original[from]</code> is placed into the initial element of the copy (unless <code>from == original.length</code> or <code>from == to</code>). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range (<code>to</code>), which must be greater than or equal to <code>from</code>, may be greater than <code>original.length</code>, in which case <code>false</code> is placed in all elements of the copy whose index is greater than or equal to <code>original.length - from</code>. The length of the returned array will be <code>to - from</code>.</p> <dl> <dt>Parameters:</dt> <dd>
<code>original</code> - the array from which a range is to be copied</dd> <dd>
<code>from</code> - the initial index of the range to be copied, inclusive</dd> <dd>
<code>to</code> - the final index of the range to be copied, exclusive. (This index may lie outside the array.)</dd> <dt>Returns:</dt> <dd>a new array containing the specified range from the original array, truncated or padded with false elements to obtain the required length</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/arrayindexoutofboundsexception">ArrayIndexOutOfBoundsException</a></code> - if <code>from &lt; 0</code> or <code>from &gt; original.length</code>
</dd> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - if <code>from &gt; to</code>
</dd> <dd>
<code><a href="../lang/nullpointerexception">NullPointerException</a></code> - if <code>original</code> is null</dd> <dt>Since:</dt> <dd>1.6</dd> </dl>    <h3 id="asList(java.lang.Object[])">asList</h3> <pre data-language="java">@SafeVarargs
public static &lt;T&gt; List&lt;T&gt; asList(T... a)</pre> <div>
<p>Returns a fixed-size list backed by the specified array. (Changes to the returned list "write through" to the array.) This method acts as bridge between array-based and collection-based APIs, in combination with <a href="collection#toArray()"><code>Collection.toArray()</code></a>. The returned list is serializable and implements <a href="randomaccess"><code>RandomAccess</code></a>. </p>
<p>This method also provides a convenient way to create a fixed-size list initialized to contain several elements: </p>
<pre data-language="java">List&lt;String&gt; stooges = Arrays.asList("Larry", "Moe", "Curly");</pre>
</div> <dl> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the class of the objects in the array</dd> <dt>Parameters:</dt> <dd>
<code>a</code> - the array by which the list will be backed</dd> <dt>Returns:</dt> <dd>a list view of the specified array</dd> </dl>    <h3 id="hashCode(long[])">hashCode</h3> <pre data-language="java">public static int hashCode(long[] a)</pre> <div>
<p>Returns a hash code based on the contents of the specified array. For any two <code>long</code> arrays <code>a</code> and <code>b</code> such that <code>Arrays.equals(a, b)</code>, it is also the case that <code>Arrays.hashCode(a) == Arrays.hashCode(b)</code>. </p>
<p>The value returned by this method is the same value that would be obtained by invoking the <a href="list#hashCode()"><code>hashCode</code></a> method on a <a href="list"><code>List</code></a> containing a sequence of <a href="../lang/long"><code>Long</code></a> instances representing the elements of <code>a</code> in the same order. If <code>a</code> is <code>null</code>, this method returns 0.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the array whose hash value to compute</dd> <dt>Returns:</dt> <dd>a content-based hash code for <code>a</code>
</dd> <dt>Since:</dt> <dd>1.5</dd> </dl>    <h3 id="hashCode(int[])">hashCode</h3> <pre data-language="java">public static int hashCode(int[] a)</pre> <div>
<p>Returns a hash code based on the contents of the specified array. For any two non-null <code>int</code> arrays <code>a</code> and <code>b</code> such that <code>Arrays.equals(a, b)</code>, it is also the case that <code>Arrays.hashCode(a) == Arrays.hashCode(b)</code>. </p>
<p>The value returned by this method is the same value that would be obtained by invoking the <a href="list#hashCode()"><code>hashCode</code></a> method on a <a href="list"><code>List</code></a> containing a sequence of <a href="../lang/integer"><code>Integer</code></a> instances representing the elements of <code>a</code> in the same order. If <code>a</code> is <code>null</code>, this method returns 0.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the array whose hash value to compute</dd> <dt>Returns:</dt> <dd>a content-based hash code for <code>a</code>
</dd> <dt>Since:</dt> <dd>1.5</dd> </dl>    <h3 id="hashCode(short[])">hashCode</h3> <pre data-language="java">public static int hashCode(short[] a)</pre> <div>
<p>Returns a hash code based on the contents of the specified array. For any two <code>short</code> arrays <code>a</code> and <code>b</code> such that <code>Arrays.equals(a, b)</code>, it is also the case that <code>Arrays.hashCode(a) == Arrays.hashCode(b)</code>. </p>
<p>The value returned by this method is the same value that would be obtained by invoking the <a href="list#hashCode()"><code>hashCode</code></a> method on a <a href="list"><code>List</code></a> containing a sequence of <a href="../lang/short"><code>Short</code></a> instances representing the elements of <code>a</code> in the same order. If <code>a</code> is <code>null</code>, this method returns 0.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the array whose hash value to compute</dd> <dt>Returns:</dt> <dd>a content-based hash code for <code>a</code>
</dd> <dt>Since:</dt> <dd>1.5</dd> </dl>    <h3 id="hashCode(char[])">hashCode</h3> <pre data-language="java">public static int hashCode(char[] a)</pre> <div>
<p>Returns a hash code based on the contents of the specified array. For any two <code>char</code> arrays <code>a</code> and <code>b</code> such that <code>Arrays.equals(a, b)</code>, it is also the case that <code>Arrays.hashCode(a) == Arrays.hashCode(b)</code>. </p>
<p>The value returned by this method is the same value that would be obtained by invoking the <a href="list#hashCode()"><code>hashCode</code></a> method on a <a href="list"><code>List</code></a> containing a sequence of <a href="../lang/character"><code>Character</code></a> instances representing the elements of <code>a</code> in the same order. If <code>a</code> is <code>null</code>, this method returns 0.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the array whose hash value to compute</dd> <dt>Returns:</dt> <dd>a content-based hash code for <code>a</code>
</dd> <dt>Since:</dt> <dd>1.5</dd> </dl>    <h3 id="hashCode(byte[])">hashCode</h3> <pre data-language="java">public static int hashCode(byte[] a)</pre> <div>
<p>Returns a hash code based on the contents of the specified array. For any two <code>byte</code> arrays <code>a</code> and <code>b</code> such that <code>Arrays.equals(a, b)</code>, it is also the case that <code>Arrays.hashCode(a) == Arrays.hashCode(b)</code>. </p>
<p>The value returned by this method is the same value that would be obtained by invoking the <a href="list#hashCode()"><code>hashCode</code></a> method on a <a href="list"><code>List</code></a> containing a sequence of <a href="../lang/byte"><code>Byte</code></a> instances representing the elements of <code>a</code> in the same order. If <code>a</code> is <code>null</code>, this method returns 0.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the array whose hash value to compute</dd> <dt>Returns:</dt> <dd>a content-based hash code for <code>a</code>
</dd> <dt>Since:</dt> <dd>1.5</dd> </dl>    <h3 id="hashCode(boolean[])">hashCode</h3> <pre data-language="java">public static int hashCode(boolean[] a)</pre> <div>
<p>Returns a hash code based on the contents of the specified array. For any two <code>boolean</code> arrays <code>a</code> and <code>b</code> such that <code>Arrays.equals(a, b)</code>, it is also the case that <code>Arrays.hashCode(a) == Arrays.hashCode(b)</code>. </p>
<p>The value returned by this method is the same value that would be obtained by invoking the <a href="list#hashCode()"><code>hashCode</code></a> method on a <a href="list"><code>List</code></a> containing a sequence of <a href="../lang/boolean"><code>Boolean</code></a> instances representing the elements of <code>a</code> in the same order. If <code>a</code> is <code>null</code>, this method returns 0.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the array whose hash value to compute</dd> <dt>Returns:</dt> <dd>a content-based hash code for <code>a</code>
</dd> <dt>Since:</dt> <dd>1.5</dd> </dl>    <h3 id="hashCode(float[])">hashCode</h3> <pre data-language="java">public static int hashCode(float[] a)</pre> <div>
<p>Returns a hash code based on the contents of the specified array. For any two <code>float</code> arrays <code>a</code> and <code>b</code> such that <code>Arrays.equals(a, b)</code>, it is also the case that <code>Arrays.hashCode(a) == Arrays.hashCode(b)</code>. </p>
<p>The value returned by this method is the same value that would be obtained by invoking the <a href="list#hashCode()"><code>hashCode</code></a> method on a <a href="list"><code>List</code></a> containing a sequence of <a href="../lang/float"><code>Float</code></a> instances representing the elements of <code>a</code> in the same order. If <code>a</code> is <code>null</code>, this method returns 0.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the array whose hash value to compute</dd> <dt>Returns:</dt> <dd>a content-based hash code for <code>a</code>
</dd> <dt>Since:</dt> <dd>1.5</dd> </dl>    <h3 id="hashCode(double[])">hashCode</h3> <pre data-language="java">public static int hashCode(double[] a)</pre> <div>
<p>Returns a hash code based on the contents of the specified array. For any two <code>double</code> arrays <code>a</code> and <code>b</code> such that <code>Arrays.equals(a, b)</code>, it is also the case that <code>Arrays.hashCode(a) == Arrays.hashCode(b)</code>. </p>
<p>The value returned by this method is the same value that would be obtained by invoking the <a href="list#hashCode()"><code>hashCode</code></a> method on a <a href="list"><code>List</code></a> containing a sequence of <a href="../lang/double"><code>Double</code></a> instances representing the elements of <code>a</code> in the same order. If <code>a</code> is <code>null</code>, this method returns 0.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the array whose hash value to compute</dd> <dt>Returns:</dt> <dd>a content-based hash code for <code>a</code>
</dd> <dt>Since:</dt> <dd>1.5</dd> </dl>    <h3 id="hashCode(java.lang.Object[])">hashCode</h3> <pre data-language="java">public static int hashCode(Object[] a)</pre> <div>
<p>Returns a hash code based on the contents of the specified array. If the array contains other arrays as elements, the hash code is based on their identities rather than their contents. It is therefore acceptable to invoke this method on an array that contains itself as an element, either directly or indirectly through one or more levels of arrays. </p>
<p>For any two arrays <code>a</code> and <code>b</code> such that <code>Arrays.equals(a, b)</code>, it is also the case that <code>Arrays.hashCode(a) == Arrays.hashCode(b)</code>. </p>
<p>The value returned by this method is equal to the value that would be returned by <code>Arrays.asList(a).hashCode()</code>, unless <code>a</code> is <code>null</code>, in which case <code>0</code> is returned.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the array whose content-based hash code to compute</dd> <dt>Returns:</dt> <dd>a content-based hash code for <code>a</code>
</dd> <dt>Since:</dt> <dd>1.5</dd> <dt>See Also:</dt> <dd><a href="#deepHashCode(java.lang.Object%5B%5D)"><code>deepHashCode(Object[])</code></a></dd> </dl>    <h3 id="deepHashCode(java.lang.Object[])">deepHashCode</h3> <pre data-language="java">public static int deepHashCode(Object[] a)</pre> <div>
<p>Returns a hash code based on the "deep contents" of the specified array. If the array contains other arrays as elements, the hash code is based on their contents and so on, ad infinitum. It is therefore unacceptable to invoke this method on an array that contains itself as an element, either directly or indirectly through one or more levels of arrays. The behavior of such an invocation is undefined. </p>
<p>For any two arrays <code>a</code> and <code>b</code> such that <code>Arrays.deepEquals(a, b)</code>, it is also the case that <code>Arrays.deepHashCode(a) == Arrays.deepHashCode(b)</code>. </p>
<p>The computation of the value returned by this method is similar to that of the value returned by <a href="list#hashCode()"><code>List.hashCode()</code></a> on a list containing the same elements as <code>a</code> in the same order, with one difference: If an element <code>e</code> of <code>a</code> is itself an array, its hash code is computed not by calling <code>e.hashCode()</code>, but as by calling the appropriate overloading of <code>Arrays.hashCode(e)</code> if <code>e</code> is an array of a primitive type, or as by calling <code>Arrays.deepHashCode(e)</code> recursively if <code>e</code> is an array of a reference type. If <code>a</code> is <code>null</code>, this method returns 0.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the array whose deep-content-based hash code to compute</dd> <dt>Returns:</dt> <dd>a deep-content-based hash code for <code>a</code>
</dd> <dt>Since:</dt> <dd>1.5</dd> <dt>See Also:</dt> <dd><a href="#hashCode(java.lang.Object%5B%5D)"><code>hashCode(Object[])</code></a></dd> </dl>    <h3 id="deepEquals(java.lang.Object[],java.lang.Object[])">deepEquals</h3> <pre data-language="java">public static boolean deepEquals(Object[] a1,
                                 Object[] a2)</pre> <div>
<p>Returns <code>true</code> if the two specified arrays are <i>deeply equal</i> to one another. Unlike the <a href="#equals(java.lang.Object%5B%5D,java.lang.Object%5B%5D)"><code>equals(Object[],Object[])</code></a> method, this method is appropriate for use with nested arrays of arbitrary depth. </p>
<p>Two array references are considered deeply equal if both are <code>null</code>, or if they refer to arrays that contain the same number of elements and all corresponding pairs of elements in the two arrays are deeply equal. </p>
<p>Two possibly <code>null</code> elements <code>e1</code> and <code>e2</code> are deeply equal if any of the following conditions hold: </p>
<ul> <li> <code>e1</code> and <code>e2</code> are both arrays of object reference types, and <code>Arrays.deepEquals(e1, e2) would return true</code> </li>
<li> <code>e1</code> and <code>e2</code> are arrays of the same primitive type, and the appropriate overloading of <code>Arrays.equals(e1, e2)</code> would return true. </li>
<li> <code>e1 == e2</code> </li>
<li> <code>e1.equals(e2)</code> would return true. </li>
</ul> Note that this definition permits <code>null</code> elements at any depth. <p>If either of the specified arrays contain themselves as elements either directly or indirectly through one or more levels of arrays, the behavior of this method is undefined.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>a1</code> - one array to be tested for equality</dd> <dd>
<code>a2</code> - the other array to be tested for equality</dd> <dt>Returns:</dt> <dd>
<code>true</code> if the two arrays are equal</dd> <dt>Since:</dt> <dd>1.5</dd> <dt>See Also:</dt> <dd>
<a href="#equals(java.lang.Object%5B%5D,java.lang.Object%5B%5D)"><code>equals(Object[],Object[])</code></a>, <a href="objects#deepEquals(java.lang.Object,java.lang.Object)"><code>Objects.deepEquals(Object, Object)</code></a>
</dd> </dl>    <h3 id="toString(long[])">toString</h3> <pre data-language="java">public static String toString(long[] a)</pre> <p>Returns a string representation of the contents of the specified array. The string representation consists of a list of the array's elements, enclosed in square brackets (<code>"[]"</code>). Adjacent elements are separated by the characters <code>", "</code> (a comma followed by a space). Elements are converted to strings as by <code>String.valueOf(long)</code>. Returns <code>"null"</code> if <code>a</code> is <code>null</code>.</p> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the array whose string representation to return</dd> <dt>Returns:</dt> <dd>a string representation of <code>a</code>
</dd> <dt>Since:</dt> <dd>1.5</dd> </dl>    <h3 id="toString(int[])">toString</h3> <pre data-language="java">public static String toString(int[] a)</pre> <p>Returns a string representation of the contents of the specified array. The string representation consists of a list of the array's elements, enclosed in square brackets (<code>"[]"</code>). Adjacent elements are separated by the characters <code>", "</code> (a comma followed by a space). Elements are converted to strings as by <code>String.valueOf(int)</code>. Returns <code>"null"</code> if <code>a</code> is <code>null</code>.</p> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the array whose string representation to return</dd> <dt>Returns:</dt> <dd>a string representation of <code>a</code>
</dd> <dt>Since:</dt> <dd>1.5</dd> </dl>    <h3 id="toString(short[])">toString</h3> <pre data-language="java">public static String toString(short[] a)</pre> <p>Returns a string representation of the contents of the specified array. The string representation consists of a list of the array's elements, enclosed in square brackets (<code>"[]"</code>). Adjacent elements are separated by the characters <code>", "</code> (a comma followed by a space). Elements are converted to strings as by <code>String.valueOf(short)</code>. Returns <code>"null"</code> if <code>a</code> is <code>null</code>.</p> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the array whose string representation to return</dd> <dt>Returns:</dt> <dd>a string representation of <code>a</code>
</dd> <dt>Since:</dt> <dd>1.5</dd> </dl>    <h3 id="toString(char[])">toString</h3> <pre data-language="java">public static String toString(char[] a)</pre> <p>Returns a string representation of the contents of the specified array. The string representation consists of a list of the array's elements, enclosed in square brackets (<code>"[]"</code>). Adjacent elements are separated by the characters <code>", "</code> (a comma followed by a space). Elements are converted to strings as by <code>String.valueOf(char)</code>. Returns <code>"null"</code> if <code>a</code> is <code>null</code>.</p> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the array whose string representation to return</dd> <dt>Returns:</dt> <dd>a string representation of <code>a</code>
</dd> <dt>Since:</dt> <dd>1.5</dd> </dl>    <h3 id="toString(byte[])">toString</h3> <pre data-language="java">public static String toString(byte[] a)</pre> <p>Returns a string representation of the contents of the specified array. The string representation consists of a list of the array's elements, enclosed in square brackets (<code>"[]"</code>). Adjacent elements are separated by the characters <code>", "</code> (a comma followed by a space). Elements are converted to strings as by <code>String.valueOf(byte)</code>. Returns <code>"null"</code> if <code>a</code> is <code>null</code>.</p> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the array whose string representation to return</dd> <dt>Returns:</dt> <dd>a string representation of <code>a</code>
</dd> <dt>Since:</dt> <dd>1.5</dd> </dl>    <h3 id="toString(boolean[])">toString</h3> <pre data-language="java">public static String toString(boolean[] a)</pre> <p>Returns a string representation of the contents of the specified array. The string representation consists of a list of the array's elements, enclosed in square brackets (<code>"[]"</code>). Adjacent elements are separated by the characters <code>", "</code> (a comma followed by a space). Elements are converted to strings as by <code>String.valueOf(boolean)</code>. Returns <code>"null"</code> if <code>a</code> is <code>null</code>.</p> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the array whose string representation to return</dd> <dt>Returns:</dt> <dd>a string representation of <code>a</code>
</dd> <dt>Since:</dt> <dd>1.5</dd> </dl>    <h3 id="toString(float[])">toString</h3> <pre data-language="java">public static String toString(float[] a)</pre> <p>Returns a string representation of the contents of the specified array. The string representation consists of a list of the array's elements, enclosed in square brackets (<code>"[]"</code>). Adjacent elements are separated by the characters <code>", "</code> (a comma followed by a space). Elements are converted to strings as by <code>String.valueOf(float)</code>. Returns <code>"null"</code> if <code>a</code> is <code>null</code>.</p> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the array whose string representation to return</dd> <dt>Returns:</dt> <dd>a string representation of <code>a</code>
</dd> <dt>Since:</dt> <dd>1.5</dd> </dl>    <h3 id="toString(double[])">toString</h3> <pre data-language="java">public static String toString(double[] a)</pre> <p>Returns a string representation of the contents of the specified array. The string representation consists of a list of the array's elements, enclosed in square brackets (<code>"[]"</code>). Adjacent elements are separated by the characters <code>", "</code> (a comma followed by a space). Elements are converted to strings as by <code>String.valueOf(double)</code>. Returns <code>"null"</code> if <code>a</code> is <code>null</code>.</p> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the array whose string representation to return</dd> <dt>Returns:</dt> <dd>a string representation of <code>a</code>
</dd> <dt>Since:</dt> <dd>1.5</dd> </dl>    <h3 id="toString(java.lang.Object[])">toString</h3> <pre data-language="java">public static String toString(Object[] a)</pre> <div>
<p>Returns a string representation of the contents of the specified array. If the array contains other arrays as elements, they are converted to strings by the <a href="../lang/object#toString()"><code>Object.toString()</code></a> method inherited from <code>Object</code>, which describes their <i>identities</i> rather than their contents. </p>
<p>The value returned by this method is equal to the value that would be returned by <code>Arrays.asList(a).toString()</code>, unless <code>a</code> is <code>null</code>, in which case <code>"null"</code> is returned.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the array whose string representation to return</dd> <dt>Returns:</dt> <dd>a string representation of <code>a</code>
</dd> <dt>Since:</dt> <dd>1.5</dd> <dt>See Also:</dt> <dd><a href="#deepToString(java.lang.Object%5B%5D)"><code>deepToString(Object[])</code></a></dd> </dl>    <h3 id="deepToString(java.lang.Object[])">deepToString</h3> <pre data-language="java">public static String deepToString(Object[] a)</pre> <div>
<p>Returns a string representation of the "deep contents" of the specified array. If the array contains other arrays as elements, the string representation contains their contents and so on. This method is designed for converting multidimensional arrays to strings. </p>
<p>The string representation consists of a list of the array's elements, enclosed in square brackets (<code>"[]"</code>). Adjacent elements are separated by the characters <code>", "</code> (a comma followed by a space). Elements are converted to strings as by <code>String.valueOf(Object)</code>, unless they are themselves arrays. </p>
<p>If an element <code>e</code> is an array of a primitive type, it is converted to a string as by invoking the appropriate overloading of <code>Arrays.toString(e)</code>. If an element <code>e</code> is an array of a reference type, it is converted to a string as by invoking this method recursively. </p>
<p>To avoid infinite recursion, if the specified array contains itself as an element, or contains an indirect reference to itself through one or more levels of arrays, the self-reference is converted to the string <code>"[...]"</code>. For example, an array containing only a reference to itself would be rendered as <code>"[[...]]"</code>. </p>
<p>This method returns <code>"null"</code> if the specified array is <code>null</code>.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the array whose string representation to return</dd> <dt>Returns:</dt> <dd>a string representation of <code>a</code>
</dd> <dt>Since:</dt> <dd>1.5</dd> <dt>See Also:</dt> <dd><a href="#toString(java.lang.Object%5B%5D)"><code>toString(Object[])</code></a></dd> </dl>    <h3 id="setAll(java.lang.Object[],java.util.function.IntFunction)">setAll</h3> <pre data-language="java">public static &lt;T&gt; void setAll(T[] array,
                              IntFunction&lt;? extends T&gt; generator)</pre> <div>
<p>Set all elements of the specified array, using the provided generator function to compute each element. </p>
<p>If the generator function throws an exception, it is relayed to the caller and the array is left in an indeterminate state.</p>
</div> <dl> <dt>API Note:</dt> <dd>Setting a subrange of an array, using a generator function to compute each element, can be written as follows: <pre data-language="java">IntStream.range(startInclusive, endExclusive)
          .forEach(i -&gt; array[i] = generator.apply(i));</pre>
</dd> <dt>Type Parameters:</dt> <dd>
<code>T</code> - type of elements of the array</dd> <dt>Parameters:</dt> <dd>
<code>array</code> - array to be initialized</dd> <dd>
<code>generator</code> - a function accepting an index and producing the desired value for that position</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/nullpointerexception">NullPointerException</a></code> - if the generator is null</dd> <dt>Since:</dt> <dd>1.8</dd> </dl>    <h3 id="parallelSetAll(java.lang.Object[],java.util.function.IntFunction)">parallelSetAll</h3> <pre data-language="java">public static &lt;T&gt; void parallelSetAll(T[] array,
                                      IntFunction&lt;? extends T&gt; generator)</pre> <div>
<p>Set all elements of the specified array, in parallel, using the provided generator function to compute each element. </p>
<p>If the generator function throws an exception, an unchecked exception is thrown from <code>parallelSetAll</code> and the array is left in an indeterminate state.</p>
</div> <dl> <dt>API Note:</dt> <dd>Setting a subrange of an array, in parallel, using a generator function to compute each element, can be written as follows: <pre data-language="java">IntStream.range(startInclusive, endExclusive)
          .parallel()
          .forEach(i -&gt; array[i] = generator.apply(i));</pre>
</dd> <dt>Type Parameters:</dt> <dd>
<code>T</code> - type of elements of the array</dd> <dt>Parameters:</dt> <dd>
<code>array</code> - array to be initialized</dd> <dd>
<code>generator</code> - a function accepting an index and producing the desired value for that position</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/nullpointerexception">NullPointerException</a></code> - if the generator is null</dd> <dt>Since:</dt> <dd>1.8</dd> </dl>    <h3 id="setAll(int[],java.util.function.IntUnaryOperator)">setAll</h3> <pre data-language="java">public static void setAll(int[] array,
                          IntUnaryOperator generator)</pre> <div>
<p>Set all elements of the specified array, using the provided generator function to compute each element. </p>
<p>If the generator function throws an exception, it is relayed to the caller and the array is left in an indeterminate state.</p>
</div> <dl> <dt>API Note:</dt> <dd>Setting a subrange of an array, using a generator function to compute each element, can be written as follows: <pre data-language="java">IntStream.range(startInclusive, endExclusive)
          .forEach(i -&gt; array[i] = generator.applyAsInt(i));</pre>
</dd> <dt>Parameters:</dt> <dd>
<code>array</code> - array to be initialized</dd> <dd>
<code>generator</code> - a function accepting an index and producing the desired value for that position</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/nullpointerexception">NullPointerException</a></code> - if the generator is null</dd> <dt>Since:</dt> <dd>1.8</dd> </dl>    <h3 id="parallelSetAll(int[],java.util.function.IntUnaryOperator)">parallelSetAll</h3> <pre data-language="java">public static void parallelSetAll(int[] array,
                                  IntUnaryOperator generator)</pre> <div>
<p>Set all elements of the specified array, in parallel, using the provided generator function to compute each element. </p>
<p>If the generator function throws an exception, an unchecked exception is thrown from <code>parallelSetAll</code> and the array is left in an indeterminate state.</p>
</div> <dl> <dt>API Note:</dt> <dd>Setting a subrange of an array, in parallel, using a generator function to compute each element, can be written as follows: <pre data-language="java">IntStream.range(startInclusive, endExclusive)
          .parallel()
          .forEach(i -&gt; array[i] = generator.applyAsInt(i));</pre>
</dd> <dt>Parameters:</dt> <dd>
<code>array</code> - array to be initialized</dd> <dd>
<code>generator</code> - a function accepting an index and producing the desired value for that position</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/nullpointerexception">NullPointerException</a></code> - if the generator is null</dd> <dt>Since:</dt> <dd>1.8</dd> </dl>    <h3 id="setAll(long[],java.util.function.IntToLongFunction)">setAll</h3> <pre data-language="java">public static void setAll(long[] array,
                          IntToLongFunction generator)</pre> <div>
<p>Set all elements of the specified array, using the provided generator function to compute each element. </p>
<p>If the generator function throws an exception, it is relayed to the caller and the array is left in an indeterminate state.</p>
</div> <dl> <dt>API Note:</dt> <dd>Setting a subrange of an array, using a generator function to compute each element, can be written as follows: <pre data-language="java">IntStream.range(startInclusive, endExclusive)
          .forEach(i -&gt; array[i] = generator.applyAsLong(i));</pre>
</dd> <dt>Parameters:</dt> <dd>
<code>array</code> - array to be initialized</dd> <dd>
<code>generator</code> - a function accepting an index and producing the desired value for that position</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/nullpointerexception">NullPointerException</a></code> - if the generator is null</dd> <dt>Since:</dt> <dd>1.8</dd> </dl>    <h3 id="parallelSetAll(long[],java.util.function.IntToLongFunction)">parallelSetAll</h3> <pre data-language="java">public static void parallelSetAll(long[] array,
                                  IntToLongFunction generator)</pre> <div>
<p>Set all elements of the specified array, in parallel, using the provided generator function to compute each element. </p>
<p>If the generator function throws an exception, an unchecked exception is thrown from <code>parallelSetAll</code> and the array is left in an indeterminate state.</p>
</div> <dl> <dt>API Note:</dt> <dd>Setting a subrange of an array, in parallel, using a generator function to compute each element, can be written as follows: <pre data-language="java">IntStream.range(startInclusive, endExclusive)
          .parallel()
          .forEach(i -&gt; array[i] = generator.applyAsLong(i));</pre>
</dd> <dt>Parameters:</dt> <dd>
<code>array</code> - array to be initialized</dd> <dd>
<code>generator</code> - a function accepting an index and producing the desired value for that position</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/nullpointerexception">NullPointerException</a></code> - if the generator is null</dd> <dt>Since:</dt> <dd>1.8</dd> </dl>    <h3 id="setAll(double[],java.util.function.IntToDoubleFunction)">setAll</h3> <pre data-language="java">public static void setAll(double[] array,
                          IntToDoubleFunction generator)</pre> <div>
<p>Set all elements of the specified array, using the provided generator function to compute each element. </p>
<p>If the generator function throws an exception, it is relayed to the caller and the array is left in an indeterminate state.</p>
</div> <dl> <dt>API Note:</dt> <dd>Setting a subrange of an array, using a generator function to compute each element, can be written as follows: <pre data-language="java">IntStream.range(startInclusive, endExclusive)
          .forEach(i -&gt; array[i] = generator.applyAsDouble(i));</pre>
</dd> <dt>Parameters:</dt> <dd>
<code>array</code> - array to be initialized</dd> <dd>
<code>generator</code> - a function accepting an index and producing the desired value for that position</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/nullpointerexception">NullPointerException</a></code> - if the generator is null</dd> <dt>Since:</dt> <dd>1.8</dd> </dl>    <h3 id="parallelSetAll(double[],java.util.function.IntToDoubleFunction)">parallelSetAll</h3> <pre data-language="java">public static void parallelSetAll(double[] array,
                                  IntToDoubleFunction generator)</pre> <div>
<p>Set all elements of the specified array, in parallel, using the provided generator function to compute each element. </p>
<p>If the generator function throws an exception, an unchecked exception is thrown from <code>parallelSetAll</code> and the array is left in an indeterminate state.</p>
</div> <dl> <dt>API Note:</dt> <dd>Setting a subrange of an array, in parallel, using a generator function to compute each element, can be written as follows: <pre data-language="java">IntStream.range(startInclusive, endExclusive)
          .parallel()
          .forEach(i -&gt; array[i] = generator.applyAsDouble(i));</pre>
</dd> <dt>Parameters:</dt> <dd>
<code>array</code> - array to be initialized</dd> <dd>
<code>generator</code> - a function accepting an index and producing the desired value for that position</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/nullpointerexception">NullPointerException</a></code> - if the generator is null</dd> <dt>Since:</dt> <dd>1.8</dd> </dl>    <h3 id="spliterator(java.lang.Object[])">spliterator</h3> <pre data-language="java">public static &lt;T&gt; Spliterator&lt;T&gt; spliterator(T[] array)</pre> <div>
<p>Returns a <a href="spliterator"><code>Spliterator</code></a> covering all of the specified array. </p>
<p>The spliterator reports <a href="spliterator#SIZED"><code>Spliterator.SIZED</code></a>, <a href="spliterator#SUBSIZED"><code>Spliterator.SUBSIZED</code></a>, <a href="spliterator#ORDERED"><code>Spliterator.ORDERED</code></a>, and <a href="spliterator#IMMUTABLE"><code>Spliterator.IMMUTABLE</code></a>.</p>
</div> <dl> <dt>Type Parameters:</dt> <dd>
<code>T</code> - type of elements</dd> <dt>Parameters:</dt> <dd>
<code>array</code> - the array, assumed to be unmodified during use</dd> <dt>Returns:</dt> <dd>a spliterator for the array elements</dd> <dt>Since:</dt> <dd>1.8</dd> </dl>    <h3 id="spliterator(java.lang.Object[],int,int)">spliterator</h3> <pre data-language="java">public static &lt;T&gt; Spliterator&lt;T&gt; spliterator(T[] array,
                                             int startInclusive,
                                             int endExclusive)</pre> <div>
<p>Returns a <a href="spliterator"><code>Spliterator</code></a> covering the specified range of the specified array. </p>
<p>The spliterator reports <a href="spliterator#SIZED"><code>Spliterator.SIZED</code></a>, <a href="spliterator#SUBSIZED"><code>Spliterator.SUBSIZED</code></a>, <a href="spliterator#ORDERED"><code>Spliterator.ORDERED</code></a>, and <a href="spliterator#IMMUTABLE"><code>Spliterator.IMMUTABLE</code></a>.</p>
</div> <dl> <dt>Type Parameters:</dt> <dd>
<code>T</code> - type of elements</dd> <dt>Parameters:</dt> <dd>
<code>array</code> - the array, assumed to be unmodified during use</dd> <dd>
<code>startInclusive</code> - the first index to cover, inclusive</dd> <dd>
<code>endExclusive</code> - index immediately past the last index to cover</dd> <dt>Returns:</dt> <dd>a spliterator for the array elements</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/arrayindexoutofboundsexception">ArrayIndexOutOfBoundsException</a></code> - if <code>startInclusive</code> is negative, <code>endExclusive</code> is less than <code>startInclusive</code>, or <code>endExclusive</code> is greater than the array size</dd> <dt>Since:</dt> <dd>1.8</dd> </dl>    <h3 id="spliterator(int[])">spliterator</h3> <pre data-language="java">public static Spliterator.OfInt spliterator(int[] array)</pre> <div>
<p>Returns a <a href="spliterator.ofint"><code>Spliterator.OfInt</code></a> covering all of the specified array. </p>
<p>The spliterator reports <a href="spliterator#SIZED"><code>Spliterator.SIZED</code></a>, <a href="spliterator#SUBSIZED"><code>Spliterator.SUBSIZED</code></a>, <a href="spliterator#ORDERED"><code>Spliterator.ORDERED</code></a>, and <a href="spliterator#IMMUTABLE"><code>Spliterator.IMMUTABLE</code></a>.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>array</code> - the array, assumed to be unmodified during use</dd> <dt>Returns:</dt> <dd>a spliterator for the array elements</dd> <dt>Since:</dt> <dd>1.8</dd> </dl>    <h3 id="spliterator(int[],int,int)">spliterator</h3> <pre data-language="java">public static Spliterator.OfInt spliterator(int[] array,
                                            int startInclusive,
                                            int endExclusive)</pre> <div>
<p>Returns a <a href="spliterator.ofint"><code>Spliterator.OfInt</code></a> covering the specified range of the specified array. </p>
<p>The spliterator reports <a href="spliterator#SIZED"><code>Spliterator.SIZED</code></a>, <a href="spliterator#SUBSIZED"><code>Spliterator.SUBSIZED</code></a>, <a href="spliterator#ORDERED"><code>Spliterator.ORDERED</code></a>, and <a href="spliterator#IMMUTABLE"><code>Spliterator.IMMUTABLE</code></a>.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>array</code> - the array, assumed to be unmodified during use</dd> <dd>
<code>startInclusive</code> - the first index to cover, inclusive</dd> <dd>
<code>endExclusive</code> - index immediately past the last index to cover</dd> <dt>Returns:</dt> <dd>a spliterator for the array elements</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/arrayindexoutofboundsexception">ArrayIndexOutOfBoundsException</a></code> - if <code>startInclusive</code> is negative, <code>endExclusive</code> is less than <code>startInclusive</code>, or <code>endExclusive</code> is greater than the array size</dd> <dt>Since:</dt> <dd>1.8</dd> </dl>    <h3 id="spliterator(long[])">spliterator</h3> <pre data-language="java">public static Spliterator.OfLong spliterator(long[] array)</pre> <div>
<p>Returns a <a href="spliterator.oflong"><code>Spliterator.OfLong</code></a> covering all of the specified array. </p>
<p>The spliterator reports <a href="spliterator#SIZED"><code>Spliterator.SIZED</code></a>, <a href="spliterator#SUBSIZED"><code>Spliterator.SUBSIZED</code></a>, <a href="spliterator#ORDERED"><code>Spliterator.ORDERED</code></a>, and <a href="spliterator#IMMUTABLE"><code>Spliterator.IMMUTABLE</code></a>.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>array</code> - the array, assumed to be unmodified during use</dd> <dt>Returns:</dt> <dd>the spliterator for the array elements</dd> <dt>Since:</dt> <dd>1.8</dd> </dl>    <h3 id="spliterator(long[],int,int)">spliterator</h3> <pre data-language="java">public static Spliterator.OfLong spliterator(long[] array,
                                             int startInclusive,
                                             int endExclusive)</pre> <div>
<p>Returns a <a href="spliterator.oflong"><code>Spliterator.OfLong</code></a> covering the specified range of the specified array. </p>
<p>The spliterator reports <a href="spliterator#SIZED"><code>Spliterator.SIZED</code></a>, <a href="spliterator#SUBSIZED"><code>Spliterator.SUBSIZED</code></a>, <a href="spliterator#ORDERED"><code>Spliterator.ORDERED</code></a>, and <a href="spliterator#IMMUTABLE"><code>Spliterator.IMMUTABLE</code></a>.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>array</code> - the array, assumed to be unmodified during use</dd> <dd>
<code>startInclusive</code> - the first index to cover, inclusive</dd> <dd>
<code>endExclusive</code> - index immediately past the last index to cover</dd> <dt>Returns:</dt> <dd>a spliterator for the array elements</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/arrayindexoutofboundsexception">ArrayIndexOutOfBoundsException</a></code> - if <code>startInclusive</code> is negative, <code>endExclusive</code> is less than <code>startInclusive</code>, or <code>endExclusive</code> is greater than the array size</dd> <dt>Since:</dt> <dd>1.8</dd> </dl>    <h3 id="spliterator(double[])">spliterator</h3> <pre data-language="java">public static Spliterator.OfDouble spliterator(double[] array)</pre> <div>
<p>Returns a <a href="spliterator.ofdouble"><code>Spliterator.OfDouble</code></a> covering all of the specified array. </p>
<p>The spliterator reports <a href="spliterator#SIZED"><code>Spliterator.SIZED</code></a>, <a href="spliterator#SUBSIZED"><code>Spliterator.SUBSIZED</code></a>, <a href="spliterator#ORDERED"><code>Spliterator.ORDERED</code></a>, and <a href="spliterator#IMMUTABLE"><code>Spliterator.IMMUTABLE</code></a>.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>array</code> - the array, assumed to be unmodified during use</dd> <dt>Returns:</dt> <dd>a spliterator for the array elements</dd> <dt>Since:</dt> <dd>1.8</dd> </dl>    <h3 id="spliterator(double[],int,int)">spliterator</h3> <pre data-language="java">public static Spliterator.OfDouble spliterator(double[] array,
                                               int startInclusive,
                                               int endExclusive)</pre> <div>
<p>Returns a <a href="spliterator.ofdouble"><code>Spliterator.OfDouble</code></a> covering the specified range of the specified array. </p>
<p>The spliterator reports <a href="spliterator#SIZED"><code>Spliterator.SIZED</code></a>, <a href="spliterator#SUBSIZED"><code>Spliterator.SUBSIZED</code></a>, <a href="spliterator#ORDERED"><code>Spliterator.ORDERED</code></a>, and <a href="spliterator#IMMUTABLE"><code>Spliterator.IMMUTABLE</code></a>.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>array</code> - the array, assumed to be unmodified during use</dd> <dd>
<code>startInclusive</code> - the first index to cover, inclusive</dd> <dd>
<code>endExclusive</code> - index immediately past the last index to cover</dd> <dt>Returns:</dt> <dd>a spliterator for the array elements</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/arrayindexoutofboundsexception">ArrayIndexOutOfBoundsException</a></code> - if <code>startInclusive</code> is negative, <code>endExclusive</code> is less than <code>startInclusive</code>, or <code>endExclusive</code> is greater than the array size</dd> <dt>Since:</dt> <dd>1.8</dd> </dl>    <h3 id="stream(java.lang.Object[])">stream</h3> <pre data-language="java">public static &lt;T&gt; Stream&lt;T&gt; stream(T[] array)</pre> <p>Returns a sequential <a href="stream/stream"><code>Stream</code></a> with the specified array as its source.</p> <dl> <dt>Type Parameters:</dt> <dd>
<code>T</code> - The type of the array elements</dd> <dt>Parameters:</dt> <dd>
<code>array</code> - The array, assumed to be unmodified during use</dd> <dt>Returns:</dt> <dd>a <code>Stream</code> for the array</dd> <dt>Since:</dt> <dd>1.8</dd> </dl>    <h3 id="stream(java.lang.Object[],int,int)">stream</h3> <pre data-language="java">public static &lt;T&gt; Stream&lt;T&gt; stream(T[] array,
                                   int startInclusive,
                                   int endExclusive)</pre> <p>Returns a sequential <a href="stream/stream"><code>Stream</code></a> with the specified range of the specified array as its source.</p> <dl> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the type of the array elements</dd> <dt>Parameters:</dt> <dd>
<code>array</code> - the array, assumed to be unmodified during use</dd> <dd>
<code>startInclusive</code> - the first index to cover, inclusive</dd> <dd>
<code>endExclusive</code> - index immediately past the last index to cover</dd> <dt>Returns:</dt> <dd>a <code>Stream</code> for the array range</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/arrayindexoutofboundsexception">ArrayIndexOutOfBoundsException</a></code> - if <code>startInclusive</code> is negative, <code>endExclusive</code> is less than <code>startInclusive</code>, or <code>endExclusive</code> is greater than the array size</dd> <dt>Since:</dt> <dd>1.8</dd> </dl>    <h3 id="stream(int[])">stream</h3> <pre data-language="java">public static IntStream stream(int[] array)</pre> <p>Returns a sequential <a href="stream/intstream"><code>IntStream</code></a> with the specified array as its source.</p> <dl> <dt>Parameters:</dt> <dd>
<code>array</code> - the array, assumed to be unmodified during use</dd> <dt>Returns:</dt> <dd>an <code>IntStream</code> for the array</dd> <dt>Since:</dt> <dd>1.8</dd> </dl>    <h3 id="stream(int[],int,int)">stream</h3> <pre data-language="java">public static IntStream stream(int[] array,
                               int startInclusive,
                               int endExclusive)</pre> <p>Returns a sequential <a href="stream/intstream"><code>IntStream</code></a> with the specified range of the specified array as its source.</p> <dl> <dt>Parameters:</dt> <dd>
<code>array</code> - the array, assumed to be unmodified during use</dd> <dd>
<code>startInclusive</code> - the first index to cover, inclusive</dd> <dd>
<code>endExclusive</code> - index immediately past the last index to cover</dd> <dt>Returns:</dt> <dd>an <code>IntStream</code> for the array range</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/arrayindexoutofboundsexception">ArrayIndexOutOfBoundsException</a></code> - if <code>startInclusive</code> is negative, <code>endExclusive</code> is less than <code>startInclusive</code>, or <code>endExclusive</code> is greater than the array size</dd> <dt>Since:</dt> <dd>1.8</dd> </dl>    <h3 id="stream(long[])">stream</h3> <pre data-language="java">public static LongStream stream(long[] array)</pre> <p>Returns a sequential <a href="stream/longstream"><code>LongStream</code></a> with the specified array as its source.</p> <dl> <dt>Parameters:</dt> <dd>
<code>array</code> - the array, assumed to be unmodified during use</dd> <dt>Returns:</dt> <dd>a <code>LongStream</code> for the array</dd> <dt>Since:</dt> <dd>1.8</dd> </dl>    <h3 id="stream(long[],int,int)">stream</h3> <pre data-language="java">public static LongStream stream(long[] array,
                                int startInclusive,
                                int endExclusive)</pre> <p>Returns a sequential <a href="stream/longstream"><code>LongStream</code></a> with the specified range of the specified array as its source.</p> <dl> <dt>Parameters:</dt> <dd>
<code>array</code> - the array, assumed to be unmodified during use</dd> <dd>
<code>startInclusive</code> - the first index to cover, inclusive</dd> <dd>
<code>endExclusive</code> - index immediately past the last index to cover</dd> <dt>Returns:</dt> <dd>a <code>LongStream</code> for the array range</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/arrayindexoutofboundsexception">ArrayIndexOutOfBoundsException</a></code> - if <code>startInclusive</code> is negative, <code>endExclusive</code> is less than <code>startInclusive</code>, or <code>endExclusive</code> is greater than the array size</dd> <dt>Since:</dt> <dd>1.8</dd> </dl>    <h3 id="stream(double[])">stream</h3> <pre data-language="java">public static DoubleStream stream(double[] array)</pre> <p>Returns a sequential <a href="stream/doublestream"><code>DoubleStream</code></a> with the specified array as its source.</p> <dl> <dt>Parameters:</dt> <dd>
<code>array</code> - the array, assumed to be unmodified during use</dd> <dt>Returns:</dt> <dd>a <code>DoubleStream</code> for the array</dd> <dt>Since:</dt> <dd>1.8</dd> </dl>    <h3 id="stream(double[],int,int)">stream</h3> <pre data-language="java">public static DoubleStream stream(double[] array,
                                  int startInclusive,
                                  int endExclusive)</pre> <p>Returns a sequential <a href="stream/doublestream"><code>DoubleStream</code></a> with the specified range of the specified array as its source.</p> <dl> <dt>Parameters:</dt> <dd>
<code>array</code> - the array, assumed to be unmodified during use</dd> <dd>
<code>startInclusive</code> - the first index to cover, inclusive</dd> <dd>
<code>endExclusive</code> - index immediately past the last index to cover</dd> <dt>Returns:</dt> <dd>a <code>DoubleStream</code> for the array range</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/arrayindexoutofboundsexception">ArrayIndexOutOfBoundsException</a></code> - if <code>startInclusive</code> is negative, <code>endExclusive</code> is less than <code>startInclusive</code>, or <code>endExclusive</code> is greater than the array size</dd> <dt>Since:</dt> <dd>1.8</dd> </dl>    <h3 id="compare(boolean[],boolean[])">compare</h3> <pre data-language="java">public static int compare(boolean[] a,
                          boolean[] b)</pre> <div>
<p>Compares two <code>boolean</code> arrays lexicographically. </p>
<p>If the two arrays share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by <a href="../lang/boolean#compare(boolean,boolean)"><code>Boolean.compare(boolean, boolean)</code></a>, at an index within the respective arrays that is the prefix length. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two array lengths. (See <a href="#mismatch(boolean%5B%5D,boolean%5B%5D)"><code>mismatch(boolean[], boolean[])</code></a> for the definition of a common and proper prefix.) </p>
<p>A <code>null</code> array reference is considered lexicographically less than a non-<code>null</code> array reference. Two <code>null</code> array references are considered equal. </p>
<p>The comparison is consistent with <a href="#equals(boolean%5B%5D,boolean%5B%5D)"><code>equals</code></a>, more specifically the following holds for arrays <code>a</code> and <code>b</code>: </p>
<pre data-language="java">Arrays.equals(a, b) == (Arrays.compare(a, b) == 0)</pre>
</div> <dl> <dt>API Note:</dt> <dd>
<p>This method behaves as if (for non-<code>null</code> array references): </p>
<pre data-language="java">int i = Arrays.mismatch(a, b);
     if (i &gt;= 0 &amp;&amp; i &lt; Math.min(a.length, b.length))
         return Boolean.compare(a[i], b[i]);
     return a.length - b.length;</pre>
</dd> <dt>Parameters:</dt> <dd>
<code>a</code> - the first array to compare</dd> <dd>
<code>b</code> - the second array to compare</dd> <dt>Returns:</dt> <dd>the value <code>0</code> if the first and second array are equal and contain the same elements in the same order; a value less than <code>0</code> if the first array is lexicographically less than the second array; and a value greater than <code>0</code> if the first array is lexicographically greater than the second array</dd> <dt>Since:</dt> <dd>9</dd> </dl>    <h3 id="compare(boolean[],int,int,boolean[],int,int)">compare</h3> <pre data-language="java">public static int compare(boolean[] a,
                          int aFromIndex,
                          int aToIndex,
                          boolean[] b,
                          int bFromIndex,
                          int bToIndex)</pre> <div>
<p>Compares two <code>boolean</code> arrays lexicographically over the specified ranges. </p>
<p>If the two arrays, over the specified ranges, share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by <a href="../lang/boolean#compare(boolean,boolean)"><code>Boolean.compare(boolean, boolean)</code></a>, at a relative index within the respective arrays that is the length of the prefix. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two range lengths. (See <a href="#mismatch(boolean%5B%5D,int,int,boolean%5B%5D,int,int)"><code>mismatch(boolean[], int, int, boolean[], int, int)</code></a> for the definition of a common and proper prefix.) </p>
<p>The comparison is consistent with <a href="#equals(boolean%5B%5D,int,int,boolean%5B%5D,int,int)"><code>equals</code></a>, more specifically the following holds for arrays <code>a</code> and <code>b</code> with specified ranges [<code>aFromIndex</code>, <code>atoIndex</code>) and [<code>bFromIndex</code>, <code>btoIndex</code>) respectively: </p>
<pre data-language="java">Arrays.equals(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) ==
         (Arrays.compare(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) == 0)</pre>
</div> <dl> <dt>API Note:</dt> <dd>
<p>This method behaves as if: </p>
<pre data-language="java">int i = Arrays.mismatch(a, aFromIndex, aToIndex,
                             b, bFromIndex, bToIndex);
     if (i &gt;= 0 &amp;&amp; i &lt; Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
         return Boolean.compare(a[aFromIndex + i], b[bFromIndex + i]);
     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);</pre>
</dd> <dt>Parameters:</dt> <dd>
<code>a</code> - the first array to compare</dd> <dd>
<code>aFromIndex</code> - the index (inclusive) of the first element in the first array to be compared</dd> <dd>
<code>aToIndex</code> - the index (exclusive) of the last element in the first array to be compared</dd> <dd>
<code>b</code> - the second array to compare</dd> <dd>
<code>bFromIndex</code> - the index (inclusive) of the first element in the second array to be compared</dd> <dd>
<code>bToIndex</code> - the index (exclusive) of the last element in the second array to be compared</dd> <dt>Returns:</dt> <dd>the value <code>0</code> if, over the specified ranges, the first and second array are equal and contain the same elements in the same order; a value less than <code>0</code> if, over the specified ranges, the first array is lexicographically less than the second array; and a value greater than <code>0</code> if, over the specified ranges, the first array is lexicographically greater than the second array</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - if <code>aFromIndex &gt; aToIndex</code> or if <code>bFromIndex &gt; bToIndex</code>
</dd> <dd>
<code><a href="../lang/arrayindexoutofboundsexception">ArrayIndexOutOfBoundsException</a></code> - if <code>aFromIndex &lt; 0 or aToIndex &gt; a.length</code> or if <code>bFromIndex &lt; 0 or bToIndex &gt; b.length</code>
</dd> <dd>
<code><a href="../lang/nullpointerexception">NullPointerException</a></code> - if either array is <code>null</code>
</dd> <dt>Since:</dt> <dd>9</dd> </dl>    <h3 id="compare(byte[],byte[])">compare</h3> <pre data-language="java">public static int compare(byte[] a,
                          byte[] b)</pre> <div>
<p>Compares two <code>byte</code> arrays lexicographically. </p>
<p>If the two arrays share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by <a href="../lang/byte#compare(byte,byte)"><code>Byte.compare(byte, byte)</code></a>, at an index within the respective arrays that is the prefix length. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two array lengths. (See <a href="#mismatch(byte%5B%5D,byte%5B%5D)"><code>mismatch(byte[], byte[])</code></a> for the definition of a common and proper prefix.) </p>
<p>A <code>null</code> array reference is considered lexicographically less than a non-<code>null</code> array reference. Two <code>null</code> array references are considered equal. </p>
<p>The comparison is consistent with <a href="#equals(byte%5B%5D,byte%5B%5D)"><code>equals</code></a>, more specifically the following holds for arrays <code>a</code> and <code>b</code>: </p>
<pre data-language="java">Arrays.equals(a, b) == (Arrays.compare(a, b) == 0)</pre>
</div> <dl> <dt>API Note:</dt> <dd>
<p>This method behaves as if (for non-<code>null</code> array references): </p>
<pre data-language="java">int i = Arrays.mismatch(a, b);
     if (i &gt;= 0 &amp;&amp; i &lt; Math.min(a.length, b.length))
         return Byte.compare(a[i], b[i]);
     return a.length - b.length;</pre>
</dd> <dt>Parameters:</dt> <dd>
<code>a</code> - the first array to compare</dd> <dd>
<code>b</code> - the second array to compare</dd> <dt>Returns:</dt> <dd>the value <code>0</code> if the first and second array are equal and contain the same elements in the same order; a value less than <code>0</code> if the first array is lexicographically less than the second array; and a value greater than <code>0</code> if the first array is lexicographically greater than the second array</dd> <dt>Since:</dt> <dd>9</dd> </dl>    <h3 id="compare(byte[],int,int,byte[],int,int)">compare</h3> <pre data-language="java">public static int compare(byte[] a,
                          int aFromIndex,
                          int aToIndex,
                          byte[] b,
                          int bFromIndex,
                          int bToIndex)</pre> <div>
<p>Compares two <code>byte</code> arrays lexicographically over the specified ranges. </p>
<p>If the two arrays, over the specified ranges, share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by <a href="../lang/byte#compare(byte,byte)"><code>Byte.compare(byte, byte)</code></a>, at a relative index within the respective arrays that is the length of the prefix. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two range lengths. (See <a href="#mismatch(byte%5B%5D,int,int,byte%5B%5D,int,int)"><code>mismatch(byte[], int, int, byte[], int, int)</code></a> for the definition of a common and proper prefix.) </p>
<p>The comparison is consistent with <a href="#equals(byte%5B%5D,int,int,byte%5B%5D,int,int)"><code>equals</code></a>, more specifically the following holds for arrays <code>a</code> and <code>b</code> with specified ranges [<code>aFromIndex</code>, <code>atoIndex</code>) and [<code>bFromIndex</code>, <code>btoIndex</code>) respectively: </p>
<pre data-language="java">Arrays.equals(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) ==
         (Arrays.compare(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) == 0)</pre>
</div> <dl> <dt>API Note:</dt> <dd>
<p>This method behaves as if: </p>
<pre data-language="java">int i = Arrays.mismatch(a, aFromIndex, aToIndex,
                             b, bFromIndex, bToIndex);
     if (i &gt;= 0 &amp;&amp; i &lt; Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
         return Byte.compare(a[aFromIndex + i], b[bFromIndex + i]);
     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);</pre>
</dd> <dt>Parameters:</dt> <dd>
<code>a</code> - the first array to compare</dd> <dd>
<code>aFromIndex</code> - the index (inclusive) of the first element in the first array to be compared</dd> <dd>
<code>aToIndex</code> - the index (exclusive) of the last element in the first array to be compared</dd> <dd>
<code>b</code> - the second array to compare</dd> <dd>
<code>bFromIndex</code> - the index (inclusive) of the first element in the second array to be compared</dd> <dd>
<code>bToIndex</code> - the index (exclusive) of the last element in the second array to be compared</dd> <dt>Returns:</dt> <dd>the value <code>0</code> if, over the specified ranges, the first and second array are equal and contain the same elements in the same order; a value less than <code>0</code> if, over the specified ranges, the first array is lexicographically less than the second array; and a value greater than <code>0</code> if, over the specified ranges, the first array is lexicographically greater than the second array</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - if <code>aFromIndex &gt; aToIndex</code> or if <code>bFromIndex &gt; bToIndex</code>
</dd> <dd>
<code><a href="../lang/arrayindexoutofboundsexception">ArrayIndexOutOfBoundsException</a></code> - if <code>aFromIndex &lt; 0 or aToIndex &gt; a.length</code> or if <code>bFromIndex &lt; 0 or bToIndex &gt; b.length</code>
</dd> <dd>
<code><a href="../lang/nullpointerexception">NullPointerException</a></code> - if either array is <code>null</code>
</dd> <dt>Since:</dt> <dd>9</dd> </dl>    <h3 id="compareUnsigned(byte[],byte[])">compareUnsigned</h3> <pre data-language="java">public static int compareUnsigned(byte[] a,
                                  byte[] b)</pre> <div>
<p>Compares two <code>byte</code> arrays lexicographically, numerically treating elements as unsigned. </p>
<p>If the two arrays share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by <a href="../lang/byte#compareUnsigned(byte,byte)"><code>Byte.compareUnsigned(byte, byte)</code></a>, at an index within the respective arrays that is the prefix length. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two array lengths. (See <a href="#mismatch(byte%5B%5D,byte%5B%5D)"><code>mismatch(byte[], byte[])</code></a> for the definition of a common and proper prefix.) </p>
<p>A <code>null</code> array reference is considered lexicographically less than a non-<code>null</code> array reference. Two <code>null</code> array references are considered equal.</p>
</div> <dl> <dt>API Note:</dt> <dd>
<p>This method behaves as if (for non-<code>null</code> array references): </p>
<pre data-language="java">int i = Arrays.mismatch(a, b);
     if (i &gt;= 0 &amp;&amp; i &lt; Math.min(a.length, b.length))
         return Byte.compareUnsigned(a[i], b[i]);
     return a.length - b.length;</pre>
</dd> <dt>Parameters:</dt> <dd>
<code>a</code> - the first array to compare</dd> <dd>
<code>b</code> - the second array to compare</dd> <dt>Returns:</dt> <dd>the value <code>0</code> if the first and second array are equal and contain the same elements in the same order; a value less than <code>0</code> if the first array is lexicographically less than the second array; and a value greater than <code>0</code> if the first array is lexicographically greater than the second array</dd> <dt>Since:</dt> <dd>9</dd> </dl>    <h3 id="compareUnsigned(byte[],int,int,byte[],int,int)">compareUnsigned</h3> <pre data-language="java">public static int compareUnsigned(byte[] a,
                                  int aFromIndex,
                                  int aToIndex,
                                  byte[] b,
                                  int bFromIndex,
                                  int bToIndex)</pre> <div>
<p>Compares two <code>byte</code> arrays lexicographically over the specified ranges, numerically treating elements as unsigned. </p>
<p>If the two arrays, over the specified ranges, share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by <a href="../lang/byte#compareUnsigned(byte,byte)"><code>Byte.compareUnsigned(byte, byte)</code></a>, at a relative index within the respective arrays that is the length of the prefix. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two range lengths. (See <a href="#mismatch(byte%5B%5D,int,int,byte%5B%5D,int,int)"><code>mismatch(byte[], int, int, byte[], int, int)</code></a> for the definition of a common and proper prefix.)</p>
</div> <dl> <dt>API Note:</dt> <dd>
<p>This method behaves as if: </p>
<pre data-language="java">int i = Arrays.mismatch(a, aFromIndex, aToIndex,
                             b, bFromIndex, bToIndex);
     if (i &gt;= 0 &amp;&amp; i &lt; Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
         return Byte.compareUnsigned(a[aFromIndex + i], b[bFromIndex + i]);
     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);</pre>
</dd> <dt>Parameters:</dt> <dd>
<code>a</code> - the first array to compare</dd> <dd>
<code>aFromIndex</code> - the index (inclusive) of the first element in the first array to be compared</dd> <dd>
<code>aToIndex</code> - the index (exclusive) of the last element in the first array to be compared</dd> <dd>
<code>b</code> - the second array to compare</dd> <dd>
<code>bFromIndex</code> - the index (inclusive) of the first element in the second array to be compared</dd> <dd>
<code>bToIndex</code> - the index (exclusive) of the last element in the second array to be compared</dd> <dt>Returns:</dt> <dd>the value <code>0</code> if, over the specified ranges, the first and second array are equal and contain the same elements in the same order; a value less than <code>0</code> if, over the specified ranges, the first array is lexicographically less than the second array; and a value greater than <code>0</code> if, over the specified ranges, the first array is lexicographically greater than the second array</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - if <code>aFromIndex &gt; aToIndex</code> or if <code>bFromIndex &gt; bToIndex</code>
</dd> <dd>
<code><a href="../lang/arrayindexoutofboundsexception">ArrayIndexOutOfBoundsException</a></code> - if <code>aFromIndex &lt; 0 or aToIndex &gt; a.length</code> or if <code>bFromIndex &lt; 0 or bToIndex &gt; b.length</code>
</dd> <dd>
<code><a href="../lang/nullpointerexception">NullPointerException</a></code> - if either array is null</dd> <dt>Since:</dt> <dd>9</dd> </dl>    <h3 id="compare(short[],short[])">compare</h3> <pre data-language="java">public static int compare(short[] a,
                          short[] b)</pre> <div>
<p>Compares two <code>short</code> arrays lexicographically. </p>
<p>If the two arrays share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by <a href="../lang/short#compare(short,short)"><code>Short.compare(short, short)</code></a>, at an index within the respective arrays that is the prefix length. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two array lengths. (See <a href="#mismatch(short%5B%5D,short%5B%5D)"><code>mismatch(short[], short[])</code></a> for the definition of a common and proper prefix.) </p>
<p>A <code>null</code> array reference is considered lexicographically less than a non-<code>null</code> array reference. Two <code>null</code> array references are considered equal. </p>
<p>The comparison is consistent with <a href="#equals(short%5B%5D,short%5B%5D)"><code>equals</code></a>, more specifically the following holds for arrays <code>a</code> and <code>b</code>: </p>
<pre data-language="java">Arrays.equals(a, b) == (Arrays.compare(a, b) == 0)</pre>
</div> <dl> <dt>API Note:</dt> <dd>
<p>This method behaves as if (for non-<code>null</code> array references): </p>
<pre data-language="java">int i = Arrays.mismatch(a, b);
     if (i &gt;= 0 &amp;&amp; i &lt; Math.min(a.length, b.length))
         return Short.compare(a[i], b[i]);
     return a.length - b.length;</pre>
</dd> <dt>Parameters:</dt> <dd>
<code>a</code> - the first array to compare</dd> <dd>
<code>b</code> - the second array to compare</dd> <dt>Returns:</dt> <dd>the value <code>0</code> if the first and second array are equal and contain the same elements in the same order; a value less than <code>0</code> if the first array is lexicographically less than the second array; and a value greater than <code>0</code> if the first array is lexicographically greater than the second array</dd> <dt>Since:</dt> <dd>9</dd> </dl>    <h3 id="compare(short[],int,int,short[],int,int)">compare</h3> <pre data-language="java">public static int compare(short[] a,
                          int aFromIndex,
                          int aToIndex,
                          short[] b,
                          int bFromIndex,
                          int bToIndex)</pre> <div>
<p>Compares two <code>short</code> arrays lexicographically over the specified ranges. </p>
<p>If the two arrays, over the specified ranges, share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by <a href="../lang/short#compare(short,short)"><code>Short.compare(short, short)</code></a>, at a relative index within the respective arrays that is the length of the prefix. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two range lengths. (See <a href="#mismatch(short%5B%5D,int,int,short%5B%5D,int,int)"><code>mismatch(short[], int, int, short[], int, int)</code></a> for the definition of a common and proper prefix.) </p>
<p>The comparison is consistent with <a href="#equals(short%5B%5D,int,int,short%5B%5D,int,int)"><code>equals</code></a>, more specifically the following holds for arrays <code>a</code> and <code>b</code> with specified ranges [<code>aFromIndex</code>, <code>atoIndex</code>) and [<code>bFromIndex</code>, <code>btoIndex</code>) respectively: </p>
<pre data-language="java">Arrays.equals(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) ==
         (Arrays.compare(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) == 0)</pre>
</div> <dl> <dt>API Note:</dt> <dd>
<p>This method behaves as if: </p>
<pre data-language="java">int i = Arrays.mismatch(a, aFromIndex, aToIndex,
                             b, bFromIndex, bToIndex);
     if (i &gt;= 0 &amp;&amp; i &lt; Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
         return Short.compare(a[aFromIndex + i], b[bFromIndex + i]);
     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);</pre>
</dd> <dt>Parameters:</dt> <dd>
<code>a</code> - the first array to compare</dd> <dd>
<code>aFromIndex</code> - the index (inclusive) of the first element in the first array to be compared</dd> <dd>
<code>aToIndex</code> - the index (exclusive) of the last element in the first array to be compared</dd> <dd>
<code>b</code> - the second array to compare</dd> <dd>
<code>bFromIndex</code> - the index (inclusive) of the first element in the second array to be compared</dd> <dd>
<code>bToIndex</code> - the index (exclusive) of the last element in the second array to be compared</dd> <dt>Returns:</dt> <dd>the value <code>0</code> if, over the specified ranges, the first and second array are equal and contain the same elements in the same order; a value less than <code>0</code> if, over the specified ranges, the first array is lexicographically less than the second array; and a value greater than <code>0</code> if, over the specified ranges, the first array is lexicographically greater than the second array</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - if <code>aFromIndex &gt; aToIndex</code> or if <code>bFromIndex &gt; bToIndex</code>
</dd> <dd>
<code><a href="../lang/arrayindexoutofboundsexception">ArrayIndexOutOfBoundsException</a></code> - if <code>aFromIndex &lt; 0 or aToIndex &gt; a.length</code> or if <code>bFromIndex &lt; 0 or bToIndex &gt; b.length</code>
</dd> <dd>
<code><a href="../lang/nullpointerexception">NullPointerException</a></code> - if either array is <code>null</code>
</dd> <dt>Since:</dt> <dd>9</dd> </dl>    <h3 id="compareUnsigned(short[],short[])">compareUnsigned</h3> <pre data-language="java">public static int compareUnsigned(short[] a,
                                  short[] b)</pre> <div>
<p>Compares two <code>short</code> arrays lexicographically, numerically treating elements as unsigned. </p>
<p>If the two arrays share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by <a href="../lang/short#compareUnsigned(short,short)"><code>Short.compareUnsigned(short, short)</code></a>, at an index within the respective arrays that is the prefix length. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two array lengths. (See <a href="#mismatch(short%5B%5D,short%5B%5D)"><code>mismatch(short[], short[])</code></a> for the definition of a common and proper prefix.) </p>
<p>A <code>null</code> array reference is considered lexicographically less than a non-<code>null</code> array reference. Two <code>null</code> array references are considered equal.</p>
</div> <dl> <dt>API Note:</dt> <dd>
<p>This method behaves as if (for non-<code>null</code> array references): </p>
<pre data-language="java">int i = Arrays.mismatch(a, b);
     if (i &gt;= 0 &amp;&amp; i &lt; Math.min(a.length, b.length))
         return Short.compareUnsigned(a[i], b[i]);
     return a.length - b.length;</pre>
</dd> <dt>Parameters:</dt> <dd>
<code>a</code> - the first array to compare</dd> <dd>
<code>b</code> - the second array to compare</dd> <dt>Returns:</dt> <dd>the value <code>0</code> if the first and second array are equal and contain the same elements in the same order; a value less than <code>0</code> if the first array is lexicographically less than the second array; and a value greater than <code>0</code> if the first array is lexicographically greater than the second array</dd> <dt>Since:</dt> <dd>9</dd> </dl>    <h3 id="compareUnsigned(short[],int,int,short[],int,int)">compareUnsigned</h3> <pre data-language="java">public static int compareUnsigned(short[] a,
                                  int aFromIndex,
                                  int aToIndex,
                                  short[] b,
                                  int bFromIndex,
                                  int bToIndex)</pre> <div>
<p>Compares two <code>short</code> arrays lexicographically over the specified ranges, numerically treating elements as unsigned. </p>
<p>If the two arrays, over the specified ranges, share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by <a href="../lang/short#compareUnsigned(short,short)"><code>Short.compareUnsigned(short, short)</code></a>, at a relative index within the respective arrays that is the length of the prefix. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two range lengths. (See <a href="#mismatch(short%5B%5D,int,int,short%5B%5D,int,int)"><code>mismatch(short[], int, int, short[], int, int)</code></a> for the definition of a common and proper prefix.)</p>
</div> <dl> <dt>API Note:</dt> <dd>
<p>This method behaves as if: </p>
<pre data-language="java">int i = Arrays.mismatch(a, aFromIndex, aToIndex,
                             b, bFromIndex, bToIndex);
     if (i &gt;= 0 &amp;&amp; i &lt; Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
         return Short.compareUnsigned(a[aFromIndex + i], b[bFromIndex + i]);
     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);</pre>
</dd> <dt>Parameters:</dt> <dd>
<code>a</code> - the first array to compare</dd> <dd>
<code>aFromIndex</code> - the index (inclusive) of the first element in the first array to be compared</dd> <dd>
<code>aToIndex</code> - the index (exclusive) of the last element in the first array to be compared</dd> <dd>
<code>b</code> - the second array to compare</dd> <dd>
<code>bFromIndex</code> - the index (inclusive) of the first element in the second array to be compared</dd> <dd>
<code>bToIndex</code> - the index (exclusive) of the last element in the second array to be compared</dd> <dt>Returns:</dt> <dd>the value <code>0</code> if, over the specified ranges, the first and second array are equal and contain the same elements in the same order; a value less than <code>0</code> if, over the specified ranges, the first array is lexicographically less than the second array; and a value greater than <code>0</code> if, over the specified ranges, the first array is lexicographically greater than the second array</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - if <code>aFromIndex &gt; aToIndex</code> or if <code>bFromIndex &gt; bToIndex</code>
</dd> <dd>
<code><a href="../lang/arrayindexoutofboundsexception">ArrayIndexOutOfBoundsException</a></code> - if <code>aFromIndex &lt; 0 or aToIndex &gt; a.length</code> or if <code>bFromIndex &lt; 0 or bToIndex &gt; b.length</code>
</dd> <dd>
<code><a href="../lang/nullpointerexception">NullPointerException</a></code> - if either array is null</dd> <dt>Since:</dt> <dd>9</dd> </dl>    <h3 id="compare(char[],char[])">compare</h3> <pre data-language="java">public static int compare(char[] a,
                          char[] b)</pre> <div>
<p>Compares two <code>char</code> arrays lexicographically. </p>
<p>If the two arrays share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by <a href="../lang/character#compare(char,char)"><code>Character.compare(char, char)</code></a>, at an index within the respective arrays that is the prefix length. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two array lengths. (See <a href="#mismatch(char%5B%5D,char%5B%5D)"><code>mismatch(char[], char[])</code></a> for the definition of a common and proper prefix.) </p>
<p>A <code>null</code> array reference is considered lexicographically less than a non-<code>null</code> array reference. Two <code>null</code> array references are considered equal. </p>
<p>The comparison is consistent with <a href="#equals(char%5B%5D,char%5B%5D)"><code>equals</code></a>, more specifically the following holds for arrays <code>a</code> and <code>b</code>: </p>
<pre data-language="java">Arrays.equals(a, b) == (Arrays.compare(a, b) == 0)</pre>
</div> <dl> <dt>API Note:</dt> <dd>
<p>This method behaves as if (for non-<code>null</code> array references): </p>
<pre data-language="java">int i = Arrays.mismatch(a, b);
     if (i &gt;= 0 &amp;&amp; i &lt; Math.min(a.length, b.length))
         return Character.compare(a[i], b[i]);
     return a.length - b.length;</pre>
</dd> <dt>Parameters:</dt> <dd>
<code>a</code> - the first array to compare</dd> <dd>
<code>b</code> - the second array to compare</dd> <dt>Returns:</dt> <dd>the value <code>0</code> if the first and second array are equal and contain the same elements in the same order; a value less than <code>0</code> if the first array is lexicographically less than the second array; and a value greater than <code>0</code> if the first array is lexicographically greater than the second array</dd> <dt>Since:</dt> <dd>9</dd> </dl>    <h3 id="compare(char[],int,int,char[],int,int)">compare</h3> <pre data-language="java">public static int compare(char[] a,
                          int aFromIndex,
                          int aToIndex,
                          char[] b,
                          int bFromIndex,
                          int bToIndex)</pre> <div>
<p>Compares two <code>char</code> arrays lexicographically over the specified ranges. </p>
<p>If the two arrays, over the specified ranges, share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by <a href="../lang/character#compare(char,char)"><code>Character.compare(char, char)</code></a>, at a relative index within the respective arrays that is the length of the prefix. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two range lengths. (See <a href="#mismatch(char%5B%5D,int,int,char%5B%5D,int,int)"><code>mismatch(char[], int, int, char[], int, int)</code></a> for the definition of a common and proper prefix.) </p>
<p>The comparison is consistent with <a href="#equals(char%5B%5D,int,int,char%5B%5D,int,int)"><code>equals</code></a>, more specifically the following holds for arrays <code>a</code> and <code>b</code> with specified ranges [<code>aFromIndex</code>, <code>atoIndex</code>) and [<code>bFromIndex</code>, <code>btoIndex</code>) respectively: </p>
<pre data-language="java">Arrays.equals(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) ==
         (Arrays.compare(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) == 0)</pre>
</div> <dl> <dt>API Note:</dt> <dd>
<p>This method behaves as if: </p>
<pre data-language="java">int i = Arrays.mismatch(a, aFromIndex, aToIndex,
                             b, bFromIndex, bToIndex);
     if (i &gt;= 0 &amp;&amp; i &lt; Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
         return Character.compare(a[aFromIndex + i], b[bFromIndex + i]);
     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);</pre>
</dd> <dt>Parameters:</dt> <dd>
<code>a</code> - the first array to compare</dd> <dd>
<code>aFromIndex</code> - the index (inclusive) of the first element in the first array to be compared</dd> <dd>
<code>aToIndex</code> - the index (exclusive) of the last element in the first array to be compared</dd> <dd>
<code>b</code> - the second array to compare</dd> <dd>
<code>bFromIndex</code> - the index (inclusive) of the first element in the second array to be compared</dd> <dd>
<code>bToIndex</code> - the index (exclusive) of the last element in the second array to be compared</dd> <dt>Returns:</dt> <dd>the value <code>0</code> if, over the specified ranges, the first and second array are equal and contain the same elements in the same order; a value less than <code>0</code> if, over the specified ranges, the first array is lexicographically less than the second array; and a value greater than <code>0</code> if, over the specified ranges, the first array is lexicographically greater than the second array</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - if <code>aFromIndex &gt; aToIndex</code> or if <code>bFromIndex &gt; bToIndex</code>
</dd> <dd>
<code><a href="../lang/arrayindexoutofboundsexception">ArrayIndexOutOfBoundsException</a></code> - if <code>aFromIndex &lt; 0 or aToIndex &gt; a.length</code> or if <code>bFromIndex &lt; 0 or bToIndex &gt; b.length</code>
</dd> <dd>
<code><a href="../lang/nullpointerexception">NullPointerException</a></code> - if either array is <code>null</code>
</dd> <dt>Since:</dt> <dd>9</dd> </dl>    <h3 id="compare(int[],int[])">compare</h3> <pre data-language="java">public static int compare(int[] a,
                          int[] b)</pre> <div>
<p>Compares two <code>int</code> arrays lexicographically. </p>
<p>If the two arrays share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by <a href="../lang/integer#compare(int,int)"><code>Integer.compare(int, int)</code></a>, at an index within the respective arrays that is the prefix length. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two array lengths. (See <a href="#mismatch(int%5B%5D,int%5B%5D)"><code>mismatch(int[], int[])</code></a> for the definition of a common and proper prefix.) </p>
<p>A <code>null</code> array reference is considered lexicographically less than a non-<code>null</code> array reference. Two <code>null</code> array references are considered equal. </p>
<p>The comparison is consistent with <a href="#equals(int%5B%5D,int%5B%5D)"><code>equals</code></a>, more specifically the following holds for arrays <code>a</code> and <code>b</code>: </p>
<pre data-language="java">Arrays.equals(a, b) == (Arrays.compare(a, b) == 0)</pre>
</div> <dl> <dt>API Note:</dt> <dd>
<p>This method behaves as if (for non-<code>null</code> array references): </p>
<pre data-language="java">int i = Arrays.mismatch(a, b);
     if (i &gt;= 0 &amp;&amp; i &lt; Math.min(a.length, b.length))
         return Integer.compare(a[i], b[i]);
     return a.length - b.length;</pre>
</dd> <dt>Parameters:</dt> <dd>
<code>a</code> - the first array to compare</dd> <dd>
<code>b</code> - the second array to compare</dd> <dt>Returns:</dt> <dd>the value <code>0</code> if the first and second array are equal and contain the same elements in the same order; a value less than <code>0</code> if the first array is lexicographically less than the second array; and a value greater than <code>0</code> if the first array is lexicographically greater than the second array</dd> <dt>Since:</dt> <dd>9</dd> </dl>    <h3 id="compare(int[],int,int,int[],int,int)">compare</h3> <pre data-language="java">public static int compare(int[] a,
                          int aFromIndex,
                          int aToIndex,
                          int[] b,
                          int bFromIndex,
                          int bToIndex)</pre> <div>
<p>Compares two <code>int</code> arrays lexicographically over the specified ranges. </p>
<p>If the two arrays, over the specified ranges, share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by <a href="../lang/integer#compare(int,int)"><code>Integer.compare(int, int)</code></a>, at a relative index within the respective arrays that is the length of the prefix. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two range lengths. (See <a href="#mismatch(int%5B%5D,int,int,int%5B%5D,int,int)"><code>mismatch(int[], int, int, int[], int, int)</code></a> for the definition of a common and proper prefix.) </p>
<p>The comparison is consistent with <a href="#equals(int%5B%5D,int,int,int%5B%5D,int,int)"><code>equals</code></a>, more specifically the following holds for arrays <code>a</code> and <code>b</code> with specified ranges [<code>aFromIndex</code>, <code>atoIndex</code>) and [<code>bFromIndex</code>, <code>btoIndex</code>) respectively: </p>
<pre data-language="java">Arrays.equals(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) ==
         (Arrays.compare(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) == 0)</pre>
</div> <dl> <dt>API Note:</dt> <dd>
<p>This method behaves as if: </p>
<pre data-language="java">int i = Arrays.mismatch(a, aFromIndex, aToIndex,
                             b, bFromIndex, bToIndex);
     if (i &gt;= 0 &amp;&amp; i &lt; Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
         return Integer.compare(a[aFromIndex + i], b[bFromIndex + i]);
     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);</pre>
</dd> <dt>Parameters:</dt> <dd>
<code>a</code> - the first array to compare</dd> <dd>
<code>aFromIndex</code> - the index (inclusive) of the first element in the first array to be compared</dd> <dd>
<code>aToIndex</code> - the index (exclusive) of the last element in the first array to be compared</dd> <dd>
<code>b</code> - the second array to compare</dd> <dd>
<code>bFromIndex</code> - the index (inclusive) of the first element in the second array to be compared</dd> <dd>
<code>bToIndex</code> - the index (exclusive) of the last element in the second array to be compared</dd> <dt>Returns:</dt> <dd>the value <code>0</code> if, over the specified ranges, the first and second array are equal and contain the same elements in the same order; a value less than <code>0</code> if, over the specified ranges, the first array is lexicographically less than the second array; and a value greater than <code>0</code> if, over the specified ranges, the first array is lexicographically greater than the second array</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - if <code>aFromIndex &gt; aToIndex</code> or if <code>bFromIndex &gt; bToIndex</code>
</dd> <dd>
<code><a href="../lang/arrayindexoutofboundsexception">ArrayIndexOutOfBoundsException</a></code> - if <code>aFromIndex &lt; 0 or aToIndex &gt; a.length</code> or if <code>bFromIndex &lt; 0 or bToIndex &gt; b.length</code>
</dd> <dd>
<code><a href="../lang/nullpointerexception">NullPointerException</a></code> - if either array is <code>null</code>
</dd> <dt>Since:</dt> <dd>9</dd> </dl>    <h3 id="compareUnsigned(int[],int[])">compareUnsigned</h3> <pre data-language="java">public static int compareUnsigned(int[] a,
                                  int[] b)</pre> <div>
<p>Compares two <code>int</code> arrays lexicographically, numerically treating elements as unsigned. </p>
<p>If the two arrays share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by <a href="../lang/integer#compareUnsigned(int,int)"><code>Integer.compareUnsigned(int, int)</code></a>, at an index within the respective arrays that is the prefix length. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two array lengths. (See <a href="#mismatch(int%5B%5D,int%5B%5D)"><code>mismatch(int[], int[])</code></a> for the definition of a common and proper prefix.) </p>
<p>A <code>null</code> array reference is considered lexicographically less than a non-<code>null</code> array reference. Two <code>null</code> array references are considered equal.</p>
</div> <dl> <dt>API Note:</dt> <dd>
<p>This method behaves as if (for non-<code>null</code> array references): </p>
<pre data-language="java">int i = Arrays.mismatch(a, b);
     if (i &gt;= 0 &amp;&amp; i &lt; Math.min(a.length, b.length))
         return Integer.compareUnsigned(a[i], b[i]);
     return a.length - b.length;</pre>
</dd> <dt>Parameters:</dt> <dd>
<code>a</code> - the first array to compare</dd> <dd>
<code>b</code> - the second array to compare</dd> <dt>Returns:</dt> <dd>the value <code>0</code> if the first and second array are equal and contain the same elements in the same order; a value less than <code>0</code> if the first array is lexicographically less than the second array; and a value greater than <code>0</code> if the first array is lexicographically greater than the second array</dd> <dt>Since:</dt> <dd>9</dd> </dl>    <h3 id="compareUnsigned(int[],int,int,int[],int,int)">compareUnsigned</h3> <pre data-language="java">public static int compareUnsigned(int[] a,
                                  int aFromIndex,
                                  int aToIndex,
                                  int[] b,
                                  int bFromIndex,
                                  int bToIndex)</pre> <div>
<p>Compares two <code>int</code> arrays lexicographically over the specified ranges, numerically treating elements as unsigned. </p>
<p>If the two arrays, over the specified ranges, share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by <a href="../lang/integer#compareUnsigned(int,int)"><code>Integer.compareUnsigned(int, int)</code></a>, at a relative index within the respective arrays that is the length of the prefix. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two range lengths. (See <a href="#mismatch(int%5B%5D,int,int,int%5B%5D,int,int)"><code>mismatch(int[], int, int, int[], int, int)</code></a> for the definition of a common and proper prefix.)</p>
</div> <dl> <dt>API Note:</dt> <dd>
<p>This method behaves as if: </p>
<pre data-language="java">int i = Arrays.mismatch(a, aFromIndex, aToIndex,
                             b, bFromIndex, bToIndex);
     if (i &gt;= 0 &amp;&amp; i &lt; Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
         return Integer.compareUnsigned(a[aFromIndex + i], b[bFromIndex + i]);
     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);</pre>
</dd> <dt>Parameters:</dt> <dd>
<code>a</code> - the first array to compare</dd> <dd>
<code>aFromIndex</code> - the index (inclusive) of the first element in the first array to be compared</dd> <dd>
<code>aToIndex</code> - the index (exclusive) of the last element in the first array to be compared</dd> <dd>
<code>b</code> - the second array to compare</dd> <dd>
<code>bFromIndex</code> - the index (inclusive) of the first element in the second array to be compared</dd> <dd>
<code>bToIndex</code> - the index (exclusive) of the last element in the second array to be compared</dd> <dt>Returns:</dt> <dd>the value <code>0</code> if, over the specified ranges, the first and second array are equal and contain the same elements in the same order; a value less than <code>0</code> if, over the specified ranges, the first array is lexicographically less than the second array; and a value greater than <code>0</code> if, over the specified ranges, the first array is lexicographically greater than the second array</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - if <code>aFromIndex &gt; aToIndex</code> or if <code>bFromIndex &gt; bToIndex</code>
</dd> <dd>
<code><a href="../lang/arrayindexoutofboundsexception">ArrayIndexOutOfBoundsException</a></code> - if <code>aFromIndex &lt; 0 or aToIndex &gt; a.length</code> or if <code>bFromIndex &lt; 0 or bToIndex &gt; b.length</code>
</dd> <dd>
<code><a href="../lang/nullpointerexception">NullPointerException</a></code> - if either array is null</dd> <dt>Since:</dt> <dd>9</dd> </dl>    <h3 id="compare(long[],long[])">compare</h3> <pre data-language="java">public static int compare(long[] a,
                          long[] b)</pre> <div>
<p>Compares two <code>long</code> arrays lexicographically. </p>
<p>If the two arrays share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by <a href="../lang/long#compare(long,long)"><code>Long.compare(long, long)</code></a>, at an index within the respective arrays that is the prefix length. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two array lengths. (See <a href="#mismatch(long%5B%5D,long%5B%5D)"><code>mismatch(long[], long[])</code></a> for the definition of a common and proper prefix.) </p>
<p>A <code>null</code> array reference is considered lexicographically less than a non-<code>null</code> array reference. Two <code>null</code> array references are considered equal. </p>
<p>The comparison is consistent with <a href="#equals(long%5B%5D,long%5B%5D)"><code>equals</code></a>, more specifically the following holds for arrays <code>a</code> and <code>b</code>: </p>
<pre data-language="java">Arrays.equals(a, b) == (Arrays.compare(a, b) == 0)</pre>
</div> <dl> <dt>API Note:</dt> <dd>
<p>This method behaves as if (for non-<code>null</code> array references): </p>
<pre data-language="java">int i = Arrays.mismatch(a, b);
     if (i &gt;= 0 &amp;&amp; i &lt; Math.min(a.length, b.length))
         return Long.compare(a[i], b[i]);
     return a.length - b.length;</pre>
</dd> <dt>Parameters:</dt> <dd>
<code>a</code> - the first array to compare</dd> <dd>
<code>b</code> - the second array to compare</dd> <dt>Returns:</dt> <dd>the value <code>0</code> if the first and second array are equal and contain the same elements in the same order; a value less than <code>0</code> if the first array is lexicographically less than the second array; and a value greater than <code>0</code> if the first array is lexicographically greater than the second array</dd> <dt>Since:</dt> <dd>9</dd> </dl>    <h3 id="compare(long[],int,int,long[],int,int)">compare</h3> <pre data-language="java">public static int compare(long[] a,
                          int aFromIndex,
                          int aToIndex,
                          long[] b,
                          int bFromIndex,
                          int bToIndex)</pre> <div>
<p>Compares two <code>long</code> arrays lexicographically over the specified ranges. </p>
<p>If the two arrays, over the specified ranges, share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by <a href="../lang/long#compare(long,long)"><code>Long.compare(long, long)</code></a>, at a relative index within the respective arrays that is the length of the prefix. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two range lengths. (See <a href="#mismatch(long%5B%5D,int,int,long%5B%5D,int,int)"><code>mismatch(long[], int, int, long[], int, int)</code></a> for the definition of a common and proper prefix.) </p>
<p>The comparison is consistent with <a href="#equals(long%5B%5D,int,int,long%5B%5D,int,int)"><code>equals</code></a>, more specifically the following holds for arrays <code>a</code> and <code>b</code> with specified ranges [<code>aFromIndex</code>, <code>atoIndex</code>) and [<code>bFromIndex</code>, <code>btoIndex</code>) respectively: </p>
<pre data-language="java">Arrays.equals(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) ==
         (Arrays.compare(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) == 0)</pre>
</div> <dl> <dt>API Note:</dt> <dd>
<p>This method behaves as if: </p>
<pre data-language="java">int i = Arrays.mismatch(a, aFromIndex, aToIndex,
                             b, bFromIndex, bToIndex);
     if (i &gt;= 0 &amp;&amp; i &lt; Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
         return Long.compare(a[aFromIndex + i], b[bFromIndex + i]);
     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);</pre>
</dd> <dt>Parameters:</dt> <dd>
<code>a</code> - the first array to compare</dd> <dd>
<code>aFromIndex</code> - the index (inclusive) of the first element in the first array to be compared</dd> <dd>
<code>aToIndex</code> - the index (exclusive) of the last element in the first array to be compared</dd> <dd>
<code>b</code> - the second array to compare</dd> <dd>
<code>bFromIndex</code> - the index (inclusive) of the first element in the second array to be compared</dd> <dd>
<code>bToIndex</code> - the index (exclusive) of the last element in the second array to be compared</dd> <dt>Returns:</dt> <dd>the value <code>0</code> if, over the specified ranges, the first and second array are equal and contain the same elements in the same order; a value less than <code>0</code> if, over the specified ranges, the first array is lexicographically less than the second array; and a value greater than <code>0</code> if, over the specified ranges, the first array is lexicographically greater than the second array</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - if <code>aFromIndex &gt; aToIndex</code> or if <code>bFromIndex &gt; bToIndex</code>
</dd> <dd>
<code><a href="../lang/arrayindexoutofboundsexception">ArrayIndexOutOfBoundsException</a></code> - if <code>aFromIndex &lt; 0 or aToIndex &gt; a.length</code> or if <code>bFromIndex &lt; 0 or bToIndex &gt; b.length</code>
</dd> <dd>
<code><a href="../lang/nullpointerexception">NullPointerException</a></code> - if either array is <code>null</code>
</dd> <dt>Since:</dt> <dd>9</dd> </dl>    <h3 id="compareUnsigned(long[],long[])">compareUnsigned</h3> <pre data-language="java">public static int compareUnsigned(long[] a,
                                  long[] b)</pre> <div>
<p>Compares two <code>long</code> arrays lexicographically, numerically treating elements as unsigned. </p>
<p>If the two arrays share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by <a href="../lang/long#compareUnsigned(long,long)"><code>Long.compareUnsigned(long, long)</code></a>, at an index within the respective arrays that is the prefix length. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two array lengths. (See <a href="#mismatch(long%5B%5D,long%5B%5D)"><code>mismatch(long[], long[])</code></a> for the definition of a common and proper prefix.) </p>
<p>A <code>null</code> array reference is considered lexicographically less than a non-<code>null</code> array reference. Two <code>null</code> array references are considered equal.</p>
</div> <dl> <dt>API Note:</dt> <dd>
<p>This method behaves as if (for non-<code>null</code> array references): </p>
<pre data-language="java">int i = Arrays.mismatch(a, b);
     if (i &gt;= 0 &amp;&amp; i &lt; Math.min(a.length, b.length))
         return Long.compareUnsigned(a[i], b[i]);
     return a.length - b.length;</pre>
</dd> <dt>Parameters:</dt> <dd>
<code>a</code> - the first array to compare</dd> <dd>
<code>b</code> - the second array to compare</dd> <dt>Returns:</dt> <dd>the value <code>0</code> if the first and second array are equal and contain the same elements in the same order; a value less than <code>0</code> if the first array is lexicographically less than the second array; and a value greater than <code>0</code> if the first array is lexicographically greater than the second array</dd> <dt>Since:</dt> <dd>9</dd> </dl>    <h3 id="compareUnsigned(long[],int,int,long[],int,int)">compareUnsigned</h3> <pre data-language="java">public static int compareUnsigned(long[] a,
                                  int aFromIndex,
                                  int aToIndex,
                                  long[] b,
                                  int bFromIndex,
                                  int bToIndex)</pre> <div>
<p>Compares two <code>long</code> arrays lexicographically over the specified ranges, numerically treating elements as unsigned. </p>
<p>If the two arrays, over the specified ranges, share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by <a href="../lang/long#compareUnsigned(long,long)"><code>Long.compareUnsigned(long, long)</code></a>, at a relative index within the respective arrays that is the length of the prefix. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two range lengths. (See <a href="#mismatch(long%5B%5D,int,int,long%5B%5D,int,int)"><code>mismatch(long[], int, int, long[], int, int)</code></a> for the definition of a common and proper prefix.)</p>
</div> <dl> <dt>API Note:</dt> <dd>
<p>This method behaves as if: </p>
<pre data-language="java">int i = Arrays.mismatch(a, aFromIndex, aToIndex,
                             b, bFromIndex, bToIndex);
     if (i &gt;= 0 &amp;&amp; i &lt; Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
         return Long.compareUnsigned(a[aFromIndex + i], b[bFromIndex + i]);
     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);</pre>
</dd> <dt>Parameters:</dt> <dd>
<code>a</code> - the first array to compare</dd> <dd>
<code>aFromIndex</code> - the index (inclusive) of the first element in the first array to be compared</dd> <dd>
<code>aToIndex</code> - the index (exclusive) of the last element in the first array to be compared</dd> <dd>
<code>b</code> - the second array to compare</dd> <dd>
<code>bFromIndex</code> - the index (inclusive) of the first element in the second array to be compared</dd> <dd>
<code>bToIndex</code> - the index (exclusive) of the last element in the second array to be compared</dd> <dt>Returns:</dt> <dd>the value <code>0</code> if, over the specified ranges, the first and second array are equal and contain the same elements in the same order; a value less than <code>0</code> if, over the specified ranges, the first array is lexicographically less than the second array; and a value greater than <code>0</code> if, over the specified ranges, the first array is lexicographically greater than the second array</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - if <code>aFromIndex &gt; aToIndex</code> or if <code>bFromIndex &gt; bToIndex</code>
</dd> <dd>
<code><a href="../lang/arrayindexoutofboundsexception">ArrayIndexOutOfBoundsException</a></code> - if <code>aFromIndex &lt; 0 or aToIndex &gt; a.length</code> or if <code>bFromIndex &lt; 0 or bToIndex &gt; b.length</code>
</dd> <dd>
<code><a href="../lang/nullpointerexception">NullPointerException</a></code> - if either array is null</dd> <dt>Since:</dt> <dd>9</dd> </dl>    <h3 id="compare(float[],float[])">compare</h3> <pre data-language="java">public static int compare(float[] a,
                          float[] b)</pre> <div>
<p>Compares two <code>float</code> arrays lexicographically. </p>
<p>If the two arrays share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by <a href="../lang/float#compare(float,float)"><code>Float.compare(float, float)</code></a>, at an index within the respective arrays that is the prefix length. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two array lengths. (See <a href="#mismatch(float%5B%5D,float%5B%5D)"><code>mismatch(float[], float[])</code></a> for the definition of a common and proper prefix.) </p>
<p>A <code>null</code> array reference is considered lexicographically less than a non-<code>null</code> array reference. Two <code>null</code> array references are considered equal. </p>
<p>The comparison is consistent with <a href="#equals(float%5B%5D,float%5B%5D)"><code>equals</code></a>, more specifically the following holds for arrays <code>a</code> and <code>b</code>: </p>
<pre data-language="java">Arrays.equals(a, b) == (Arrays.compare(a, b) == 0)</pre>
</div> <dl> <dt>API Note:</dt> <dd>
<p>This method behaves as if (for non-<code>null</code> array references): </p>
<pre data-language="java">int i = Arrays.mismatch(a, b);
     if (i &gt;= 0 &amp;&amp; i &lt; Math.min(a.length, b.length))
         return Float.compare(a[i], b[i]);
     return a.length - b.length;</pre>
</dd> <dt>Parameters:</dt> <dd>
<code>a</code> - the first array to compare</dd> <dd>
<code>b</code> - the second array to compare</dd> <dt>Returns:</dt> <dd>the value <code>0</code> if the first and second array are equal and contain the same elements in the same order; a value less than <code>0</code> if the first array is lexicographically less than the second array; and a value greater than <code>0</code> if the first array is lexicographically greater than the second array</dd> <dt>Since:</dt> <dd>9</dd> </dl>    <h3 id="compare(float[],int,int,float[],int,int)">compare</h3> <pre data-language="java">public static int compare(float[] a,
                          int aFromIndex,
                          int aToIndex,
                          float[] b,
                          int bFromIndex,
                          int bToIndex)</pre> <div>
<p>Compares two <code>float</code> arrays lexicographically over the specified ranges. </p>
<p>If the two arrays, over the specified ranges, share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by <a href="../lang/float#compare(float,float)"><code>Float.compare(float, float)</code></a>, at a relative index within the respective arrays that is the length of the prefix. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two range lengths. (See <a href="#mismatch(float%5B%5D,int,int,float%5B%5D,int,int)"><code>mismatch(float[], int, int, float[], int, int)</code></a> for the definition of a common and proper prefix.) </p>
<p>The comparison is consistent with <a href="#equals(float%5B%5D,int,int,float%5B%5D,int,int)"><code>equals</code></a>, more specifically the following holds for arrays <code>a</code> and <code>b</code> with specified ranges [<code>aFromIndex</code>, <code>atoIndex</code>) and [<code>bFromIndex</code>, <code>btoIndex</code>) respectively: </p>
<pre data-language="java">Arrays.equals(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) ==
         (Arrays.compare(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) == 0)</pre>
</div> <dl> <dt>API Note:</dt> <dd>
<p>This method behaves as if: </p>
<pre data-language="java">int i = Arrays.mismatch(a, aFromIndex, aToIndex,
                             b, bFromIndex, bToIndex);
     if (i &gt;= 0 &amp;&amp; i &lt; Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
         return Float.compare(a[aFromIndex + i], b[bFromIndex + i]);
     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);</pre>
</dd> <dt>Parameters:</dt> <dd>
<code>a</code> - the first array to compare</dd> <dd>
<code>aFromIndex</code> - the index (inclusive) of the first element in the first array to be compared</dd> <dd>
<code>aToIndex</code> - the index (exclusive) of the last element in the first array to be compared</dd> <dd>
<code>b</code> - the second array to compare</dd> <dd>
<code>bFromIndex</code> - the index (inclusive) of the first element in the second array to be compared</dd> <dd>
<code>bToIndex</code> - the index (exclusive) of the last element in the second array to be compared</dd> <dt>Returns:</dt> <dd>the value <code>0</code> if, over the specified ranges, the first and second array are equal and contain the same elements in the same order; a value less than <code>0</code> if, over the specified ranges, the first array is lexicographically less than the second array; and a value greater than <code>0</code> if, over the specified ranges, the first array is lexicographically greater than the second array</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - if <code>aFromIndex &gt; aToIndex</code> or if <code>bFromIndex &gt; bToIndex</code>
</dd> <dd>
<code><a href="../lang/arrayindexoutofboundsexception">ArrayIndexOutOfBoundsException</a></code> - if <code>aFromIndex &lt; 0 or aToIndex &gt; a.length</code> or if <code>bFromIndex &lt; 0 or bToIndex &gt; b.length</code>
</dd> <dd>
<code><a href="../lang/nullpointerexception">NullPointerException</a></code> - if either array is <code>null</code>
</dd> <dt>Since:</dt> <dd>9</dd> </dl>    <h3 id="compare(double[],double[])">compare</h3> <pre data-language="java">public static int compare(double[] a,
                          double[] b)</pre> <div>
<p>Compares two <code>double</code> arrays lexicographically. </p>
<p>If the two arrays share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by <a href="../lang/double#compare(double,double)"><code>Double.compare(double, double)</code></a>, at an index within the respective arrays that is the prefix length. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two array lengths. (See <a href="#mismatch(double%5B%5D,double%5B%5D)"><code>mismatch(double[], double[])</code></a> for the definition of a common and proper prefix.) </p>
<p>A <code>null</code> array reference is considered lexicographically less than a non-<code>null</code> array reference. Two <code>null</code> array references are considered equal. </p>
<p>The comparison is consistent with <a href="#equals(double%5B%5D,double%5B%5D)"><code>equals</code></a>, more specifically the following holds for arrays <code>a</code> and <code>b</code>: </p>
<pre data-language="java">Arrays.equals(a, b) == (Arrays.compare(a, b) == 0)</pre>
</div> <dl> <dt>API Note:</dt> <dd>
<p>This method behaves as if (for non-<code>null</code> array references): </p>
<pre data-language="java">int i = Arrays.mismatch(a, b);
     if (i &gt;= 0 &amp;&amp; i &lt; Math.min(a.length, b.length))
         return Double.compare(a[i], b[i]);
     return a.length - b.length;</pre>
</dd> <dt>Parameters:</dt> <dd>
<code>a</code> - the first array to compare</dd> <dd>
<code>b</code> - the second array to compare</dd> <dt>Returns:</dt> <dd>the value <code>0</code> if the first and second array are equal and contain the same elements in the same order; a value less than <code>0</code> if the first array is lexicographically less than the second array; and a value greater than <code>0</code> if the first array is lexicographically greater than the second array</dd> <dt>Since:</dt> <dd>9</dd> </dl>    <h3 id="compare(double[],int,int,double[],int,int)">compare</h3> <pre data-language="java">public static int compare(double[] a,
                          int aFromIndex,
                          int aToIndex,
                          double[] b,
                          int bFromIndex,
                          int bToIndex)</pre> <div>
<p>Compares two <code>double</code> arrays lexicographically over the specified ranges. </p>
<p>If the two arrays, over the specified ranges, share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by <a href="../lang/double#compare(double,double)"><code>Double.compare(double, double)</code></a>, at a relative index within the respective arrays that is the length of the prefix. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two range lengths. (See <a href="#mismatch(double%5B%5D,int,int,double%5B%5D,int,int)"><code>mismatch(double[], int, int, double[], int, int)</code></a> for the definition of a common and proper prefix.) </p>
<p>The comparison is consistent with <a href="#equals(double%5B%5D,int,int,double%5B%5D,int,int)"><code>equals</code></a>, more specifically the following holds for arrays <code>a</code> and <code>b</code> with specified ranges [<code>aFromIndex</code>, <code>atoIndex</code>) and [<code>bFromIndex</code>, <code>btoIndex</code>) respectively: </p>
<pre data-language="java">Arrays.equals(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) ==
         (Arrays.compare(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) == 0)</pre>
</div> <dl> <dt>API Note:</dt> <dd>
<p>This method behaves as if: </p>
<pre data-language="java">int i = Arrays.mismatch(a, aFromIndex, aToIndex,
                             b, bFromIndex, bToIndex);
     if (i &gt;= 0 &amp;&amp; i &lt; Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
         return Double.compare(a[aFromIndex + i], b[bFromIndex + i]);
     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);</pre>
</dd> <dt>Parameters:</dt> <dd>
<code>a</code> - the first array to compare</dd> <dd>
<code>aFromIndex</code> - the index (inclusive) of the first element in the first array to be compared</dd> <dd>
<code>aToIndex</code> - the index (exclusive) of the last element in the first array to be compared</dd> <dd>
<code>b</code> - the second array to compare</dd> <dd>
<code>bFromIndex</code> - the index (inclusive) of the first element in the second array to be compared</dd> <dd>
<code>bToIndex</code> - the index (exclusive) of the last element in the second array to be compared</dd> <dt>Returns:</dt> <dd>the value <code>0</code> if, over the specified ranges, the first and second array are equal and contain the same elements in the same order; a value less than <code>0</code> if, over the specified ranges, the first array is lexicographically less than the second array; and a value greater than <code>0</code> if, over the specified ranges, the first array is lexicographically greater than the second array</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - if <code>aFromIndex &gt; aToIndex</code> or if <code>bFromIndex &gt; bToIndex</code>
</dd> <dd>
<code><a href="../lang/arrayindexoutofboundsexception">ArrayIndexOutOfBoundsException</a></code> - if <code>aFromIndex &lt; 0 or aToIndex &gt; a.length</code> or if <code>bFromIndex &lt; 0 or bToIndex &gt; b.length</code>
</dd> <dd>
<code><a href="../lang/nullpointerexception">NullPointerException</a></code> - if either array is <code>null</code>
</dd> <dt>Since:</dt> <dd>9</dd> </dl>    <h3 id="compare(java.lang.Comparable[],java.lang.Comparable[])">compare</h3> <pre data-language="java">public static &lt;T extends Comparable&lt;? super T&gt;&gt; int compare(T[] a,
                                                            T[] b)</pre> <div>
<p>Compares two <code>Object</code> arrays, within comparable elements, lexicographically. </p>
<p>If the two arrays share a common prefix then the lexicographic comparison is the result of comparing two elements of type <code>T</code> at an index <code>i</code> within the respective arrays that is the prefix length, as if by: </p>
<pre data-language="java">Comparator.nullsFirst(Comparator.&lt;T&gt;naturalOrder()).
         compare(a[i], b[i])</pre> Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two array lengths. (See <a href="#mismatch(java.lang.Object%5B%5D,java.lang.Object%5B%5D)"><code>mismatch(Object[], Object[])</code></a> for the definition of a common and proper prefix.) <p>A <code>null</code> array reference is considered lexicographically less than a non-<code>null</code> array reference. Two <code>null</code> array references are considered equal. A <code>null</code> array element is considered lexicographically than a non-<code>null</code> array element. Two <code>null</code> array elements are considered equal. </p>
<p>The comparison is consistent with <a href="#equals(java.lang.Object%5B%5D,java.lang.Object%5B%5D)"><code>equals</code></a>, more specifically the following holds for arrays <code>a</code> and <code>b</code>: </p>
<pre data-language="java">Arrays.equals(a, b) == (Arrays.compare(a, b) == 0)</pre>
</div> <dl> <dt>API Note:</dt> <dd>
<p>This method behaves as if (for non-<code>null</code> array references and elements): </p>
<pre data-language="java">int i = Arrays.mismatch(a, b);
     if (i &gt;= 0 &amp;&amp; i &lt; Math.min(a.length, b.length))
         return a[i].compareTo(b[i]);
     return a.length - b.length;</pre>
</dd> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the type of comparable array elements</dd> <dt>Parameters:</dt> <dd>
<code>a</code> - the first array to compare</dd> <dd>
<code>b</code> - the second array to compare</dd> <dt>Returns:</dt> <dd>the value <code>0</code> if the first and second array are equal and contain the same elements in the same order; a value less than <code>0</code> if the first array is lexicographically less than the second array; and a value greater than <code>0</code> if the first array is lexicographically greater than the second array</dd> <dt>Since:</dt> <dd>9</dd> </dl>    <h3 id="compare(java.lang.Comparable[],int,int,java.lang.Comparable[],int,int)">compare</h3> <pre data-language="java">public static &lt;T extends Comparable&lt;? super T&gt;&gt; int compare(T[] a,
                                                            int aFromIndex,
                                                            int aToIndex,
                                                            T[] b,
                                                            int bFromIndex,
                                                            int bToIndex)</pre> <div>
<p>Compares two <code>Object</code> arrays lexicographically over the specified ranges. </p>
<p>If the two arrays, over the specified ranges, share a common prefix then the lexicographic comparison is the result of comparing two elements of type <code>T</code> at a relative index <code>i</code> within the respective arrays that is the prefix length, as if by: </p>
<pre data-language="java">Comparator.nullsFirst(Comparator.&lt;T&gt;naturalOrder()).
         compare(a[aFromIndex + i, b[bFromIndex + i])</pre> Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two range lengths. (See <a href="#mismatch(java.lang.Object%5B%5D,int,int,java.lang.Object%5B%5D,int,int)"><code>mismatch(Object[], int, int, Object[], int, int)</code></a> for the definition of a common and proper prefix.) <p>The comparison is consistent with <a href="#equals(java.lang.Object%5B%5D,int,int,java.lang.Object%5B%5D,int,int)"><code>equals</code></a>, more specifically the following holds for arrays <code>a</code> and <code>b</code> with specified ranges [<code>aFromIndex</code>, <code>atoIndex</code>) and [<code>bFromIndex</code>, <code>btoIndex</code>) respectively: </p>
<pre data-language="java">Arrays.equals(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) ==
         (Arrays.compare(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex) == 0)</pre>
</div> <dl> <dt>API Note:</dt> <dd>
<p>This method behaves as if (for non-<code>null</code> array elements): </p>
<pre data-language="java">int i = Arrays.mismatch(a, aFromIndex, aToIndex,
                             b, bFromIndex, bToIndex);
     if (i &gt;= 0 &amp;&amp; i &lt; Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
         return a[aFromIndex + i].compareTo(b[bFromIndex + i]);
     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);</pre>
</dd> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the type of comparable array elements</dd> <dt>Parameters:</dt> <dd>
<code>a</code> - the first array to compare</dd> <dd>
<code>aFromIndex</code> - the index (inclusive) of the first element in the first array to be compared</dd> <dd>
<code>aToIndex</code> - the index (exclusive) of the last element in the first array to be compared</dd> <dd>
<code>b</code> - the second array to compare</dd> <dd>
<code>bFromIndex</code> - the index (inclusive) of the first element in the second array to be compared</dd> <dd>
<code>bToIndex</code> - the index (exclusive) of the last element in the second array to be compared</dd> <dt>Returns:</dt> <dd>the value <code>0</code> if, over the specified ranges, the first and second array are equal and contain the same elements in the same order; a value less than <code>0</code> if, over the specified ranges, the first array is lexicographically less than the second array; and a value greater than <code>0</code> if, over the specified ranges, the first array is lexicographically greater than the second array</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - if <code>aFromIndex &gt; aToIndex</code> or if <code>bFromIndex &gt; bToIndex</code>
</dd> <dd>
<code><a href="../lang/arrayindexoutofboundsexception">ArrayIndexOutOfBoundsException</a></code> - if <code>aFromIndex &lt; 0 or aToIndex &gt; a.length</code> or if <code>bFromIndex &lt; 0 or bToIndex &gt; b.length</code>
</dd> <dd>
<code><a href="../lang/nullpointerexception">NullPointerException</a></code> - if either array is <code>null</code>
</dd> <dt>Since:</dt> <dd>9</dd> </dl>    <h3 id="compare(java.lang.Object[],java.lang.Object[],java.util.Comparator)">compare</h3> <pre data-language="java">public static &lt;T&gt; int compare(T[] a,
                              T[] b,
                              Comparator&lt;? super T&gt; cmp)</pre> <div>
<p>Compares two <code>Object</code> arrays lexicographically using a specified comparator. </p>
<p>If the two arrays share a common prefix then the lexicographic comparison is the result of comparing with the specified comparator two elements at an index within the respective arrays that is the prefix length. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two array lengths. (See <a href="#mismatch(java.lang.Object%5B%5D,java.lang.Object%5B%5D)"><code>mismatch(Object[], Object[])</code></a> for the definition of a common and proper prefix.) </p>
<p>A <code>null</code> array reference is considered lexicographically less than a non-<code>null</code> array reference. Two <code>null</code> array references are considered equal.</p>
</div> <dl> <dt>API Note:</dt> <dd>
<p>This method behaves as if (for non-<code>null</code> array references): </p>
<pre data-language="java">int i = Arrays.mismatch(a, b, cmp);
     if (i &gt;= 0 &amp;&amp; i &lt; Math.min(a.length, b.length))
         return cmp.compare(a[i], b[i]);
     return a.length - b.length;</pre>
</dd> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the type of array elements</dd> <dt>Parameters:</dt> <dd>
<code>a</code> - the first array to compare</dd> <dd>
<code>b</code> - the second array to compare</dd> <dd>
<code>cmp</code> - the comparator to compare array elements</dd> <dt>Returns:</dt> <dd>the value <code>0</code> if the first and second array are equal and contain the same elements in the same order; a value less than <code>0</code> if the first array is lexicographically less than the second array; and a value greater than <code>0</code> if the first array is lexicographically greater than the second array</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/nullpointerexception">NullPointerException</a></code> - if the comparator is <code>null</code>
</dd> <dt>Since:</dt> <dd>9</dd> </dl>    <h3 id="compare(java.lang.Object[],int,int,java.lang.Object[],int,int,java.util.Comparator)">compare</h3> <pre data-language="java">public static &lt;T&gt; int compare(T[] a,
                              int aFromIndex,
                              int aToIndex,
                              T[] b,
                              int bFromIndex,
                              int bToIndex,
                              Comparator&lt;? super T&gt; cmp)</pre> <div>
<p>Compares two <code>Object</code> arrays lexicographically over the specified ranges. </p>
<p>If the two arrays, over the specified ranges, share a common prefix then the lexicographic comparison is the result of comparing with the specified comparator two elements at a relative index within the respective arrays that is the prefix length. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two range lengths. (See <a href="#mismatch(java.lang.Object%5B%5D,int,int,java.lang.Object%5B%5D,int,int)"><code>mismatch(Object[], int, int, Object[], int, int)</code></a> for the definition of a common and proper prefix.)</p>
</div> <dl> <dt>API Note:</dt> <dd>
<p>This method behaves as if (for non-<code>null</code> array elements): </p>
<pre data-language="java">int i = Arrays.mismatch(a, aFromIndex, aToIndex,
                             b, bFromIndex, bToIndex, cmp);
     if (i &gt;= 0 &amp;&amp; i &lt; Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))
         return cmp.compare(a[aFromIndex + i], b[bFromIndex + i]);
     return (aToIndex - aFromIndex) - (bToIndex - bFromIndex);</pre>
</dd> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the type of array elements</dd> <dt>Parameters:</dt> <dd>
<code>a</code> - the first array to compare</dd> <dd>
<code>aFromIndex</code> - the index (inclusive) of the first element in the first array to be compared</dd> <dd>
<code>aToIndex</code> - the index (exclusive) of the last element in the first array to be compared</dd> <dd>
<code>b</code> - the second array to compare</dd> <dd>
<code>bFromIndex</code> - the index (inclusive) of the first element in the second array to be compared</dd> <dd>
<code>bToIndex</code> - the index (exclusive) of the last element in the second array to be compared</dd> <dd>
<code>cmp</code> - the comparator to compare array elements</dd> <dt>Returns:</dt> <dd>the value <code>0</code> if, over the specified ranges, the first and second array are equal and contain the same elements in the same order; a value less than <code>0</code> if, over the specified ranges, the first array is lexicographically less than the second array; and a value greater than <code>0</code> if, over the specified ranges, the first array is lexicographically greater than the second array</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - if <code>aFromIndex &gt; aToIndex</code> or if <code>bFromIndex &gt; bToIndex</code>
</dd> <dd>
<code><a href="../lang/arrayindexoutofboundsexception">ArrayIndexOutOfBoundsException</a></code> - if <code>aFromIndex &lt; 0 or aToIndex &gt; a.length</code> or if <code>bFromIndex &lt; 0 or bToIndex &gt; b.length</code>
</dd> <dd>
<code><a href="../lang/nullpointerexception">NullPointerException</a></code> - if either array or the comparator is <code>null</code>
</dd> <dt>Since:</dt> <dd>9</dd> </dl>    <h3 id="mismatch(boolean[],boolean[])">mismatch</h3> <pre data-language="java">public static int mismatch(boolean[] a,
                           boolean[] b)</pre> <div>
<p>Finds and returns the index of the first mismatch between two <code>boolean</code> arrays, otherwise return -1 if no mismatch is found. The index will be in the range of 0 (inclusive) up to the length (inclusive) of the smaller array. </p>
<p>If the two arrays share a common prefix then the returned index is the length of the common prefix and it follows that there is a mismatch between the two elements at that index within the respective arrays. If one array is a proper prefix of the other then the returned index is the length of the smaller array and it follows that the index is only valid for the larger array. Otherwise, there is no mismatch. </p>
<p>Two non-<code>null</code> arrays, <code>a</code> and <code>b</code>, share a common prefix of length <code>pl</code> if the following expression is true: </p>
<pre data-language="java">pl &gt;= 0 &amp;&amp;
     pl &lt; Math.min(a.length, b.length) &amp;&amp;
     Arrays.equals(a, 0, pl, b, 0, pl) &amp;&amp;
     a[pl] != b[pl]</pre> Note that a common prefix length of <code>0</code> indicates that the first elements from each array mismatch. <p>Two non-<code>null</code> arrays, <code>a</code> and <code>b</code>, share a proper prefix if the following expression is true: </p>
<pre data-language="java">a.length != b.length &amp;&amp;
     Arrays.equals(a, 0, Math.min(a.length, b.length),
                   b, 0, Math.min(a.length, b.length))</pre>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the first array to be tested for a mismatch</dd> <dd>
<code>b</code> - the second array to be tested for a mismatch</dd> <dt>Returns:</dt> <dd>the index of the first mismatch between the two arrays, otherwise <code>-1</code>.</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/nullpointerexception">NullPointerException</a></code> - if either array is <code>null</code>
</dd> <dt>Since:</dt> <dd>9</dd> </dl>    <h3 id="mismatch(boolean[],int,int,boolean[],int,int)">mismatch</h3> <pre data-language="java">public static int mismatch(boolean[] a,
                           int aFromIndex,
                           int aToIndex,
                           boolean[] b,
                           int bFromIndex,
                           int bToIndex)</pre> <div>
<p>Finds and returns the relative index of the first mismatch between two <code>boolean</code> arrays over the specified ranges, otherwise return -1 if no mismatch is found. The index will be in the range of 0 (inclusive) up to the length (inclusive) of the smaller range. </p>
<p>If the two arrays, over the specified ranges, share a common prefix then the returned relative index is the length of the common prefix and it follows that there is a mismatch between the two elements at that relative index within the respective arrays. If one array is a proper prefix of the other, over the specified ranges, then the returned relative index is the length of the smaller range and it follows that the relative index is only valid for the array with the larger range. Otherwise, there is no mismatch. </p>
<p>Two non-<code>null</code> arrays, <code>a</code> and <code>b</code> with specified ranges [<code>aFromIndex</code>, <code>atoIndex</code>) and [<code>bFromIndex</code>, <code>btoIndex</code>) respectively, share a common prefix of length <code>pl</code> if the following expression is true: </p>
<pre data-language="java">pl &gt;= 0 &amp;&amp;
     pl &lt; Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) &amp;&amp;
     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) &amp;&amp;
     a[aFromIndex + pl] != b[bFromIndex + pl]</pre> Note that a common prefix length of <code>0</code> indicates that the first elements from each array mismatch. <p>Two non-<code>null</code> arrays, <code>a</code> and <code>b</code> with specified ranges [<code>aFromIndex</code>, <code>atoIndex</code>) and [<code>bFromIndex</code>, <code>btoIndex</code>) respectively, share a proper if the following expression is true: </p>
<pre data-language="java">(aToIndex - aFromIndex) != (bToIndex - bFromIndex) &amp;&amp;
     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),
                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))</pre>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the first array to be tested for a mismatch</dd> <dd>
<code>aFromIndex</code> - the index (inclusive) of the first element in the first array to be tested</dd> <dd>
<code>aToIndex</code> - the index (exclusive) of the last element in the first array to be tested</dd> <dd>
<code>b</code> - the second array to be tested for a mismatch</dd> <dd>
<code>bFromIndex</code> - the index (inclusive) of the first element in the second array to be tested</dd> <dd>
<code>bToIndex</code> - the index (exclusive) of the last element in the second array to be tested</dd> <dt>Returns:</dt> <dd>the relative index of the first mismatch between the two arrays over the specified ranges, otherwise <code>-1</code>.</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - if <code>aFromIndex &gt; aToIndex</code> or if <code>bFromIndex &gt; bToIndex</code>
</dd> <dd>
<code><a href="../lang/arrayindexoutofboundsexception">ArrayIndexOutOfBoundsException</a></code> - if <code>aFromIndex &lt; 0 or aToIndex &gt; a.length</code> or if <code>bFromIndex &lt; 0 or bToIndex &gt; b.length</code>
</dd> <dd>
<code><a href="../lang/nullpointerexception">NullPointerException</a></code> - if either array is <code>null</code>
</dd> <dt>Since:</dt> <dd>9</dd> </dl>    <h3 id="mismatch(byte[],byte[])">mismatch</h3> <pre data-language="java">public static int mismatch(byte[] a,
                           byte[] b)</pre> <div>
<p>Finds and returns the index of the first mismatch between two <code>byte</code> arrays, otherwise return -1 if no mismatch is found. The index will be in the range of 0 (inclusive) up to the length (inclusive) of the smaller array. </p>
<p>If the two arrays share a common prefix then the returned index is the length of the common prefix and it follows that there is a mismatch between the two elements at that index within the respective arrays. If one array is a proper prefix of the other then the returned index is the length of the smaller array and it follows that the index is only valid for the larger array. Otherwise, there is no mismatch. </p>
<p>Two non-<code>null</code> arrays, <code>a</code> and <code>b</code>, share a common prefix of length <code>pl</code> if the following expression is true: </p>
<pre data-language="java">pl &gt;= 0 &amp;&amp;
     pl &lt; Math.min(a.length, b.length) &amp;&amp;
     Arrays.equals(a, 0, pl, b, 0, pl) &amp;&amp;
     a[pl] != b[pl]</pre> Note that a common prefix length of <code>0</code> indicates that the first elements from each array mismatch. <p>Two non-<code>null</code> arrays, <code>a</code> and <code>b</code>, share a proper prefix if the following expression is true: </p>
<pre data-language="java">a.length != b.length &amp;&amp;
     Arrays.equals(a, 0, Math.min(a.length, b.length),
                   b, 0, Math.min(a.length, b.length))</pre>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the first array to be tested for a mismatch</dd> <dd>
<code>b</code> - the second array to be tested for a mismatch</dd> <dt>Returns:</dt> <dd>the index of the first mismatch between the two arrays, otherwise <code>-1</code>.</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/nullpointerexception">NullPointerException</a></code> - if either array is <code>null</code>
</dd> <dt>Since:</dt> <dd>9</dd> </dl>    <h3 id="mismatch(byte[],int,int,byte[],int,int)">mismatch</h3> <pre data-language="java">public static int mismatch(byte[] a,
                           int aFromIndex,
                           int aToIndex,
                           byte[] b,
                           int bFromIndex,
                           int bToIndex)</pre> <div>
<p>Finds and returns the relative index of the first mismatch between two <code>byte</code> arrays over the specified ranges, otherwise return -1 if no mismatch is found. The index will be in the range of 0 (inclusive) up to the length (inclusive) of the smaller range. </p>
<p>If the two arrays, over the specified ranges, share a common prefix then the returned relative index is the length of the common prefix and it follows that there is a mismatch between the two elements at that relative index within the respective arrays. If one array is a proper prefix of the other, over the specified ranges, then the returned relative index is the length of the smaller range and it follows that the relative index is only valid for the array with the larger range. Otherwise, there is no mismatch. </p>
<p>Two non-<code>null</code> arrays, <code>a</code> and <code>b</code> with specified ranges [<code>aFromIndex</code>, <code>atoIndex</code>) and [<code>bFromIndex</code>, <code>btoIndex</code>) respectively, share a common prefix of length <code>pl</code> if the following expression is true: </p>
<pre data-language="java">pl &gt;= 0 &amp;&amp;
     pl &lt; Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) &amp;&amp;
     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) &amp;&amp;
     a[aFromIndex + pl] != b[bFromIndex + pl]</pre> Note that a common prefix length of <code>0</code> indicates that the first elements from each array mismatch. <p>Two non-<code>null</code> arrays, <code>a</code> and <code>b</code> with specified ranges [<code>aFromIndex</code>, <code>atoIndex</code>) and [<code>bFromIndex</code>, <code>btoIndex</code>) respectively, share a proper if the following expression is true: </p>
<pre data-language="java">(aToIndex - aFromIndex) != (bToIndex - bFromIndex) &amp;&amp;
     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),
                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))</pre>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the first array to be tested for a mismatch</dd> <dd>
<code>aFromIndex</code> - the index (inclusive) of the first element in the first array to be tested</dd> <dd>
<code>aToIndex</code> - the index (exclusive) of the last element in the first array to be tested</dd> <dd>
<code>b</code> - the second array to be tested for a mismatch</dd> <dd>
<code>bFromIndex</code> - the index (inclusive) of the first element in the second array to be tested</dd> <dd>
<code>bToIndex</code> - the index (exclusive) of the last element in the second array to be tested</dd> <dt>Returns:</dt> <dd>the relative index of the first mismatch between the two arrays over the specified ranges, otherwise <code>-1</code>.</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - if <code>aFromIndex &gt; aToIndex</code> or if <code>bFromIndex &gt; bToIndex</code>
</dd> <dd>
<code><a href="../lang/arrayindexoutofboundsexception">ArrayIndexOutOfBoundsException</a></code> - if <code>aFromIndex &lt; 0 or aToIndex &gt; a.length</code> or if <code>bFromIndex &lt; 0 or bToIndex &gt; b.length</code>
</dd> <dd>
<code><a href="../lang/nullpointerexception">NullPointerException</a></code> - if either array is <code>null</code>
</dd> <dt>Since:</dt> <dd>9</dd> </dl>    <h3 id="mismatch(char[],char[])">mismatch</h3> <pre data-language="java">public static int mismatch(char[] a,
                           char[] b)</pre> <div>
<p>Finds and returns the index of the first mismatch between two <code>char</code> arrays, otherwise return -1 if no mismatch is found. The index will be in the range of 0 (inclusive) up to the length (inclusive) of the smaller array. </p>
<p>If the two arrays share a common prefix then the returned index is the length of the common prefix and it follows that there is a mismatch between the two elements at that index within the respective arrays. If one array is a proper prefix of the other then the returned index is the length of the smaller array and it follows that the index is only valid for the larger array. Otherwise, there is no mismatch. </p>
<p>Two non-<code>null</code> arrays, <code>a</code> and <code>b</code>, share a common prefix of length <code>pl</code> if the following expression is true: </p>
<pre data-language="java">pl &gt;= 0 &amp;&amp;
     pl &lt; Math.min(a.length, b.length) &amp;&amp;
     Arrays.equals(a, 0, pl, b, 0, pl) &amp;&amp;
     a[pl] != b[pl]</pre> Note that a common prefix length of <code>0</code> indicates that the first elements from each array mismatch. <p>Two non-<code>null</code> arrays, <code>a</code> and <code>b</code>, share a proper prefix if the following expression is true: </p>
<pre data-language="java">a.length != b.length &amp;&amp;
     Arrays.equals(a, 0, Math.min(a.length, b.length),
                   b, 0, Math.min(a.length, b.length))</pre>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the first array to be tested for a mismatch</dd> <dd>
<code>b</code> - the second array to be tested for a mismatch</dd> <dt>Returns:</dt> <dd>the index of the first mismatch between the two arrays, otherwise <code>-1</code>.</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/nullpointerexception">NullPointerException</a></code> - if either array is <code>null</code>
</dd> <dt>Since:</dt> <dd>9</dd> </dl>    <h3 id="mismatch(char[],int,int,char[],int,int)">mismatch</h3> <pre data-language="java">public static int mismatch(char[] a,
                           int aFromIndex,
                           int aToIndex,
                           char[] b,
                           int bFromIndex,
                           int bToIndex)</pre> <div>
<p>Finds and returns the relative index of the first mismatch between two <code>char</code> arrays over the specified ranges, otherwise return -1 if no mismatch is found. The index will be in the range of 0 (inclusive) up to the length (inclusive) of the smaller range. </p>
<p>If the two arrays, over the specified ranges, share a common prefix then the returned relative index is the length of the common prefix and it follows that there is a mismatch between the two elements at that relative index within the respective arrays. If one array is a proper prefix of the other, over the specified ranges, then the returned relative index is the length of the smaller range and it follows that the relative index is only valid for the array with the larger range. Otherwise, there is no mismatch. </p>
<p>Two non-<code>null</code> arrays, <code>a</code> and <code>b</code> with specified ranges [<code>aFromIndex</code>, <code>atoIndex</code>) and [<code>bFromIndex</code>, <code>btoIndex</code>) respectively, share a common prefix of length <code>pl</code> if the following expression is true: </p>
<pre data-language="java">pl &gt;= 0 &amp;&amp;
     pl &lt; Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) &amp;&amp;
     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) &amp;&amp;
     a[aFromIndex + pl] != b[bFromIndex + pl]</pre> Note that a common prefix length of <code>0</code> indicates that the first elements from each array mismatch. <p>Two non-<code>null</code> arrays, <code>a</code> and <code>b</code> with specified ranges [<code>aFromIndex</code>, <code>atoIndex</code>) and [<code>bFromIndex</code>, <code>btoIndex</code>) respectively, share a proper if the following expression is true: </p>
<pre data-language="java">(aToIndex - aFromIndex) != (bToIndex - bFromIndex) &amp;&amp;
     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),
                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))</pre>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the first array to be tested for a mismatch</dd> <dd>
<code>aFromIndex</code> - the index (inclusive) of the first element in the first array to be tested</dd> <dd>
<code>aToIndex</code> - the index (exclusive) of the last element in the first array to be tested</dd> <dd>
<code>b</code> - the second array to be tested for a mismatch</dd> <dd>
<code>bFromIndex</code> - the index (inclusive) of the first element in the second array to be tested</dd> <dd>
<code>bToIndex</code> - the index (exclusive) of the last element in the second array to be tested</dd> <dt>Returns:</dt> <dd>the relative index of the first mismatch between the two arrays over the specified ranges, otherwise <code>-1</code>.</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - if <code>aFromIndex &gt; aToIndex</code> or if <code>bFromIndex &gt; bToIndex</code>
</dd> <dd>
<code><a href="../lang/arrayindexoutofboundsexception">ArrayIndexOutOfBoundsException</a></code> - if <code>aFromIndex &lt; 0 or aToIndex &gt; a.length</code> or if <code>bFromIndex &lt; 0 or bToIndex &gt; b.length</code>
</dd> <dd>
<code><a href="../lang/nullpointerexception">NullPointerException</a></code> - if either array is <code>null</code>
</dd> <dt>Since:</dt> <dd>9</dd> </dl>    <h3 id="mismatch(short[],short[])">mismatch</h3> <pre data-language="java">public static int mismatch(short[] a,
                           short[] b)</pre> <div>
<p>Finds and returns the index of the first mismatch between two <code>short</code> arrays, otherwise return -1 if no mismatch is found. The index will be in the range of 0 (inclusive) up to the length (inclusive) of the smaller array. </p>
<p>If the two arrays share a common prefix then the returned index is the length of the common prefix and it follows that there is a mismatch between the two elements at that index within the respective arrays. If one array is a proper prefix of the other then the returned index is the length of the smaller array and it follows that the index is only valid for the larger array. Otherwise, there is no mismatch. </p>
<p>Two non-<code>null</code> arrays, <code>a</code> and <code>b</code>, share a common prefix of length <code>pl</code> if the following expression is true: </p>
<pre data-language="java">pl &gt;= 0 &amp;&amp;
     pl &lt; Math.min(a.length, b.length) &amp;&amp;
     Arrays.equals(a, 0, pl, b, 0, pl) &amp;&amp;
     a[pl] != b[pl]</pre> Note that a common prefix length of <code>0</code> indicates that the first elements from each array mismatch. <p>Two non-<code>null</code> arrays, <code>a</code> and <code>b</code>, share a proper prefix if the following expression is true: </p>
<pre data-language="java">a.length != b.length &amp;&amp;
     Arrays.equals(a, 0, Math.min(a.length, b.length),
                   b, 0, Math.min(a.length, b.length))</pre>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the first array to be tested for a mismatch</dd> <dd>
<code>b</code> - the second array to be tested for a mismatch</dd> <dt>Returns:</dt> <dd>the index of the first mismatch between the two arrays, otherwise <code>-1</code>.</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/nullpointerexception">NullPointerException</a></code> - if either array is <code>null</code>
</dd> <dt>Since:</dt> <dd>9</dd> </dl>    <h3 id="mismatch(short[],int,int,short[],int,int)">mismatch</h3> <pre data-language="java">public static int mismatch(short[] a,
                           int aFromIndex,
                           int aToIndex,
                           short[] b,
                           int bFromIndex,
                           int bToIndex)</pre> <div>
<p>Finds and returns the relative index of the first mismatch between two <code>short</code> arrays over the specified ranges, otherwise return -1 if no mismatch is found. The index will be in the range of 0 (inclusive) up to the length (inclusive) of the smaller range. </p>
<p>If the two arrays, over the specified ranges, share a common prefix then the returned relative index is the length of the common prefix and it follows that there is a mismatch between the two elements at that relative index within the respective arrays. If one array is a proper prefix of the other, over the specified ranges, then the returned relative index is the length of the smaller range and it follows that the relative index is only valid for the array with the larger range. Otherwise, there is no mismatch. </p>
<p>Two non-<code>null</code> arrays, <code>a</code> and <code>b</code> with specified ranges [<code>aFromIndex</code>, <code>atoIndex</code>) and [<code>bFromIndex</code>, <code>btoIndex</code>) respectively, share a common prefix of length <code>pl</code> if the following expression is true: </p>
<pre data-language="java">pl &gt;= 0 &amp;&amp;
     pl &lt; Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) &amp;&amp;
     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) &amp;&amp;
     a[aFromIndex + pl] != b[bFromIndex + pl]</pre> Note that a common prefix length of <code>0</code> indicates that the first elements from each array mismatch. <p>Two non-<code>null</code> arrays, <code>a</code> and <code>b</code> with specified ranges [<code>aFromIndex</code>, <code>atoIndex</code>) and [<code>bFromIndex</code>, <code>btoIndex</code>) respectively, share a proper if the following expression is true: </p>
<pre data-language="java">(aToIndex - aFromIndex) != (bToIndex - bFromIndex) &amp;&amp;
     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),
                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))</pre>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the first array to be tested for a mismatch</dd> <dd>
<code>aFromIndex</code> - the index (inclusive) of the first element in the first array to be tested</dd> <dd>
<code>aToIndex</code> - the index (exclusive) of the last element in the first array to be tested</dd> <dd>
<code>b</code> - the second array to be tested for a mismatch</dd> <dd>
<code>bFromIndex</code> - the index (inclusive) of the first element in the second array to be tested</dd> <dd>
<code>bToIndex</code> - the index (exclusive) of the last element in the second array to be tested</dd> <dt>Returns:</dt> <dd>the relative index of the first mismatch between the two arrays over the specified ranges, otherwise <code>-1</code>.</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - if <code>aFromIndex &gt; aToIndex</code> or if <code>bFromIndex &gt; bToIndex</code>
</dd> <dd>
<code><a href="../lang/arrayindexoutofboundsexception">ArrayIndexOutOfBoundsException</a></code> - if <code>aFromIndex &lt; 0 or aToIndex &gt; a.length</code> or if <code>bFromIndex &lt; 0 or bToIndex &gt; b.length</code>
</dd> <dd>
<code><a href="../lang/nullpointerexception">NullPointerException</a></code> - if either array is <code>null</code>
</dd> <dt>Since:</dt> <dd>9</dd> </dl>    <h3 id="mismatch(int[],int[])">mismatch</h3> <pre data-language="java">public static int mismatch(int[] a,
                           int[] b)</pre> <div>
<p>Finds and returns the index of the first mismatch between two <code>int</code> arrays, otherwise return -1 if no mismatch is found. The index will be in the range of 0 (inclusive) up to the length (inclusive) of the smaller array. </p>
<p>If the two arrays share a common prefix then the returned index is the length of the common prefix and it follows that there is a mismatch between the two elements at that index within the respective arrays. If one array is a proper prefix of the other then the returned index is the length of the smaller array and it follows that the index is only valid for the larger array. Otherwise, there is no mismatch. </p>
<p>Two non-<code>null</code> arrays, <code>a</code> and <code>b</code>, share a common prefix of length <code>pl</code> if the following expression is true: </p>
<pre data-language="java">pl &gt;= 0 &amp;&amp;
     pl &lt; Math.min(a.length, b.length) &amp;&amp;
     Arrays.equals(a, 0, pl, b, 0, pl) &amp;&amp;
     a[pl] != b[pl]</pre> Note that a common prefix length of <code>0</code> indicates that the first elements from each array mismatch. <p>Two non-<code>null</code> arrays, <code>a</code> and <code>b</code>, share a proper prefix if the following expression is true: </p>
<pre data-language="java">a.length != b.length &amp;&amp;
     Arrays.equals(a, 0, Math.min(a.length, b.length),
                   b, 0, Math.min(a.length, b.length))</pre>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the first array to be tested for a mismatch</dd> <dd>
<code>b</code> - the second array to be tested for a mismatch</dd> <dt>Returns:</dt> <dd>the index of the first mismatch between the two arrays, otherwise <code>-1</code>.</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/nullpointerexception">NullPointerException</a></code> - if either array is <code>null</code>
</dd> <dt>Since:</dt> <dd>9</dd> </dl>    <h3 id="mismatch(int[],int,int,int[],int,int)">mismatch</h3> <pre data-language="java">public static int mismatch(int[] a,
                           int aFromIndex,
                           int aToIndex,
                           int[] b,
                           int bFromIndex,
                           int bToIndex)</pre> <div>
<p>Finds and returns the relative index of the first mismatch between two <code>int</code> arrays over the specified ranges, otherwise return -1 if no mismatch is found. The index will be in the range of 0 (inclusive) up to the length (inclusive) of the smaller range. </p>
<p>If the two arrays, over the specified ranges, share a common prefix then the returned relative index is the length of the common prefix and it follows that there is a mismatch between the two elements at that relative index within the respective arrays. If one array is a proper prefix of the other, over the specified ranges, then the returned relative index is the length of the smaller range and it follows that the relative index is only valid for the array with the larger range. Otherwise, there is no mismatch. </p>
<p>Two non-<code>null</code> arrays, <code>a</code> and <code>b</code> with specified ranges [<code>aFromIndex</code>, <code>atoIndex</code>) and [<code>bFromIndex</code>, <code>btoIndex</code>) respectively, share a common prefix of length <code>pl</code> if the following expression is true: </p>
<pre data-language="java">pl &gt;= 0 &amp;&amp;
     pl &lt; Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) &amp;&amp;
     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) &amp;&amp;
     a[aFromIndex + pl] != b[bFromIndex + pl]</pre> Note that a common prefix length of <code>0</code> indicates that the first elements from each array mismatch. <p>Two non-<code>null</code> arrays, <code>a</code> and <code>b</code> with specified ranges [<code>aFromIndex</code>, <code>atoIndex</code>) and [<code>bFromIndex</code>, <code>btoIndex</code>) respectively, share a proper if the following expression is true: </p>
<pre data-language="java">(aToIndex - aFromIndex) != (bToIndex - bFromIndex) &amp;&amp;
     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),
                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))</pre>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the first array to be tested for a mismatch</dd> <dd>
<code>aFromIndex</code> - the index (inclusive) of the first element in the first array to be tested</dd> <dd>
<code>aToIndex</code> - the index (exclusive) of the last element in the first array to be tested</dd> <dd>
<code>b</code> - the second array to be tested for a mismatch</dd> <dd>
<code>bFromIndex</code> - the index (inclusive) of the first element in the second array to be tested</dd> <dd>
<code>bToIndex</code> - the index (exclusive) of the last element in the second array to be tested</dd> <dt>Returns:</dt> <dd>the relative index of the first mismatch between the two arrays over the specified ranges, otherwise <code>-1</code>.</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - if <code>aFromIndex &gt; aToIndex</code> or if <code>bFromIndex &gt; bToIndex</code>
</dd> <dd>
<code><a href="../lang/arrayindexoutofboundsexception">ArrayIndexOutOfBoundsException</a></code> - if <code>aFromIndex &lt; 0 or aToIndex &gt; a.length</code> or if <code>bFromIndex &lt; 0 or bToIndex &gt; b.length</code>
</dd> <dd>
<code><a href="../lang/nullpointerexception">NullPointerException</a></code> - if either array is <code>null</code>
</dd> <dt>Since:</dt> <dd>9</dd> </dl>    <h3 id="mismatch(long[],long[])">mismatch</h3> <pre data-language="java">public static int mismatch(long[] a,
                           long[] b)</pre> <div>
<p>Finds and returns the index of the first mismatch between two <code>long</code> arrays, otherwise return -1 if no mismatch is found. The index will be in the range of 0 (inclusive) up to the length (inclusive) of the smaller array. </p>
<p>If the two arrays share a common prefix then the returned index is the length of the common prefix and it follows that there is a mismatch between the two elements at that index within the respective arrays. If one array is a proper prefix of the other then the returned index is the length of the smaller array and it follows that the index is only valid for the larger array. Otherwise, there is no mismatch. </p>
<p>Two non-<code>null</code> arrays, <code>a</code> and <code>b</code>, share a common prefix of length <code>pl</code> if the following expression is true: </p>
<pre data-language="java">pl &gt;= 0 &amp;&amp;
     pl &lt; Math.min(a.length, b.length) &amp;&amp;
     Arrays.equals(a, 0, pl, b, 0, pl) &amp;&amp;
     a[pl] != b[pl]</pre> Note that a common prefix length of <code>0</code> indicates that the first elements from each array mismatch. <p>Two non-<code>null</code> arrays, <code>a</code> and <code>b</code>, share a proper prefix if the following expression is true: </p>
<pre data-language="java">a.length != b.length &amp;&amp;
     Arrays.equals(a, 0, Math.min(a.length, b.length),
                   b, 0, Math.min(a.length, b.length))</pre>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the first array to be tested for a mismatch</dd> <dd>
<code>b</code> - the second array to be tested for a mismatch</dd> <dt>Returns:</dt> <dd>the index of the first mismatch between the two arrays, otherwise <code>-1</code>.</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/nullpointerexception">NullPointerException</a></code> - if either array is <code>null</code>
</dd> <dt>Since:</dt> <dd>9</dd> </dl>    <h3 id="mismatch(long[],int,int,long[],int,int)">mismatch</h3> <pre data-language="java">public static int mismatch(long[] a,
                           int aFromIndex,
                           int aToIndex,
                           long[] b,
                           int bFromIndex,
                           int bToIndex)</pre> <div>
<p>Finds and returns the relative index of the first mismatch between two <code>long</code> arrays over the specified ranges, otherwise return -1 if no mismatch is found. The index will be in the range of 0 (inclusive) up to the length (inclusive) of the smaller range. </p>
<p>If the two arrays, over the specified ranges, share a common prefix then the returned relative index is the length of the common prefix and it follows that there is a mismatch between the two elements at that relative index within the respective arrays. If one array is a proper prefix of the other, over the specified ranges, then the returned relative index is the length of the smaller range and it follows that the relative index is only valid for the array with the larger range. Otherwise, there is no mismatch. </p>
<p>Two non-<code>null</code> arrays, <code>a</code> and <code>b</code> with specified ranges [<code>aFromIndex</code>, <code>atoIndex</code>) and [<code>bFromIndex</code>, <code>btoIndex</code>) respectively, share a common prefix of length <code>pl</code> if the following expression is true: </p>
<pre data-language="java">pl &gt;= 0 &amp;&amp;
     pl &lt; Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) &amp;&amp;
     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) &amp;&amp;
     a[aFromIndex + pl] != b[bFromIndex + pl]</pre> Note that a common prefix length of <code>0</code> indicates that the first elements from each array mismatch. <p>Two non-<code>null</code> arrays, <code>a</code> and <code>b</code> with specified ranges [<code>aFromIndex</code>, <code>atoIndex</code>) and [<code>bFromIndex</code>, <code>btoIndex</code>) respectively, share a proper if the following expression is true: </p>
<pre data-language="java">(aToIndex - aFromIndex) != (bToIndex - bFromIndex) &amp;&amp;
     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),
                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))</pre>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the first array to be tested for a mismatch</dd> <dd>
<code>aFromIndex</code> - the index (inclusive) of the first element in the first array to be tested</dd> <dd>
<code>aToIndex</code> - the index (exclusive) of the last element in the first array to be tested</dd> <dd>
<code>b</code> - the second array to be tested for a mismatch</dd> <dd>
<code>bFromIndex</code> - the index (inclusive) of the first element in the second array to be tested</dd> <dd>
<code>bToIndex</code> - the index (exclusive) of the last element in the second array to be tested</dd> <dt>Returns:</dt> <dd>the relative index of the first mismatch between the two arrays over the specified ranges, otherwise <code>-1</code>.</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - if <code>aFromIndex &gt; aToIndex</code> or if <code>bFromIndex &gt; bToIndex</code>
</dd> <dd>
<code><a href="../lang/arrayindexoutofboundsexception">ArrayIndexOutOfBoundsException</a></code> - if <code>aFromIndex &lt; 0 or aToIndex &gt; a.length</code> or if <code>bFromIndex &lt; 0 or bToIndex &gt; b.length</code>
</dd> <dd>
<code><a href="../lang/nullpointerexception">NullPointerException</a></code> - if either array is <code>null</code>
</dd> <dt>Since:</dt> <dd>9</dd> </dl>    <h3 id="mismatch(float[],float[])">mismatch</h3> <pre data-language="java">public static int mismatch(float[] a,
                           float[] b)</pre> <div>
<p>Finds and returns the index of the first mismatch between two <code>float</code> arrays, otherwise return -1 if no mismatch is found. The index will be in the range of 0 (inclusive) up to the length (inclusive) of the smaller array. </p>
<p>If the two arrays share a common prefix then the returned index is the length of the common prefix and it follows that there is a mismatch between the two elements at that index within the respective arrays. If one array is a proper prefix of the other then the returned index is the length of the smaller array and it follows that the index is only valid for the larger array. Otherwise, there is no mismatch. </p>
<p>Two non-<code>null</code> arrays, <code>a</code> and <code>b</code>, share a common prefix of length <code>pl</code> if the following expression is true: </p>
<pre data-language="java">pl &gt;= 0 &amp;&amp;
     pl &lt; Math.min(a.length, b.length) &amp;&amp;
     Arrays.equals(a, 0, pl, b, 0, pl) &amp;&amp;
     Float.compare(a[pl], b[pl]) != 0</pre> Note that a common prefix length of <code>0</code> indicates that the first elements from each array mismatch. <p>Two non-<code>null</code> arrays, <code>a</code> and <code>b</code>, share a proper prefix if the following expression is true: </p>
<pre data-language="java">a.length != b.length &amp;&amp;
     Arrays.equals(a, 0, Math.min(a.length, b.length),
                   b, 0, Math.min(a.length, b.length))</pre>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the first array to be tested for a mismatch</dd> <dd>
<code>b</code> - the second array to be tested for a mismatch</dd> <dt>Returns:</dt> <dd>the index of the first mismatch between the two arrays, otherwise <code>-1</code>.</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/nullpointerexception">NullPointerException</a></code> - if either array is <code>null</code>
</dd> <dt>Since:</dt> <dd>9</dd> </dl>    <h3 id="mismatch(float[],int,int,float[],int,int)">mismatch</h3> <pre data-language="java">public static int mismatch(float[] a,
                           int aFromIndex,
                           int aToIndex,
                           float[] b,
                           int bFromIndex,
                           int bToIndex)</pre> <div>
<p>Finds and returns the relative index of the first mismatch between two <code>float</code> arrays over the specified ranges, otherwise return -1 if no mismatch is found. The index will be in the range of 0 (inclusive) up to the length (inclusive) of the smaller range. </p>
<p>If the two arrays, over the specified ranges, share a common prefix then the returned relative index is the length of the common prefix and it follows that there is a mismatch between the two elements at that relative index within the respective arrays. If one array is a proper prefix of the other, over the specified ranges, then the returned relative index is the length of the smaller range and it follows that the relative index is only valid for the array with the larger range. Otherwise, there is no mismatch. </p>
<p>Two non-<code>null</code> arrays, <code>a</code> and <code>b</code> with specified ranges [<code>aFromIndex</code>, <code>atoIndex</code>) and [<code>bFromIndex</code>, <code>btoIndex</code>) respectively, share a common prefix of length <code>pl</code> if the following expression is true: </p>
<pre data-language="java">pl &gt;= 0 &amp;&amp;
     pl &lt; Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) &amp;&amp;
     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) &amp;&amp;
     Float.compare(a[aFromIndex + pl], b[bFromIndex + pl]) != 0</pre> Note that a common prefix length of <code>0</code> indicates that the first elements from each array mismatch. <p>Two non-<code>null</code> arrays, <code>a</code> and <code>b</code> with specified ranges [<code>aFromIndex</code>, <code>atoIndex</code>) and [<code>bFromIndex</code>, <code>btoIndex</code>) respectively, share a proper if the following expression is true: </p>
<pre data-language="java">(aToIndex - aFromIndex) != (bToIndex - bFromIndex) &amp;&amp;
     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),
                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))</pre>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the first array to be tested for a mismatch</dd> <dd>
<code>aFromIndex</code> - the index (inclusive) of the first element in the first array to be tested</dd> <dd>
<code>aToIndex</code> - the index (exclusive) of the last element in the first array to be tested</dd> <dd>
<code>b</code> - the second array to be tested for a mismatch</dd> <dd>
<code>bFromIndex</code> - the index (inclusive) of the first element in the second array to be tested</dd> <dd>
<code>bToIndex</code> - the index (exclusive) of the last element in the second array to be tested</dd> <dt>Returns:</dt> <dd>the relative index of the first mismatch between the two arrays over the specified ranges, otherwise <code>-1</code>.</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - if <code>aFromIndex &gt; aToIndex</code> or if <code>bFromIndex &gt; bToIndex</code>
</dd> <dd>
<code><a href="../lang/arrayindexoutofboundsexception">ArrayIndexOutOfBoundsException</a></code> - if <code>aFromIndex &lt; 0 or aToIndex &gt; a.length</code> or if <code>bFromIndex &lt; 0 or bToIndex &gt; b.length</code>
</dd> <dd>
<code><a href="../lang/nullpointerexception">NullPointerException</a></code> - if either array is <code>null</code>
</dd> <dt>Since:</dt> <dd>9</dd> </dl>    <h3 id="mismatch(double[],double[])">mismatch</h3> <pre data-language="java">public static int mismatch(double[] a,
                           double[] b)</pre> <div>
<p>Finds and returns the index of the first mismatch between two <code>double</code> arrays, otherwise return -1 if no mismatch is found. The index will be in the range of 0 (inclusive) up to the length (inclusive) of the smaller array. </p>
<p>If the two arrays share a common prefix then the returned index is the length of the common prefix and it follows that there is a mismatch between the two elements at that index within the respective arrays. If one array is a proper prefix of the other then the returned index is the length of the smaller array and it follows that the index is only valid for the larger array. Otherwise, there is no mismatch. </p>
<p>Two non-<code>null</code> arrays, <code>a</code> and <code>b</code>, share a common prefix of length <code>pl</code> if the following expression is true: </p>
<pre data-language="java">pl &gt;= 0 &amp;&amp;
     pl &lt; Math.min(a.length, b.length) &amp;&amp;
     Arrays.equals(a, 0, pl, b, 0, pl) &amp;&amp;
     Double.compare(a[pl], b[pl]) != 0</pre> Note that a common prefix length of <code>0</code> indicates that the first elements from each array mismatch. <p>Two non-<code>null</code> arrays, <code>a</code> and <code>b</code>, share a proper prefix if the following expression is true: </p>
<pre data-language="java">a.length != b.length &amp;&amp;
     Arrays.equals(a, 0, Math.min(a.length, b.length),
                   b, 0, Math.min(a.length, b.length))</pre>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the first array to be tested for a mismatch</dd> <dd>
<code>b</code> - the second array to be tested for a mismatch</dd> <dt>Returns:</dt> <dd>the index of the first mismatch between the two arrays, otherwise <code>-1</code>.</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/nullpointerexception">NullPointerException</a></code> - if either array is <code>null</code>
</dd> <dt>Since:</dt> <dd>9</dd> </dl>    <h3 id="mismatch(double[],int,int,double[],int,int)">mismatch</h3> <pre data-language="java">public static int mismatch(double[] a,
                           int aFromIndex,
                           int aToIndex,
                           double[] b,
                           int bFromIndex,
                           int bToIndex)</pre> <div>
<p>Finds and returns the relative index of the first mismatch between two <code>double</code> arrays over the specified ranges, otherwise return -1 if no mismatch is found. The index will be in the range of 0 (inclusive) up to the length (inclusive) of the smaller range. </p>
<p>If the two arrays, over the specified ranges, share a common prefix then the returned relative index is the length of the common prefix and it follows that there is a mismatch between the two elements at that relative index within the respective arrays. If one array is a proper prefix of the other, over the specified ranges, then the returned relative index is the length of the smaller range and it follows that the relative index is only valid for the array with the larger range. Otherwise, there is no mismatch. </p>
<p>Two non-<code>null</code> arrays, <code>a</code> and <code>b</code> with specified ranges [<code>aFromIndex</code>, <code>atoIndex</code>) and [<code>bFromIndex</code>, <code>btoIndex</code>) respectively, share a common prefix of length <code>pl</code> if the following expression is true: </p>
<pre data-language="java">pl &gt;= 0 &amp;&amp;
     pl &lt; Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) &amp;&amp;
     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) &amp;&amp;
     Double.compare(a[aFromIndex + pl], b[bFromIndex + pl]) != 0</pre> Note that a common prefix length of <code>0</code> indicates that the first elements from each array mismatch. <p>Two non-<code>null</code> arrays, <code>a</code> and <code>b</code> with specified ranges [<code>aFromIndex</code>, <code>atoIndex</code>) and [<code>bFromIndex</code>, <code>btoIndex</code>) respectively, share a proper if the following expression is true: </p>
<pre data-language="java">(aToIndex - aFromIndex) != (bToIndex - bFromIndex) &amp;&amp;
     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),
                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))</pre>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the first array to be tested for a mismatch</dd> <dd>
<code>aFromIndex</code> - the index (inclusive) of the first element in the first array to be tested</dd> <dd>
<code>aToIndex</code> - the index (exclusive) of the last element in the first array to be tested</dd> <dd>
<code>b</code> - the second array to be tested for a mismatch</dd> <dd>
<code>bFromIndex</code> - the index (inclusive) of the first element in the second array to be tested</dd> <dd>
<code>bToIndex</code> - the index (exclusive) of the last element in the second array to be tested</dd> <dt>Returns:</dt> <dd>the relative index of the first mismatch between the two arrays over the specified ranges, otherwise <code>-1</code>.</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - if <code>aFromIndex &gt; aToIndex</code> or if <code>bFromIndex &gt; bToIndex</code>
</dd> <dd>
<code><a href="../lang/arrayindexoutofboundsexception">ArrayIndexOutOfBoundsException</a></code> - if <code>aFromIndex &lt; 0 or aToIndex &gt; a.length</code> or if <code>bFromIndex &lt; 0 or bToIndex &gt; b.length</code>
</dd> <dd>
<code><a href="../lang/nullpointerexception">NullPointerException</a></code> - if either array is <code>null</code>
</dd> <dt>Since:</dt> <dd>9</dd> </dl>    <h3 id="mismatch(java.lang.Object[],java.lang.Object[])">mismatch</h3> <pre data-language="java">public static int mismatch(Object[] a,
                           Object[] b)</pre> <div>
<p>Finds and returns the index of the first mismatch between two <code>Object</code> arrays, otherwise return -1 if no mismatch is found. The index will be in the range of 0 (inclusive) up to the length (inclusive) of the smaller array. </p>
<p>If the two arrays share a common prefix then the returned index is the length of the common prefix and it follows that there is a mismatch between the two elements at that index within the respective arrays. If one array is a proper prefix of the other then the returned index is the length of the smaller array and it follows that the index is only valid for the larger array. Otherwise, there is no mismatch. </p>
<p>Two non-<code>null</code> arrays, <code>a</code> and <code>b</code>, share a common prefix of length <code>pl</code> if the following expression is true: </p>
<pre data-language="java">pl &gt;= 0 &amp;&amp;
     pl &lt; Math.min(a.length, b.length) &amp;&amp;
     Arrays.equals(a, 0, pl, b, 0, pl) &amp;&amp;
     !Objects.equals(a[pl], b[pl])</pre> Note that a common prefix length of <code>0</code> indicates that the first elements from each array mismatch. <p>Two non-<code>null</code> arrays, <code>a</code> and <code>b</code>, share a proper prefix if the following expression is true: </p>
<pre data-language="java">a.length != b.length &amp;&amp;
     Arrays.equals(a, 0, Math.min(a.length, b.length),
                   b, 0, Math.min(a.length, b.length))</pre>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the first array to be tested for a mismatch</dd> <dd>
<code>b</code> - the second array to be tested for a mismatch</dd> <dt>Returns:</dt> <dd>the index of the first mismatch between the two arrays, otherwise <code>-1</code>.</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/nullpointerexception">NullPointerException</a></code> - if either array is <code>null</code>
</dd> <dt>Since:</dt> <dd>9</dd> </dl>    <h3 id="mismatch(java.lang.Object[],int,int,java.lang.Object[],int,int)">mismatch</h3> <pre data-language="java">public static int mismatch(Object[] a,
                           int aFromIndex,
                           int aToIndex,
                           Object[] b,
                           int bFromIndex,
                           int bToIndex)</pre> <div>
<p>Finds and returns the relative index of the first mismatch between two <code>Object</code> arrays over the specified ranges, otherwise return -1 if no mismatch is found. The index will be in the range of 0 (inclusive) up to the length (inclusive) of the smaller range. </p>
<p>If the two arrays, over the specified ranges, share a common prefix then the returned relative index is the length of the common prefix and it follows that there is a mismatch between the two elements at that relative index within the respective arrays. If one array is a proper prefix of the other, over the specified ranges, then the returned relative index is the length of the smaller range and it follows that the relative index is only valid for the array with the larger range. Otherwise, there is no mismatch. </p>
<p>Two non-<code>null</code> arrays, <code>a</code> and <code>b</code> with specified ranges [<code>aFromIndex</code>, <code>atoIndex</code>) and [<code>bFromIndex</code>, <code>btoIndex</code>) respectively, share a common prefix of length <code>pl</code> if the following expression is true: </p>
<pre data-language="java">pl &gt;= 0 &amp;&amp;
     pl &lt; Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) &amp;&amp;
     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl) &amp;&amp;
     !Objects.equals(a[aFromIndex + pl], b[bFromIndex + pl])</pre> Note that a common prefix length of <code>0</code> indicates that the first elements from each array mismatch. <p>Two non-<code>null</code> arrays, <code>a</code> and <code>b</code> with specified ranges [<code>aFromIndex</code>, <code>atoIndex</code>) and [<code>bFromIndex</code>, <code>btoIndex</code>) respectively, share a proper if the following expression is true: </p>
<pre data-language="java">(aToIndex - aFromIndex) != (bToIndex - bFromIndex) &amp;&amp;
     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),
                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex))</pre>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>a</code> - the first array to be tested for a mismatch</dd> <dd>
<code>aFromIndex</code> - the index (inclusive) of the first element in the first array to be tested</dd> <dd>
<code>aToIndex</code> - the index (exclusive) of the last element in the first array to be tested</dd> <dd>
<code>b</code> - the second array to be tested for a mismatch</dd> <dd>
<code>bFromIndex</code> - the index (inclusive) of the first element in the second array to be tested</dd> <dd>
<code>bToIndex</code> - the index (exclusive) of the last element in the second array to be tested</dd> <dt>Returns:</dt> <dd>the relative index of the first mismatch between the two arrays over the specified ranges, otherwise <code>-1</code>.</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - if <code>aFromIndex &gt; aToIndex</code> or if <code>bFromIndex &gt; bToIndex</code>
</dd> <dd>
<code><a href="../lang/arrayindexoutofboundsexception">ArrayIndexOutOfBoundsException</a></code> - if <code>aFromIndex &lt; 0 or aToIndex &gt; a.length</code> or if <code>bFromIndex &lt; 0 or bToIndex &gt; b.length</code>
</dd> <dd>
<code><a href="../lang/nullpointerexception">NullPointerException</a></code> - if either array is <code>null</code>
</dd> <dt>Since:</dt> <dd>9</dd> </dl>    <h3 id="mismatch(java.lang.Object[],java.lang.Object[],java.util.Comparator)">mismatch</h3> <pre data-language="java">public static &lt;T&gt; int mismatch(T[] a,
                               T[] b,
                               Comparator&lt;? super T&gt; cmp)</pre> <div>
<p>Finds and returns the index of the first mismatch between two <code>Object</code> arrays, otherwise return -1 if no mismatch is found. The index will be in the range of 0 (inclusive) up to the length (inclusive) of the smaller array. </p>
<p>The specified comparator is used to determine if two array elements from the each array are not equal. </p>
<p>If the two arrays share a common prefix then the returned index is the length of the common prefix and it follows that there is a mismatch between the two elements at that index within the respective arrays. If one array is a proper prefix of the other then the returned index is the length of the smaller array and it follows that the index is only valid for the larger array. Otherwise, there is no mismatch. </p>
<p>Two non-<code>null</code> arrays, <code>a</code> and <code>b</code>, share a common prefix of length <code>pl</code> if the following expression is true: </p>
<pre data-language="java">pl &gt;= 0 &amp;&amp;
     pl &lt; Math.min(a.length, b.length) &amp;&amp;
     Arrays.equals(a, 0, pl, b, 0, pl, cmp)
     cmp.compare(a[pl], b[pl]) != 0</pre> Note that a common prefix length of <code>0</code> indicates that the first elements from each array mismatch. <p>Two non-<code>null</code> arrays, <code>a</code> and <code>b</code>, share a proper prefix if the following expression is true: </p>
<pre data-language="java">a.length != b.length &amp;&amp;
     Arrays.equals(a, 0, Math.min(a.length, b.length),
                   b, 0, Math.min(a.length, b.length),
                   cmp)</pre>
</div> <dl> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the type of array elements</dd> <dt>Parameters:</dt> <dd>
<code>a</code> - the first array to be tested for a mismatch</dd> <dd>
<code>b</code> - the second array to be tested for a mismatch</dd> <dd>
<code>cmp</code> - the comparator to compare array elements</dd> <dt>Returns:</dt> <dd>the index of the first mismatch between the two arrays, otherwise <code>-1</code>.</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/nullpointerexception">NullPointerException</a></code> - if either array or the comparator is <code>null</code>
</dd> <dt>Since:</dt> <dd>9</dd> </dl>    <h3 id="mismatch(java.lang.Object[],int,int,java.lang.Object[],int,int,java.util.Comparator)">mismatch</h3> <pre data-language="java">public static &lt;T&gt; int mismatch(T[] a,
                               int aFromIndex,
                               int aToIndex,
                               T[] b,
                               int bFromIndex,
                               int bToIndex,
                               Comparator&lt;? super T&gt; cmp)</pre> <div>
<p>Finds and returns the relative index of the first mismatch between two <code>Object</code> arrays over the specified ranges, otherwise return -1 if no mismatch is found. The index will be in the range of 0 (inclusive) up to the length (inclusive) of the smaller range. </p>
<p>If the two arrays, over the specified ranges, share a common prefix then the returned relative index is the length of the common prefix and it follows that there is a mismatch between the two elements at that relative index within the respective arrays. If one array is a proper prefix of the other, over the specified ranges, then the returned relative index is the length of the smaller range and it follows that the relative index is only valid for the array with the larger range. Otherwise, there is no mismatch. </p>
<p>Two non-<code>null</code> arrays, <code>a</code> and <code>b</code> with specified ranges [<code>aFromIndex</code>, <code>atoIndex</code>) and [<code>bFromIndex</code>, <code>btoIndex</code>) respectively, share a common prefix of length <code>pl</code> if the following expression is true: </p>
<pre data-language="java">pl &gt;= 0 &amp;&amp;
     pl &lt; Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex) &amp;&amp;
     Arrays.equals(a, aFromIndex, aFromIndex + pl, b, bFromIndex, bFromIndex + pl, cmp) &amp;&amp;
     cmp.compare(a[aFromIndex + pl], b[bFromIndex + pl]) != 0</pre> Note that a common prefix length of <code>0</code> indicates that the first elements from each array mismatch. <p>Two non-<code>null</code> arrays, <code>a</code> and <code>b</code> with specified ranges [<code>aFromIndex</code>, <code>atoIndex</code>) and [<code>bFromIndex</code>, <code>btoIndex</code>) respectively, share a proper if the following expression is true: </p>
<pre data-language="java">(aToIndex - aFromIndex) != (bToIndex - bFromIndex) &amp;&amp;
     Arrays.equals(a, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),
                   b, 0, Math.min(aToIndex - aFromIndex, bToIndex - bFromIndex),
                   cmp)</pre>
</div> <dl> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the type of array elements</dd> <dt>Parameters:</dt> <dd>
<code>a</code> - the first array to be tested for a mismatch</dd> <dd>
<code>aFromIndex</code> - the index (inclusive) of the first element in the first array to be tested</dd> <dd>
<code>aToIndex</code> - the index (exclusive) of the last element in the first array to be tested</dd> <dd>
<code>b</code> - the second array to be tested for a mismatch</dd> <dd>
<code>bFromIndex</code> - the index (inclusive) of the first element in the second array to be tested</dd> <dd>
<code>bToIndex</code> - the index (exclusive) of the last element in the second array to be tested</dd> <dd>
<code>cmp</code> - the comparator to compare array elements</dd> <dt>Returns:</dt> <dd>the relative index of the first mismatch between the two arrays over the specified ranges, otherwise <code>-1</code>.</dd> <dt>Throws:</dt> <dd>
<code><a href="../lang/illegalargumentexception">IllegalArgumentException</a></code> - if <code>aFromIndex &gt; aToIndex</code> or if <code>bFromIndex &gt; bToIndex</code>
</dd> <dd>
<code><a href="../lang/arrayindexoutofboundsexception">ArrayIndexOutOfBoundsException</a></code> - if <code>aFromIndex &lt; 0 or aToIndex &gt; a.length</code> or if <code>bFromIndex &lt; 0 or bToIndex &gt; b.length</code>
</dd> <dd>
<code><a href="../lang/nullpointerexception">NullPointerException</a></code> - if either array or the comparator is <code>null</code>
</dd> <dt>Since:</dt> <dd>9</dd> </dl>   </section>  </div>  </main>  <div class="_attribution">
  <p class="_attribution-p">
    &copy; 1993, 2020, Oracle and/or its affiliates. All rights reserved.<br>Documentation extracted from Debian's OpenJDK Development Kit package.<br>Licensed under the GNU General Public License, version 2, with the Classpath Exception.<br>Various third party code in OpenJDK is licensed under different licenses (see Debian package).<br>Java and OpenJDK are trademarks or registered trademarks of Oracle and/or its affiliates.<br>
    <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Arrays.html" class="_attribution-link">https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Arrays.html</a>
  </p>
</div>
