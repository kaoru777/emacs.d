  <main role="main">    <h1>Class Area</h1>   <ul class="inheritance"> <li><a href="../../../../java.base/java/lang/object">java.lang.Object</a></li> <li> <ul class="inheritance"> <li>java.awt.geom.Area</li> </ul> </li> </ul>   <dl> <dt>All Implemented Interfaces:</dt> <dd>
<code><a href="../shape">Shape</a></code>, <code><a href="../../../../java.base/java/lang/cloneable">Cloneable</a></code>
</dd> </dl>  <pre data-language="java">public class Area
extends Object
implements Shape, Cloneable</pre> <div>
<p>An <code>Area</code> object stores and manipulates a resolution-independent description of an enclosed area of 2-dimensional space. <code>Area</code> objects can be transformed and can perform various Constructive Area Geometry (CAG) operations when combined with other <code>Area</code> objects. The CAG operations include area <a href="#add(java.awt.geom.Area)"><code>addition</code></a>, <a href="#subtract(java.awt.geom.Area)"><code>subtraction</code></a>, <a href="#intersect(java.awt.geom.Area)"><code>intersection</code></a>, and <a href="#exclusiveOr(java.awt.geom.Area)"><code>exclusive or</code></a>. See the linked method documentation for examples of the various operations. </p>
<p> The <code>Area</code> class implements the <code>Shape</code> interface and provides full support for all of its hit-testing and path iteration facilities, but an <code>Area</code> is more specific than a generalized path in a number of ways: </p>
<ul> <li>Only closed paths and sub-paths are stored. <code>Area</code> objects constructed from unclosed paths are implicitly closed during construction as if those paths had been filled by the <code>Graphics2D.fill</code> method. </li>
<li>The interiors of the individual stored sub-paths are all non-empty and non-overlapping. Paths are decomposed during construction into separate component non-overlapping parts, empty pieces of the path are discarded, and then these non-empty and non-overlapping properties are maintained through all subsequent CAG operations. Outlines of different component sub-paths may touch each other, as long as they do not cross so that their enclosed areas overlap. </li>
<li>The geometry of the path describing the outline of the <code>Area</code> resembles the path from which it was constructed only in that it describes the same enclosed 2-dimensional area, but may use entirely different types and ordering of the path segments to do so. </li>
</ul> Interesting issues which are not always obvious when using the <code>Area</code> include: <ul> <li>Creating an <code>Area</code> from an unclosed (open) <code>Shape</code> results in a closed outline in the <code>Area</code> object. </li>
<li>Creating an <code>Area</code> from a <code>Shape</code> which encloses no area (even when "closed") produces an empty <code>Area</code>. A common example of this issue is that producing an <code>Area</code> from a line will be empty since the line encloses no area. An empty <code>Area</code> will iterate no geometry in its <code>PathIterator</code> objects. </li>
<li>A self-intersecting <code>Shape</code> may be split into two (or more) sub-paths each enclosing one of the non-intersecting portions of the original path. </li>
<li>An <code>Area</code> may take more path segments to describe the same geometry even when the original outline is simple and obvious. The analysis that the <code>Area</code> class must perform on the path may not reflect the same concepts of "simple and obvious" as a human being perceives. </li>
</ul>
</div> <dl> <dt>Since:</dt> <dd>1.2</dd> </dl>      <section role="region">  <h2 id="constructor.summary">Constructors</h2> <table>  <tr> <th scope="col">Constructor</th> <th scope="col">Description</th> </tr> <tr> <th scope="row"><code><a href="#%3Cinit%3E()">Area</a>()</code></th> <td> <p>Default constructor which creates an empty area.</p> </td> </tr> <tr> <th scope="row"><code><a href="#%3Cinit%3E(java.awt.Shape)">Area</a>​(<a href="../shape">Shape</a> s)</code></th> <td> <p>The <code>Area</code> class creates an area geometry from the specified <a href="../shape"><code>Shape</code></a> object.</p> </td> </tr> </table>  </section>  <section role="region">  <h2 id="method.summary">Methods</h2> <table>  <tr> <th scope="col">Modifier and Type</th> <th scope="col">Method</th> <th scope="col">Description</th> </tr> <tr id="i0"> <td><code>void</code></td> <th scope="row"><code><a href="#add(java.awt.geom.Area)">add</a>​(<a href="area">Area</a> rhs)</code></th> <td> <p>Adds the shape of the specified <code>Area</code> to the shape of this <code>Area</code>.</p> </td> </tr> <tr id="i1"> <td><code><a href="../../../../java.base/java/lang/object">Object</a></code></td> <th scope="row"><code><a href="#clone()">clone</a>()</code></th> <td> <p>Returns an exact copy of this <code>Area</code> object.</p> </td> </tr> <tr id="i2"> <td><code>boolean</code></td> <th scope="row"><code><a href="#contains(double,double)">contains</a>​(double x,
        double y)</code></th> <td> <p>Tests if the specified coordinates are inside the boundary of the <code>Shape</code>, as described by the <a href="../shape#def_insideness"> definition of insideness</a>.</p> </td> </tr> <tr id="i3"> <td><code>boolean</code></td> <th scope="row"><code><a href="#contains(double,double,double,double)">contains</a>​(double x,
        double y,
        double w,
        double h)</code></th> <td> <p>Tests if the interior of the <code>Shape</code> entirely contains the specified rectangular area.</p> </td> </tr> <tr id="i4"> <td><code>boolean</code></td> <th scope="row"><code><a href="#contains(java.awt.geom.Point2D)">contains</a>​(<a href="point2d">Point2D</a> p)</code></th> <td> <p>Tests if a specified <a href="point2d"><code>Point2D</code></a> is inside the boundary of the <code>Shape</code>, as described by the <a href="../shape#def_insideness"> definition of insideness</a>.</p> </td> </tr> <tr id="i5"> <td><code>boolean</code></td> <th scope="row"><code><a href="#contains(java.awt.geom.Rectangle2D)">contains</a>​(<a href="rectangle2d">Rectangle2D</a> r)</code></th> <td> <p>Tests if the interior of the <code>Shape</code> entirely contains the specified <code>Rectangle2D</code>.</p> </td> </tr> <tr id="i6"> <td><code><a href="area">Area</a></code></td> <th scope="row"><code><a href="#createTransformedArea(java.awt.geom.AffineTransform)">createTransformedArea</a>​(<a href="affinetransform">AffineTransform</a> t)</code></th> <td> <p>Creates a new <code>Area</code> object that contains the same geometry as this <code>Area</code> transformed by the specified <code>AffineTransform</code>.</p> </td> </tr> <tr id="i7"> <td><code>boolean</code></td> <th scope="row"><code><a href="#equals(java.awt.geom.Area)">equals</a>​(<a href="area">Area</a> other)</code></th> <td> <p>Tests whether the geometries of the two <code>Area</code> objects are equal.</p> </td> </tr> <tr id="i8"> <td><code>void</code></td> <th scope="row"><code><a href="#exclusiveOr(java.awt.geom.Area)">exclusiveOr</a>​(<a href="area">Area</a> rhs)</code></th> <td> <p>Sets the shape of this <code>Area</code> to be the combined area of its current shape and the shape of the specified <code>Area</code>, minus their intersection.</p> </td> </tr> <tr id="i9"> <td><code><a href="../rectangle">Rectangle</a></code></td> <th scope="row"><code><a href="#getBounds()">getBounds</a>()</code></th> <td> <p>Returns a bounding <a href="../rectangle"><code>Rectangle</code></a> that completely encloses this <code>Area</code>.</p> </td> </tr> <tr id="i10"> <td><code><a href="rectangle2d">Rectangle2D</a></code></td> <th scope="row"><code><a href="#getBounds2D()">getBounds2D</a>()</code></th> <td> <p>Returns a high precision bounding <a href="rectangle2d"><code>Rectangle2D</code></a> that completely encloses this <code>Area</code>.</p> </td> </tr> <tr id="i11"> <td><code><a href="pathiterator">PathIterator</a></code></td> <th scope="row"><code><a href="#getPathIterator(java.awt.geom.AffineTransform)">getPathIterator</a>​(<a href="affinetransform">AffineTransform</a> at)</code></th> <td> <p>Creates a <a href="pathiterator"><code>PathIterator</code></a> for the outline of this <code>Area</code> object.</p> </td> </tr> <tr id="i12"> <td><code><a href="pathiterator">PathIterator</a></code></td> <th scope="row"><code><a href="#getPathIterator(java.awt.geom.AffineTransform,double)">getPathIterator</a>​(<a href="affinetransform">AffineTransform</a> at,
               double flatness)</code></th> <td> <p>Creates a <code>PathIterator</code> for the flattened outline of this <code>Area</code> object.</p> </td> </tr> <tr id="i13"> <td><code>void</code></td> <th scope="row"><code><a href="#intersect(java.awt.geom.Area)">intersect</a>​(<a href="area">Area</a> rhs)</code></th> <td> <p>Sets the shape of this <code>Area</code> to the intersection of its current shape and the shape of the specified <code>Area</code>.</p> </td> </tr> <tr id="i14"> <td><code>boolean</code></td> <th scope="row"><code><a href="#intersects(double,double,double,double)">intersects</a>​(double x,
          double y,
          double w,
          double h)</code></th> <td> <p>Tests if the interior of the <code>Shape</code> intersects the interior of a specified rectangular area.</p> </td> </tr> <tr id="i15"> <td><code>boolean</code></td> <th scope="row"><code><a href="#intersects(java.awt.geom.Rectangle2D)">intersects</a>​(<a href="rectangle2d">Rectangle2D</a> r)</code></th> <td> <p>Tests if the interior of the <code>Shape</code> intersects the interior of a specified <code>Rectangle2D</code>.</p> </td> </tr> <tr id="i16"> <td><code>boolean</code></td> <th scope="row"><code><a href="#isEmpty()">isEmpty</a>()</code></th> <td> <p>Tests whether this <code>Area</code> object encloses any area.</p> </td> </tr> <tr id="i17"> <td><code>boolean</code></td> <th scope="row"><code><a href="#isPolygonal()">isPolygonal</a>()</code></th> <td> <p>Tests whether this <code>Area</code> consists entirely of straight edged polygonal geometry.</p> </td> </tr> <tr id="i18"> <td><code>boolean</code></td> <th scope="row"><code><a href="#isRectangular()">isRectangular</a>()</code></th> <td> <p>Tests whether this <code>Area</code> is rectangular in shape.</p> </td> </tr> <tr id="i19"> <td><code>boolean</code></td> <th scope="row"><code><a href="#isSingular()">isSingular</a>()</code></th> <td> <p>Tests whether this <code>Area</code> is comprised of a single closed subpath.</p> </td> </tr> <tr id="i20"> <td><code>void</code></td> <th scope="row"><code><a href="#reset()">reset</a>()</code></th> <td> <p>Removes all of the geometry from this <code>Area</code> and restores it to an empty area.</p> </td> </tr> <tr id="i21"> <td><code>void</code></td> <th scope="row"><code><a href="#subtract(java.awt.geom.Area)">subtract</a>​(<a href="area">Area</a> rhs)</code></th> <td> <p>Subtracts the shape of the specified <code>Area</code> from the shape of this <code>Area</code>.</p> </td> </tr> <tr id="i22"> <td><code>void</code></td> <th scope="row"><code><a href="#transform(java.awt.geom.AffineTransform)">transform</a>​(<a href="affinetransform">AffineTransform</a> t)</code></th> <td> <p>Transforms the geometry of this <code>Area</code> using the specified <a href="affinetransform"><code>AffineTransform</code></a>.</p> </td> </tr> </table>  <h2 id="methods.inherited.from.class.java.lang.Object">Methods declared in class java.lang.<a href="../../../../java.base/java/lang/object">Object</a>
</h2> <code><a href="../../../../java.base/java/lang/object#equals(java.lang.Object)">equals</a>, <a href="../../../../java.base/java/lang/object#finalize()">finalize</a>, <a href="../../../../java.base/java/lang/object#getClass()">getClass</a>, <a href="../../../../java.base/java/lang/object#hashCode()">hashCode</a>, <a href="../../../../java.base/java/lang/object#notify()">notify</a>, <a href="../../../../java.base/java/lang/object#notifyAll()">notifyAll</a>, <a href="../../../../java.base/java/lang/object#toString()">toString</a>, <a href="../../../../java.base/java/lang/object#wait()">wait</a>, <a href="../../../../java.base/java/lang/object#wait(long)">wait</a>, <a href="../../../../java.base/java/lang/object#wait(long,int)">wait</a></code>  </section>   <div>   <section role="region">  <h2 id="constructor.detail">Constructors</h2>   <h3 id="&lt;init&gt;()">Area</h3> <pre data-language="java">public Area()</pre> <p>Default constructor which creates an empty area.</p> <dl> <dt>Since:</dt> <dd>1.2</dd> </dl>    <h3 id="&lt;init&gt;(java.awt.Shape)">Area</h3> <pre data-language="java">public Area(Shape s)</pre> <p>The <code>Area</code> class creates an area geometry from the specified <a href="../shape"><code>Shape</code></a> object. The geometry is explicitly closed, if the <code>Shape</code> is not already closed. The fill rule (even-odd or winding) specified by the geometry of the <code>Shape</code> is used to determine the resulting enclosed area.</p> <dl> <dt>Parameters:</dt> <dd>
<code>s</code> - the <code>Shape</code> from which the area is constructed</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.base/java/lang/nullpointerexception">NullPointerException</a></code> - if <code>s</code> is null</dd> <dt>Since:</dt> <dd>1.2</dd> </dl>   </section>  <section role="region">  <h2 id="method.detail">Methods</h2>   <h3 id="add(java.awt.geom.Area)">add</h3> <pre data-language="java">public void add(Area rhs)</pre> <p>Adds the shape of the specified <code>Area</code> to the shape of this <code>Area</code>. The resulting shape of this <code>Area</code> will include the union of both shapes, or all areas that were contained in either this or the specified <code>Area</code>. <pre data-language="java">// Example:
     Area a1 = new Area([triangle 0,0 =&gt; 8,0 =&gt; 0,8]);
     Area a2 = new Area([triangle 0,0 =&gt; 8,0 =&gt; 8,8]);
     a1.add(a2);

        a1(before)     +         a2         =     a1(after)

     ################     ################     ################
     ##############         ##############     ################
     ############             ############     ################
     ##########                 ##########     ################
     ########                     ########     ################
     ######                         ######     ######    ######
     ####                             ####     ####        ####
     ##                                 ##     ##            ##</pre></p> <dl> <dt>Parameters:</dt> <dd>
<code>rhs</code> - the <code>Area</code> to be added to the current shape</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.base/java/lang/nullpointerexception">NullPointerException</a></code> - if <code>rhs</code> is null</dd> <dt>Since:</dt> <dd>1.2</dd> </dl>    <h3 id="subtract(java.awt.geom.Area)">subtract</h3> <pre data-language="java">public void subtract(Area rhs)</pre> <p>Subtracts the shape of the specified <code>Area</code> from the shape of this <code>Area</code>. The resulting shape of this <code>Area</code> will include areas that were contained only in this <code>Area</code> and not in the specified <code>Area</code>. <pre data-language="java">// Example:
     Area a1 = new Area([triangle 0,0 =&gt; 8,0 =&gt; 0,8]);
     Area a2 = new Area([triangle 0,0 =&gt; 8,0 =&gt; 8,8]);
     a1.subtract(a2);

        a1(before)     -         a2         =     a1(after)

     ################     ################
     ##############         ##############     ##
     ############             ############     ####
     ##########                 ##########     ######
     ########                     ########     ########
     ######                         ######     ######
     ####                             ####     ####
     ##                                 ##     ##</pre></p> <dl> <dt>Parameters:</dt> <dd>
<code>rhs</code> - the <code>Area</code> to be subtracted from the current shape</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.base/java/lang/nullpointerexception">NullPointerException</a></code> - if <code>rhs</code> is null</dd> <dt>Since:</dt> <dd>1.2</dd> </dl>    <h3 id="intersect(java.awt.geom.Area)">intersect</h3> <pre data-language="java">public void intersect(Area rhs)</pre> <p>Sets the shape of this <code>Area</code> to the intersection of its current shape and the shape of the specified <code>Area</code>. The resulting shape of this <code>Area</code> will include only areas that were contained in both this <code>Area</code> and also in the specified <code>Area</code>. <pre data-language="java">// Example:
     Area a1 = new Area([triangle 0,0 =&gt; 8,0 =&gt; 0,8]);
     Area a2 = new Area([triangle 0,0 =&gt; 8,0 =&gt; 8,8]);
     a1.intersect(a2);

      a1(before)   intersect     a2         =     a1(after)

     ################     ################     ################
     ##############         ##############       ############
     ############             ############         ########
     ##########                 ##########           ####
     ########                     ########
     ######                         ######
     ####                             ####
     ##                                 ##</pre></p> <dl> <dt>Parameters:</dt> <dd>
<code>rhs</code> - the <code>Area</code> to be intersected with this <code>Area</code>
</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.base/java/lang/nullpointerexception">NullPointerException</a></code> - if <code>rhs</code> is null</dd> <dt>Since:</dt> <dd>1.2</dd> </dl>    <h3 id="exclusiveOr(java.awt.geom.Area)">exclusiveOr</h3> <pre data-language="java">public void exclusiveOr(Area rhs)</pre> <p>Sets the shape of this <code>Area</code> to be the combined area of its current shape and the shape of the specified <code>Area</code>, minus their intersection. The resulting shape of this <code>Area</code> will include only areas that were contained in either this <code>Area</code> or in the specified <code>Area</code>, but not in both. <pre data-language="java">// Example:
     Area a1 = new Area([triangle 0,0 =&gt; 8,0 =&gt; 0,8]);
     Area a2 = new Area([triangle 0,0 =&gt; 8,0 =&gt; 8,8]);
     a1.exclusiveOr(a2);

        a1(before)    xor        a2         =     a1(after)

     ################     ################
     ##############         ##############     ##            ##
     ############             ############     ####        ####
     ##########                 ##########     ######    ######
     ########                     ########     ################
     ######                         ######     ######    ######
     ####                             ####     ####        ####
     ##                                 ##     ##            ##</pre></p> <dl> <dt>Parameters:</dt> <dd>
<code>rhs</code> - the <code>Area</code> to be exclusive ORed with this <code>Area</code>.</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.base/java/lang/nullpointerexception">NullPointerException</a></code> - if <code>rhs</code> is null</dd> <dt>Since:</dt> <dd>1.2</dd> </dl>    <h3 id="reset()">reset</h3> <pre data-language="java">public void reset()</pre> <p>Removes all of the geometry from this <code>Area</code> and restores it to an empty area.</p> <dl> <dt>Since:</dt> <dd>1.2</dd> </dl>    <h3 id="isEmpty()">isEmpty</h3> <pre data-language="java">public boolean isEmpty()</pre> <p>Tests whether this <code>Area</code> object encloses any area.</p> <dl> <dt>Returns:</dt> <dd>
<code>true</code> if this <code>Area</code> object represents an empty area; <code>false</code> otherwise.</dd> <dt>Since:</dt> <dd>1.2</dd> </dl>    <h3 id="isPolygonal()">isPolygonal</h3> <pre data-language="java">public boolean isPolygonal()</pre> <p>Tests whether this <code>Area</code> consists entirely of straight edged polygonal geometry.</p> <dl> <dt>Returns:</dt> <dd>
<code>true</code> if the geometry of this <code>Area</code> consists entirely of line segments; <code>false</code> otherwise.</dd> <dt>Since:</dt> <dd>1.2</dd> </dl>    <h3 id="isRectangular()">isRectangular</h3> <pre data-language="java">public boolean isRectangular()</pre> <p>Tests whether this <code>Area</code> is rectangular in shape.</p> <dl> <dt>Returns:</dt> <dd>
<code>true</code> if the geometry of this <code>Area</code> is rectangular in shape; <code>false</code> otherwise.</dd> <dt>Since:</dt> <dd>1.2</dd> </dl>    <h3 id="isSingular()">isSingular</h3> <pre data-language="java">public boolean isSingular()</pre> <p>Tests whether this <code>Area</code> is comprised of a single closed subpath. This method returns <code>true</code> if the path contains 0 or 1 subpaths, or <code>false</code> if the path contains more than 1 subpath. The subpaths are counted by the number of <a href="pathiterator#SEG_MOVETO"><code>SEG_MOVETO</code></a> segments that appear in the path.</p> <dl> <dt>Returns:</dt> <dd>
<code>true</code> if the <code>Area</code> is comprised of a single basic geometry; <code>false</code> otherwise.</dd> <dt>Since:</dt> <dd>1.2</dd> </dl>    <h3 id="getBounds2D()">getBounds2D</h3> <pre data-language="java">public Rectangle2D getBounds2D()</pre> <div>
<p>Returns a high precision bounding <a href="rectangle2d"><code>Rectangle2D</code></a> that completely encloses this <code>Area</code>. </p>
<p> The Area class will attempt to return the tightest bounding box possible for the Shape. The bounding box will not be padded to include the control points of curves in the outline of the Shape, but should tightly fit the actual geometry of the outline itself.</p>
</div> <dl> <dt>Specified by:</dt> <dd>
<code><a href="../shape#getBounds2D()">getBounds2D</a></code> in interface <code><a href="../shape">Shape</a></code>
</dd> <dt>Returns:</dt> <dd>the bounding <code>Rectangle2D</code> for the <code>Area</code>.</dd> <dt>Since:</dt> <dd>1.2</dd> <dt>See Also:</dt> <dd><a href="../shape#getBounds()"><code>Shape.getBounds()</code></a></dd> </dl>    <h3 id="getBounds()">getBounds</h3> <pre data-language="java">public Rectangle getBounds()</pre> <div>
<p>Returns a bounding <a href="../rectangle"><code>Rectangle</code></a> that completely encloses this <code>Area</code>. </p>
<p> The Area class will attempt to return the tightest bounding box possible for the Shape. The bounding box will not be padded to include the control points of curves in the outline of the Shape, but should tightly fit the actual geometry of the outline itself. Since the returned object represents the bounding box with integers, the bounding box can only be as tight as the nearest integer coordinates that encompass the geometry of the Shape.</p>
</div> <dl> <dt>Specified by:</dt> <dd>
<code><a href="../shape#getBounds()">getBounds</a></code> in interface <code><a href="../shape">Shape</a></code>
</dd> <dt>Returns:</dt> <dd>the bounding <code>Rectangle</code> for the <code>Area</code>.</dd> <dt>Since:</dt> <dd>1.2</dd> <dt>See Also:</dt> <dd><a href="../shape#getBounds2D()"><code>Shape.getBounds2D()</code></a></dd> </dl>    <h3 id="clone()">clone</h3> <pre data-language="java">public Object clone()</pre> <p>Returns an exact copy of this <code>Area</code> object.</p> <dl> <dt>Overrides:</dt> <dd>
<code><a href="../../../../java.base/java/lang/object#clone()">clone</a></code> in class <code><a href="../../../../java.base/java/lang/object">Object</a></code>
</dd> <dt>Returns:</dt> <dd>Created clone object</dd> <dt>Since:</dt> <dd>1.2</dd> <dt>See Also:</dt> <dd><a href="../../../../java.base/java/lang/cloneable"><code>Cloneable</code></a></dd> </dl>    <h3 id="equals(java.awt.geom.Area)">equals</h3> <pre data-language="java">public boolean equals(Area other)</pre> <p>Tests whether the geometries of the two <code>Area</code> objects are equal. This method will return false if the argument is null.</p> <dl> <dt>Parameters:</dt> <dd>
<code>other</code> - the <code>Area</code> to be compared to this <code>Area</code>
</dd> <dt>Returns:</dt> <dd>
<code>true</code> if the two geometries are equal; <code>false</code> otherwise.</dd> <dt>Since:</dt> <dd>1.2</dd> </dl>    <h3 id="transform(java.awt.geom.AffineTransform)">transform</h3> <pre data-language="java">public void transform(AffineTransform t)</pre> <p>Transforms the geometry of this <code>Area</code> using the specified <a href="affinetransform"><code>AffineTransform</code></a>. The geometry is transformed in place, which permanently changes the enclosed area defined by this object.</p> <dl> <dt>Parameters:</dt> <dd>
<code>t</code> - the transformation used to transform the area</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.base/java/lang/nullpointerexception">NullPointerException</a></code> - if <code>t</code> is null</dd> <dt>Since:</dt> <dd>1.2</dd> </dl>    <h3 id="createTransformedArea(java.awt.geom.AffineTransform)">createTransformedArea</h3> <pre data-language="java">public Area createTransformedArea(AffineTransform t)</pre> <p>Creates a new <code>Area</code> object that contains the same geometry as this <code>Area</code> transformed by the specified <code>AffineTransform</code>. This <code>Area</code> object is unchanged.</p> <dl> <dt>Parameters:</dt> <dd>
<code>t</code> - the specified <code>AffineTransform</code> used to transform the new <code>Area</code>
</dd> <dt>Returns:</dt> <dd>a new <code>Area</code> object representing the transformed geometry.</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.base/java/lang/nullpointerexception">NullPointerException</a></code> - if <code>t</code> is null</dd> <dt>Since:</dt> <dd>1.2</dd> </dl>    <h3 id="contains(double,double)">contains</h3> <pre data-language="java">public boolean contains(double x,
                        double y)</pre> <p>Tests if the specified coordinates are inside the boundary of the <code>Shape</code>, as described by the <a href="../shape#def_insideness"> definition of insideness</a>.</p> <dl> <dt>Specified by:</dt> <dd>
<code><a href="../shape#contains(double,double)">contains</a></code> in interface <code><a href="../shape">Shape</a></code>
</dd> <dt>Parameters:</dt> <dd>
<code>x</code> - the specified X coordinate to be tested</dd> <dd>
<code>y</code> - the specified Y coordinate to be tested</dd> <dt>Returns:</dt> <dd>
<code>true</code> if the specified coordinates are inside the <code>Shape</code> boundary; <code>false</code> otherwise.</dd> <dt>Since:</dt> <dd>1.2</dd> </dl>    <h3 id="contains(java.awt.geom.Point2D)">contains</h3> <pre data-language="java">public boolean contains(Point2D p)</pre> <p>Tests if a specified <a href="point2d"><code>Point2D</code></a> is inside the boundary of the <code>Shape</code>, as described by the <a href="../shape#def_insideness"> definition of insideness</a>.</p> <dl> <dt>Specified by:</dt> <dd>
<code><a href="../shape#contains(java.awt.geom.Point2D)">contains</a></code> in interface <code><a href="../shape">Shape</a></code>
</dd> <dt>Parameters:</dt> <dd>
<code>p</code> - the specified <code>Point2D</code> to be tested</dd> <dt>Returns:</dt> <dd>
<code>true</code> if the specified <code>Point2D</code> is inside the boundary of the <code>Shape</code>; <code>false</code> otherwise.</dd> <dt>Since:</dt> <dd>1.2</dd> </dl>    <h3 id="contains(double,double,double,double)">contains</h3> <pre data-language="java">public boolean contains(double x,
                        double y,
                        double w,
                        double h)</pre> <div>
<p>Tests if the interior of the <code>Shape</code> entirely contains the specified rectangular area. All coordinates that lie inside the rectangular area must lie within the <code>Shape</code> for the entire rectangular area to be considered contained within the <code>Shape</code>. </p>
<p> The <code>Shape.contains()</code> method allows a <code>Shape</code> implementation to conservatively return <code>false</code> when: </p>
<ul> <li> the <code>intersect</code> method returns <code>true</code> and </li>
<li> the calculations to determine whether or not the <code>Shape</code> entirely contains the rectangular area are prohibitively expensive. </li>
</ul> This means that for some <code>Shapes</code> this method might return <code>false</code> even though the <code>Shape</code> contains the rectangular area. The <a href="area"><code>Area</code></a> class performs more accurate geometric computations than most <code>Shape</code> objects and therefore can be used if a more precise answer is required.</div> <dl> <dt>Specified by:</dt> <dd>
<code><a href="../shape#contains(double,double,double,double)">contains</a></code> in interface <code><a href="../shape">Shape</a></code>
</dd> <dt>Parameters:</dt> <dd>
<code>x</code> - the X coordinate of the upper-left corner of the specified rectangular area</dd> <dd>
<code>y</code> - the Y coordinate of the upper-left corner of the specified rectangular area</dd> <dd>
<code>w</code> - the width of the specified rectangular area</dd> <dd>
<code>h</code> - the height of the specified rectangular area</dd> <dt>Returns:</dt> <dd>
<code>true</code> if the interior of the <code>Shape</code> entirely contains the specified rectangular area; <code>false</code> otherwise or, if the <code>Shape</code> contains the rectangular area and the <code>intersects</code> method returns <code>true</code> and the containment calculations would be too expensive to perform.</dd> <dt>Since:</dt> <dd>1.2</dd> <dt>See Also:</dt> <dd>
<a href="area"><code>Area</code></a>, <a href="../shape#intersects(double,double,double,double)"><code>Shape.intersects(double, double, double, double)</code></a>
</dd> </dl>    <h3 id="contains(java.awt.geom.Rectangle2D)">contains</h3> <pre data-language="java">public boolean contains(Rectangle2D r)</pre> <p>Tests if the interior of the <code>Shape</code> entirely contains the specified <code>Rectangle2D</code>. The <code>Shape.contains()</code> method allows a <code>Shape</code> implementation to conservatively return <code>false</code> when: <ul> <li> the <code>intersect</code> method returns <code>true</code> and </li>
<li> the calculations to determine whether or not the <code>Shape</code> entirely contains the <code>Rectangle2D</code> are prohibitively expensive. </li>
</ul> This means that for some <code>Shapes</code> this method might return <code>false</code> even though the <code>Shape</code> contains the <code>Rectangle2D</code>. The <a href="area"><code>Area</code></a> class performs more accurate geometric computations than most <code>Shape</code> objects and therefore can be used if a more precise answer is required.</p> <dl> <dt>Specified by:</dt> <dd>
<code><a href="../shape#contains(java.awt.geom.Rectangle2D)">contains</a></code> in interface <code><a href="../shape">Shape</a></code>
</dd> <dt>Parameters:</dt> <dd>
<code>r</code> - The specified <code>Rectangle2D</code>
</dd> <dt>Returns:</dt> <dd>
<code>true</code> if the interior of the <code>Shape</code> entirely contains the <code>Rectangle2D</code>; <code>false</code> otherwise or, if the <code>Shape</code> contains the <code>Rectangle2D</code> and the <code>intersects</code> method returns <code>true</code> and the containment calculations would be too expensive to perform.</dd> <dt>Since:</dt> <dd>1.2</dd> <dt>See Also:</dt> <dd><a href="../shape#contains(double,double,double,double)"><code>Shape.contains(double, double, double, double)</code></a></dd> </dl>    <h3 id="intersects(double,double,double,double)">intersects</h3> <pre data-language="java">public boolean intersects(double x,
                          double y,
                          double w,
                          double h)</pre> <div>
<p>Tests if the interior of the <code>Shape</code> intersects the interior of a specified rectangular area. The rectangular area is considered to intersect the <code>Shape</code> if any point is contained in both the interior of the <code>Shape</code> and the specified rectangular area. </p>
<p> The <code>Shape.intersects()</code> method allows a <code>Shape</code> implementation to conservatively return <code>true</code> when: </p>
<ul> <li> there is a high probability that the rectangular area and the <code>Shape</code> intersect, but </li>
<li> the calculations to accurately determine this intersection are prohibitively expensive. </li>
</ul> This means that for some <code>Shapes</code> this method might return <code>true</code> even though the rectangular area does not intersect the <code>Shape</code>. The <a href="area"><code>Area</code></a> class performs more accurate computations of geometric intersection than most <code>Shape</code> objects and therefore can be used if a more precise answer is required.</div> <dl> <dt>Specified by:</dt> <dd>
<code><a href="../shape#intersects(double,double,double,double)">intersects</a></code> in interface <code><a href="../shape">Shape</a></code>
</dd> <dt>Parameters:</dt> <dd>
<code>x</code> - the X coordinate of the upper-left corner of the specified rectangular area</dd> <dd>
<code>y</code> - the Y coordinate of the upper-left corner of the specified rectangular area</dd> <dd>
<code>w</code> - the width of the specified rectangular area</dd> <dd>
<code>h</code> - the height of the specified rectangular area</dd> <dt>Returns:</dt> <dd>
<code>true</code> if the interior of the <code>Shape</code> and the interior of the rectangular area intersect, or are both highly likely to intersect and intersection calculations would be too expensive to perform; <code>false</code> otherwise.</dd> <dt>Since:</dt> <dd>1.2</dd> <dt>See Also:</dt> <dd><a href="area"><code>Area</code></a></dd> </dl>    <h3 id="intersects(java.awt.geom.Rectangle2D)">intersects</h3> <pre data-language="java">public boolean intersects(Rectangle2D r)</pre> <p>Tests if the interior of the <code>Shape</code> intersects the interior of a specified <code>Rectangle2D</code>. The <code>Shape.intersects()</code> method allows a <code>Shape</code> implementation to conservatively return <code>true</code> when: <ul> <li> there is a high probability that the <code>Rectangle2D</code> and the <code>Shape</code> intersect, but </li>
<li> the calculations to accurately determine this intersection are prohibitively expensive. </li>
</ul> This means that for some <code>Shapes</code> this method might return <code>true</code> even though the <code>Rectangle2D</code> does not intersect the <code>Shape</code>. The <a href="area"><code>Area</code></a> class performs more accurate computations of geometric intersection than most <code>Shape</code> objects and therefore can be used if a more precise answer is required.</p> <dl> <dt>Specified by:</dt> <dd>
<code><a href="../shape#intersects(java.awt.geom.Rectangle2D)">intersects</a></code> in interface <code><a href="../shape">Shape</a></code>
</dd> <dt>Parameters:</dt> <dd>
<code>r</code> - the specified <code>Rectangle2D</code>
</dd> <dt>Returns:</dt> <dd>
<code>true</code> if the interior of the <code>Shape</code> and the interior of the specified <code>Rectangle2D</code> intersect, or are both highly likely to intersect and intersection calculations would be too expensive to perform; <code>false</code> otherwise.</dd> <dt>Since:</dt> <dd>1.2</dd> <dt>See Also:</dt> <dd><a href="../shape#intersects(double,double,double,double)"><code>Shape.intersects(double, double, double, double)</code></a></dd> </dl>    <h3 id="getPathIterator(java.awt.geom.AffineTransform)">getPathIterator</h3> <pre data-language="java">public PathIterator getPathIterator(AffineTransform at)</pre> <p>Creates a <a href="pathiterator"><code>PathIterator</code></a> for the outline of this <code>Area</code> object. This <code>Area</code> object is unchanged.</p> <dl> <dt>Specified by:</dt> <dd>
<code><a href="../shape#getPathIterator(java.awt.geom.AffineTransform)">getPathIterator</a></code> in interface <code><a href="../shape">Shape</a></code>
</dd> <dt>Parameters:</dt> <dd>
<code>at</code> - an optional <code>AffineTransform</code> to be applied to the coordinates as they are returned in the iteration, or <code>null</code> if untransformed coordinates are desired</dd> <dt>Returns:</dt> <dd>the <code>PathIterator</code> object that returns the geometry of the outline of this <code>Area</code>, one segment at a time.</dd> <dt>Since:</dt> <dd>1.2</dd> </dl>    <h3 id="getPathIterator(java.awt.geom.AffineTransform,double)">getPathIterator</h3> <pre data-language="java">public PathIterator getPathIterator(AffineTransform at,
                                    double flatness)</pre> <p>Creates a <code>PathIterator</code> for the flattened outline of this <code>Area</code> object. Only uncurved path segments represented by the SEG_MOVETO, SEG_LINETO, and SEG_CLOSE point types are returned by the iterator. This <code>Area</code> object is unchanged.</p> <dl> <dt>Specified by:</dt> <dd>
<code><a href="../shape#getPathIterator(java.awt.geom.AffineTransform,double)">getPathIterator</a></code> in interface <code><a href="../shape">Shape</a></code>
</dd> <dt>Parameters:</dt> <dd>
<code>at</code> - an optional <code>AffineTransform</code> to be applied to the coordinates as they are returned in the iteration, or <code>null</code> if untransformed coordinates are desired</dd> <dd>
<code>flatness</code> - the maximum amount that the control points for a given curve can vary from colinear before a subdivided curve is replaced by a straight line connecting the end points</dd> <dt>Returns:</dt> <dd>the <code>PathIterator</code> object that returns the geometry of the outline of this <code>Area</code>, one segment at a time.</dd> <dt>Since:</dt> <dd>1.2</dd> </dl>   </section>  </div>  </main>  <div class="_attribution">
  <p class="_attribution-p">
    &copy; 1993, 2020, Oracle and/or its affiliates. All rights reserved.<br>Documentation extracted from Debian's OpenJDK Development Kit package.<br>Licensed under the GNU General Public License, version 2, with the Classpath Exception.<br>Various third party code in OpenJDK is licensed under different licenses (see Debian package).<br>Java and OpenJDK are trademarks or registered trademarks of Oracle and/or its affiliates.<br>
    <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.desktop/java/awt/geom/Area.html" class="_attribution-link">https://docs.oracle.com/en/java/javase/11/docs/api/java.desktop/java/awt/geom/Area.html</a>
  </p>
</div>
