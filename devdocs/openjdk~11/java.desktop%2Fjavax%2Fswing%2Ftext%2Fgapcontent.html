  <main role="main">    <h1>Class GapContent</h1>   <ul class="inheritance"> <li><a href="../../../../java.base/java/lang/object">java.lang.Object</a></li> <li> <ul class="inheritance"> <li>javax.swing.text.GapContent</li> </ul> </li> </ul>   <dl> <dt>All Implemented Interfaces:</dt> <dd>
<code><a href="../../../../java.base/java/io/serializable">Serializable</a></code>, <code><a href="abstractdocument.content">AbstractDocument.Content</a></code>
</dd> </dl>  <pre data-language="java">public class GapContent
extends Object
implements AbstractDocument.Content, Serializable</pre> <div>
<p>An implementation of the AbstractDocument.Content interface implemented using a gapped buffer similar to that used by emacs. The underlying storage is a array of unicode characters with a gap somewhere. The gap is moved to the location of changes to take advantage of common behavior where most changes are in the same location. Changes that occur at a gap boundary are generally cheap and moving the gap is generally cheaper than moving the array contents directly to accommodate the change. </p>
<p> The positions tracking change are also generally cheap to maintain. The Position implementations (marks) store the array index and can easily calculate the sequential position from the current gap location. Changes only require update to the the marks between the old and new gap boundaries when the gap is moved, so generally updating the marks is pretty cheap. The marks are stored sorted so they can be located quickly with a binary search. This increases the cost of adding a mark, and decreases the cost of keeping the mark updated.</p>
</div> <dl> <dt>See Also:</dt> <dd><a href="https://docs.oracle.com/en/java/javase/11/docs/api/serialized-form.html#javax.swing.text.GapContent">Serialized Form</a></dd> </dl>      <section role="region">  <h2 id="constructor.summary">Constructors</h2> <table>  <tr> <th scope="col">Constructor</th> <th scope="col">Description</th> </tr> <tr> <th scope="row"><code><a href="#%3Cinit%3E()">GapContent</a>()</code></th> <td> <p>Creates a new GapContent object.</p> </td> </tr> <tr> <th scope="row"><code><a href="#%3Cinit%3E(int)">GapContent</a>​(int initialLength)</code></th> <td> <p>Creates a new GapContent object, with the initial size specified.</p> </td> </tr> </table>  </section>  <section role="region">  <h2 id="method.summary">Methods</h2> <table>  <tr> <th scope="col">Modifier and Type</th> <th scope="col">Method</th> <th scope="col">Description</th> </tr> <tr id="i0"> <td><code>protected <a href="../../../../java.base/java/lang/object">Object</a></code></td> <th scope="row"><code><a href="#allocateArray(int)">allocateArray</a>​(int len)</code></th> <td> <p>Allocate an array to store items of the type appropriate (which is determined by the subclass).</p> </td> </tr> <tr id="i1"> <td><code><a href="position">Position</a></code></td> <th scope="row"><code><a href="#createPosition(int)">createPosition</a>​(int offset)</code></th> <td> <p>Creates a position within the content that will track change as the content is mutated.</p> </td> </tr> <tr id="i2"> <td><code>protected <a href="../../../../java.base/java/lang/object">Object</a></code></td> <th scope="row"><code><a href="#getArray()">getArray</a>()</code></th> <td> <p>Access to the array.</p> </td> </tr> <tr id="i3"> <td><code>protected int</code></td> <th scope="row"><code><a href="#getArrayLength()">getArrayLength</a>()</code></th> <td> <p>Get the length of the allocated array.</p> </td> </tr> <tr id="i4"> <td><code>void</code></td> <th scope="row"><code><a href="#getChars(int,int,javax.swing.text.Segment)">getChars</a>​(int where,
        int len,
        <a href="segment">Segment</a> chars)</code></th> <td> <p>Retrieves a portion of the content.</p> </td> </tr> <tr id="i5"> <td><code>protected int</code></td> <th scope="row"><code><a href="#getGapEnd()">getGapEnd</a>()</code></th> <td> <p>Access to the end of the gap.</p> </td> </tr> <tr id="i6"> <td><code>protected int</code></td> <th scope="row"><code><a href="#getGapStart()">getGapStart</a>()</code></th> <td> <p>Access to the start of the gap.</p> </td> </tr> <tr id="i7"> <td><code>protected <a href="../../../../java.base/java/util/vector">Vector</a></code></td> <th scope="row"><code><a href="#getPositionsInRange(java.util.Vector,int,int)">getPositionsInRange</a>​(<a href="../../../../java.base/java/util/vector">Vector</a> v,
                   int offset,
                   int length)</code></th> <td> <p>Returns a Vector containing instances of UndoPosRef for the Positions in the range <code>offset</code> to <code>offset</code> + <code>length</code>.</p> </td> </tr> <tr id="i8"> <td><code><a href="../../../../java.base/java/lang/string">String</a></code></td> <th scope="row"><code><a href="#getString(int,int)">getString</a>​(int where,
         int len)</code></th> <td> <p>Retrieves a portion of the content.</p> </td> </tr> <tr id="i9"> <td><code><a href="../undo/undoableedit">UndoableEdit</a></code></td> <th scope="row"><code><a href="#insertString(int,java.lang.String)">insertString</a>​(int where,
            <a href="../../../../java.base/java/lang/string">String</a> str)</code></th> <td> <p>Inserts a string into the content.</p> </td> </tr> <tr id="i10"> <td><code>int</code></td> <th scope="row"><code><a href="#length()">length</a>()</code></th> <td> <p>Returns the length of the content.</p> </td> </tr> <tr id="i11"> <td><code><a href="../undo/undoableedit">UndoableEdit</a></code></td> <th scope="row"><code><a href="#remove(int,int)">remove</a>​(int where,
      int nitems)</code></th> <td> <p>Removes part of the content.</p> </td> </tr> <tr id="i12"> <td><code>protected void</code></td> <th scope="row"><code><a href="#replace(int,int,java.lang.Object,int)">replace</a>​(int position,
       int rmSize,
       <a href="../../../../java.base/java/lang/object">Object</a> addItems,
       int addSize)</code></th> <td> <p>Replace the given logical position in the storage with the given new items.</p> </td> </tr> <tr id="i13"> <td><code>protected void</code></td> <th scope="row"><code><a href="#resetMarksAtZero()">resetMarksAtZero</a>()</code></th> <td> <p>Resets all the marks that have an offset of 0 to have an index of zero as well.</p> </td> </tr> <tr id="i14"> <td><code>protected void</code></td> <th scope="row"><code><a href="#shiftEnd(int)">shiftEnd</a>​(int newSize)</code></th> <td> <p>Make the gap bigger, moving any necessary data and updating the appropriate marks</p> </td> </tr> <tr id="i15"> <td><code>protected void</code></td> <th scope="row"><code><a href="#shiftGap(int)">shiftGap</a>​(int newGapStart)</code></th> <td> <p>Move the start of the gap to a new location, without changing the size of the gap.</p> </td> </tr> <tr id="i16"> <td><code>protected void</code></td> <th scope="row"><code><a href="#shiftGapEndUp(int)">shiftGapEndUp</a>​(int newGapEnd)</code></th> <td> <p>Adjust the gap end upward.</p> </td> </tr> <tr id="i17"> <td><code>protected void</code></td> <th scope="row"><code><a href="#shiftGapStartDown(int)">shiftGapStartDown</a>​(int newGapStart)</code></th> <td> <p>Adjust the gap end downward.</p> </td> </tr> <tr id="i18"> <td><code>protected void</code></td> <th scope="row"><code><a href="#updateUndoPositions(java.util.Vector,int,int)">updateUndoPositions</a>​(<a href="../../../../java.base/java/util/vector">Vector</a> positions,
                   int offset,
                   int length)</code></th> <td> <p>Resets the location for all the UndoPosRef instances in <code>positions</code>.</p> </td> </tr> </table>  <h2 id="methods.inherited.from.class.java.lang.Object">Methods declared in class java.lang.<a href="../../../../java.base/java/lang/object">Object</a>
</h2> <code><a href="../../../../java.base/java/lang/object#clone()">clone</a>, <a href="../../../../java.base/java/lang/object#equals(java.lang.Object)">equals</a>, <a href="../../../../java.base/java/lang/object#finalize()">finalize</a>, <a href="../../../../java.base/java/lang/object#getClass()">getClass</a>, <a href="../../../../java.base/java/lang/object#hashCode()">hashCode</a>, <a href="../../../../java.base/java/lang/object#notify()">notify</a>, <a href="../../../../java.base/java/lang/object#notifyAll()">notifyAll</a>, <a href="../../../../java.base/java/lang/object#toString()">toString</a>, <a href="../../../../java.base/java/lang/object#wait()">wait</a>, <a href="../../../../java.base/java/lang/object#wait(long)">wait</a>, <a href="../../../../java.base/java/lang/object#wait(long,int)">wait</a></code>  </section>   <div>   <section role="region">  <h2 id="constructor.detail">Constructors</h2>   <h3 id="&lt;init&gt;()">GapContent</h3> <pre data-language="java">public GapContent()</pre> <p>Creates a new GapContent object. Initial size defaults to 10.</p>    <h3 id="&lt;init&gt;(int)">GapContent</h3> <pre data-language="java">public GapContent(int initialLength)</pre> <p>Creates a new GapContent object, with the initial size specified. The initial size will not be allowed to go below 2, to give room for the implied break and the gap.</p> <dl> <dt>Parameters:</dt> <dd>
<code>initialLength</code> - the initial size</dd> </dl>   </section>  <section role="region">  <h2 id="method.detail">Methods</h2>   <h3 id="allocateArray(int)">allocateArray</h3> <pre data-language="java">protected Object allocateArray(int len)</pre> <p>Allocate an array to store items of the type appropriate (which is determined by the subclass).</p>    <h3 id="getArrayLength()">getArrayLength</h3> <pre data-language="java">protected int getArrayLength()</pre> <p>Get the length of the allocated array.</p>    <h3 id="length()">length</h3> <pre data-language="java">public int length()</pre> <p>Returns the length of the content.</p> <dl> <dt>Specified by:</dt> <dd>
<code><a href="abstractdocument.content#length()">length</a></code> in interface <code><a href="abstractdocument.content">AbstractDocument.Content</a></code>
</dd> <dt>Returns:</dt> <dd>the length &gt;= 1</dd> <dt>See Also:</dt> <dd><a href="abstractdocument.content#length()"><code>AbstractDocument.Content.length()</code></a></dd> </dl>    <h3 id="insertString(int,java.lang.String)">insertString</h3> <pre data-language="java">public UndoableEdit insertString(int where,
                                 String str)
                          throws BadLocationException</pre> <p>Inserts a string into the content.</p> <dl> <dt>Specified by:</dt> <dd>
<code><a href="abstractdocument.content#insertString(int,java.lang.String)">insertString</a></code> in interface <code><a href="abstractdocument.content">AbstractDocument.Content</a></code>
</dd> <dt>Parameters:</dt> <dd>
<code>where</code> - the starting position &gt;= 0, &lt; length()</dd> <dd>
<code>str</code> - the non-null string to insert</dd> <dt>Returns:</dt> <dd>an UndoableEdit object for undoing</dd> <dt>Throws:</dt> <dd>
<code><a href="badlocationexception">BadLocationException</a></code> - if the specified position is invalid</dd> <dt>See Also:</dt> <dd><a href="abstractdocument.content#insertString(int,java.lang.String)"><code>AbstractDocument.Content.insertString(int, java.lang.String)</code></a></dd> </dl>    <h3 id="remove(int,int)">remove</h3> <pre data-language="java">public UndoableEdit remove(int where,
                           int nitems)
                    throws BadLocationException</pre> <p>Removes part of the content.</p> <dl> <dt>Specified by:</dt> <dd>
<code><a href="abstractdocument.content#remove(int,int)">remove</a></code> in interface <code><a href="abstractdocument.content">AbstractDocument.Content</a></code>
</dd> <dt>Parameters:</dt> <dd>
<code>where</code> - the starting position &gt;= 0, where + nitems &lt; length()</dd> <dd>
<code>nitems</code> - the number of characters to remove &gt;= 0</dd> <dt>Returns:</dt> <dd>an UndoableEdit object for undoing</dd> <dt>Throws:</dt> <dd>
<code><a href="badlocationexception">BadLocationException</a></code> - if the specified position is invalid</dd> <dt>See Also:</dt> <dd><a href="abstractdocument.content#remove(int,int)"><code>AbstractDocument.Content.remove(int, int)</code></a></dd> </dl>    <h3 id="getString(int,int)">getString</h3> <pre data-language="java">public String getString(int where,
                        int len)
                 throws BadLocationException</pre> <p>Retrieves a portion of the content.</p> <dl> <dt>Specified by:</dt> <dd>
<code><a href="abstractdocument.content#getString(int,int)">getString</a></code> in interface <code><a href="abstractdocument.content">AbstractDocument.Content</a></code>
</dd> <dt>Parameters:</dt> <dd>
<code>where</code> - the starting position &gt;= 0</dd> <dd>
<code>len</code> - the length to retrieve &gt;= 0</dd> <dt>Returns:</dt> <dd>a string representing the content</dd> <dt>Throws:</dt> <dd>
<code><a href="badlocationexception">BadLocationException</a></code> - if the specified position is invalid</dd> <dt>See Also:</dt> <dd><a href="abstractdocument.content#getString(int,int)"><code>AbstractDocument.Content.getString(int, int)</code></a></dd> </dl>    <h3 id="getChars(int,int,javax.swing.text.Segment)">getChars</h3> <pre data-language="java">public void getChars(int where,
                     int len,
                     Segment chars)
              throws BadLocationException</pre> <p>Retrieves a portion of the content. If the desired content spans the gap, we copy the content. If the desired content does not span the gap, the actual store is returned to avoid the copy since it is contiguous.</p> <dl> <dt>Specified by:</dt> <dd>
<code><a href="abstractdocument.content#getChars(int,int,javax.swing.text.Segment)">getChars</a></code> in interface <code><a href="abstractdocument.content">AbstractDocument.Content</a></code>
</dd> <dt>Parameters:</dt> <dd>
<code>where</code> - the starting position &gt;= 0, where + len &lt;= length()</dd> <dd>
<code>len</code> - the number of characters to retrieve &gt;= 0</dd> <dd>
<code>chars</code> - the Segment object to return the characters in</dd> <dt>Throws:</dt> <dd>
<code><a href="badlocationexception">BadLocationException</a></code> - if the specified position is invalid</dd> <dt>See Also:</dt> <dd><a href="abstractdocument.content#getChars(int,int,javax.swing.text.Segment)"><code>AbstractDocument.Content.getChars(int, int, javax.swing.text.Segment)</code></a></dd> </dl>    <h3 id="createPosition(int)">createPosition</h3> <pre data-language="java">public Position createPosition(int offset)
                        throws BadLocationException</pre> <p>Creates a position within the content that will track change as the content is mutated.</p> <dl> <dt>Specified by:</dt> <dd>
<code><a href="abstractdocument.content#createPosition(int)">createPosition</a></code> in interface <code><a href="abstractdocument.content">AbstractDocument.Content</a></code>
</dd> <dt>Parameters:</dt> <dd>
<code>offset</code> - the offset to track &gt;= 0</dd> <dt>Returns:</dt> <dd>the position</dd> <dt>Throws:</dt> <dd>
<code><a href="badlocationexception">BadLocationException</a></code> - if the specified position is invalid</dd> </dl>    <h3 id="shiftEnd(int)">shiftEnd</h3> <pre data-language="java">protected void shiftEnd(int newSize)</pre> <p>Make the gap bigger, moving any necessary data and updating the appropriate marks</p>    <h3 id="shiftGap(int)">shiftGap</h3> <pre data-language="java">protected void shiftGap(int newGapStart)</pre> <p>Move the start of the gap to a new location, without changing the size of the gap. This moves the data in the array and updates the marks accordingly.</p>    <h3 id="resetMarksAtZero()">resetMarksAtZero</h3> <pre data-language="java">protected void resetMarksAtZero()</pre> <p>Resets all the marks that have an offset of 0 to have an index of zero as well.</p>    <h3 id="shiftGapStartDown(int)">shiftGapStartDown</h3> <pre data-language="java">protected void shiftGapStartDown(int newGapStart)</pre> <p>Adjust the gap end downward. This doesn't move any data, but it does update any marks affected by the boundary change. All marks from the old gap start down to the new gap start are squeezed to the end of the gap (their location has been removed).</p>    <h3 id="shiftGapEndUp(int)">shiftGapEndUp</h3> <pre data-language="java">protected void shiftGapEndUp(int newGapEnd)</pre> <p>Adjust the gap end upward. This doesn't move any data, but it does update any marks affected by the boundary change. All marks from the old gap end up to the new gap end are squeezed to the end of the gap (their location has been removed).</p>    <h3 id="getPositionsInRange(java.util.Vector,int,int)">getPositionsInRange</h3> <pre data-language="java">protected Vector getPositionsInRange(Vector v,
                                     int offset,
                                     int length)</pre> <p>Returns a Vector containing instances of UndoPosRef for the Positions in the range <code>offset</code> to <code>offset</code> + <code>length</code>. If <code>v</code> is not null the matching Positions are placed in there. The vector with the resulting Positions are returned.</p> <dl> <dt>Parameters:</dt> <dd>
<code>v</code> - the Vector to use, with a new one created on null</dd> <dd>
<code>offset</code> - the starting offset &gt;= 0</dd> <dd>
<code>length</code> - the length &gt;= 0</dd> <dt>Returns:</dt> <dd>the set of instances</dd> </dl>    <h3 id="updateUndoPositions(java.util.Vector,int,int)">updateUndoPositions</h3> <pre data-language="java">protected void updateUndoPositions(Vector positions,
                                   int offset,
                                   int length)</pre> <div>
<p>Resets the location for all the UndoPosRef instances in <code>positions</code>. </p>
<p> This is meant for internal usage, and is generally not of interest to subclasses.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>positions</code> - the UndoPosRef instances to reset</dd> <dd>
<code>offset</code> - where the string was inserted</dd> <dd>
<code>length</code> - length of inserted string</dd> </dl>    <h3 id="getArray()">getArray</h3> <pre data-language="java">protected final Object getArray()</pre> <p>Access to the array. The actual type of the array is known only by the subclass.</p>    <h3 id="getGapStart()">getGapStart</h3> <pre data-language="java">protected final int getGapStart()</pre> <p>Access to the start of the gap.</p>    <h3 id="getGapEnd()">getGapEnd</h3> <pre data-language="java">protected final int getGapEnd()</pre> <p>Access to the end of the gap.</p>    <h3 id="replace(int,int,java.lang.Object,int)">replace</h3> <pre data-language="java">protected void replace(int position,
                       int rmSize,
                       Object addItems,
                       int addSize)</pre> <p>Replace the given logical position in the storage with the given new items. This will move the gap to the area being changed if the gap is not currently located at the change location.</p> <dl> <dt>Parameters:</dt> <dd>
<code>position</code> - the location to make the replacement. This is not the location in the underlying storage array, but the location in the contiguous space being modeled.</dd> <dd>
<code>rmSize</code> - the number of items to remove</dd> <dd>
<code>addItems</code> - the new items to place in storage.</dd> </dl>   </section>  </div>  </main>  <div class="_attribution">
  <p class="_attribution-p">
    &copy; 1993, 2020, Oracle and/or its affiliates. All rights reserved.<br>Documentation extracted from Debian's OpenJDK Development Kit package.<br>Licensed under the GNU General Public License, version 2, with the Classpath Exception.<br>Various third party code in OpenJDK is licensed under different licenses (see Debian package).<br>Java and OpenJDK are trademarks or registered trademarks of Oracle and/or its affiliates.<br>
    <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.desktop/javax/swing/text/GapContent.html" class="_attribution-link">https://docs.oracle.com/en/java/javase/11/docs/api/java.desktop/javax/swing/text/GapContent.html</a>
  </p>
</div>
