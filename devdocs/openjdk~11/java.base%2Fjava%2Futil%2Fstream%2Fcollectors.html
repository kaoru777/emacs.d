  <main role="main">    <h1>Class Collectors</h1>   <ul class="inheritance"> <li><a href="../../lang/object">java.lang.Object</a></li> <li> <ul class="inheritance"> <li>java.util.stream.Collectors</li> </ul> </li> </ul>    <pre data-language="java">public final class Collectors
extends Object</pre> <div>
<p>Implementations of <a href="collector"><code>Collector</code></a> that implement various useful reduction operations, such as accumulating elements into collections, summarizing elements according to various criteria, etc. </p>
<p>The following are examples of using the predefined collectors to perform common mutable reduction tasks: </p>
<pre data-language="java">// Accumulate names into a List
 List&lt;String&gt; list = people.stream()
   .map(Person::getName)
   .collect(Collectors.toList());

 // Accumulate names into a TreeSet
 Set&lt;String&gt; set = people.stream()
   .map(Person::getName)
   .collect(Collectors.toCollection(TreeSet::new));

 // Convert elements to strings and concatenate them, separated by commas
 String joined = things.stream()
   .map(Object::toString)
   .collect(Collectors.joining(", "));

 // Compute sum of salaries of employee
 int total = employees.stream()
   .collect(Collectors.summingInt(Employee::getSalary));

 // Group employees by department
 Map&lt;Department, List&lt;Employee&gt;&gt; byDept = employees.stream()
   .collect(Collectors.groupingBy(Employee::getDepartment));

 // Compute sum of salaries by department
 Map&lt;Department, Integer&gt; totalByDept = employees.stream()
   .collect(Collectors.groupingBy(Employee::getDepartment,
                                  Collectors.summingInt(Employee::getSalary)));

 // Partition students into passing and failing
 Map&lt;Boolean, List&lt;Student&gt;&gt; passingFailing = students.stream()
   .collect(Collectors.partitioningBy(s -&gt; s.getGrade() &gt;= PASS_THRESHOLD));</pre>
</div> <dl> <dt>Since:</dt> <dd>1.8</dd> </dl>      <section role="region">  <h2 id="method.summary">Methods</h2> <table>  <tr> <th scope="col">Modifier and Type</th> <th scope="col">Method</th> <th scope="col">Description</th> </tr> <tr id="i0"> <td><code>static &lt;T&gt; <a href="collector">Collector</a>&lt;T,​?,​<a href="../../lang/double">Double</a>&gt;</code></td> <th scope="row"><code><a href="#averagingDouble(java.util.function.ToDoubleFunction)">averagingDouble</a>​(<a href="../function/todoublefunction">ToDoubleFunction</a>&lt;? super T&gt; mapper)</code></th> <td> <p>Returns a <code>Collector</code> that produces the arithmetic mean of a double-valued function applied to the input elements.</p> </td> </tr> <tr id="i1"> <td><code>static &lt;T&gt; <a href="collector">Collector</a>&lt;T,​?,​<a href="../../lang/double">Double</a>&gt;</code></td> <th scope="row"><code><a href="#averagingInt(java.util.function.ToIntFunction)">averagingInt</a>​(<a href="../function/tointfunction">ToIntFunction</a>&lt;? super T&gt; mapper)</code></th> <td> <p>Returns a <code>Collector</code> that produces the arithmetic mean of an integer-valued function applied to the input elements.</p> </td> </tr> <tr id="i2"> <td><code>static &lt;T&gt; <a href="collector">Collector</a>&lt;T,​?,​<a href="../../lang/double">Double</a>&gt;</code></td> <th scope="row"><code><a href="#averagingLong(java.util.function.ToLongFunction)">averagingLong</a>​(<a href="../function/tolongfunction">ToLongFunction</a>&lt;? super T&gt; mapper)</code></th> <td> <p>Returns a <code>Collector</code> that produces the arithmetic mean of a long-valued function applied to the input elements.</p> </td> </tr> <tr id="i3"> <td><code>static &lt;T,​A,​R,​RR&gt;<br><a href="collector">Collector</a>&lt;T,​A,​RR&gt;</code></td> <th scope="row"><code><a href="#collectingAndThen(java.util.stream.Collector,java.util.function.Function)">collectingAndThen</a>​(<a href="collector">Collector</a>&lt;T,​A,​R&gt; downstream,
                 <a href="../function/function">Function</a>&lt;R,​RR&gt; finisher)</code></th> <td> <p>Adapts a <code>Collector</code> to perform an additional finishing transformation.</p> </td> </tr> <tr id="i4"> <td><code>static &lt;T&gt; <a href="collector">Collector</a>&lt;T,​?,​<a href="../../lang/long">Long</a>&gt;</code></td> <th scope="row"><code><a href="#counting()">counting</a>()</code></th> <td> <p>Returns a <code>Collector</code> accepting elements of type <code>T</code> that counts the number of input elements.</p> </td> </tr> <tr id="i5"> <td><code>static &lt;T,​A,​R&gt;<br><a href="collector">Collector</a>&lt;T,​?,​R&gt;</code></td> <th scope="row"><code><a href="#filtering(java.util.function.Predicate,java.util.stream.Collector)">filtering</a>​(<a href="../function/predicate">Predicate</a>&lt;? super T&gt; predicate,
         <a href="collector">Collector</a>&lt;? super T,​A,​R&gt; downstream)</code></th> <td> <p>Adapts a <code>Collector</code> to one accepting elements of the same type <code>T</code> by applying the predicate to each input element and only accumulating if the predicate returns <code>true</code>.</p> </td> </tr> <tr id="i6"> <td><code>static &lt;T,​U,​A,​R&gt;<br><a href="collector">Collector</a>&lt;T,​?,​R&gt;</code></td> <th scope="row"><code><a href="#flatMapping(java.util.function.Function,java.util.stream.Collector)">flatMapping</a>​(<a href="../function/function">Function</a>&lt;? super T,​? extends <a href="stream">Stream</a>&lt;? extends U&gt;&gt; mapper,
           <a href="collector">Collector</a>&lt;? super U,​A,​R&gt; downstream)</code></th> <td> <p>Adapts a <code>Collector</code> accepting elements of type <code>U</code> to one accepting elements of type <code>T</code> by applying a flat mapping function to each input element before accumulation.</p> </td> </tr> <tr id="i7"> <td><code>static &lt;T,​K&gt;<br><a href="collector">Collector</a>&lt;T,​?,​<a href="../map">Map</a>&lt;K,​<a href="../list">List</a>&lt;T&gt;&gt;&gt;</code></td> <th scope="row"><code><a href="#groupingBy(java.util.function.Function)">groupingBy</a>​(<a href="../function/function">Function</a>&lt;? super T,​? extends K&gt; classifier)</code></th> <td> <p>Returns a <code>Collector</code> implementing a "group by" operation on input elements of type <code>T</code>, grouping elements according to a classification function, and returning the results in a <code>Map</code>.</p> </td> </tr> <tr id="i8"> <td><code>static &lt;T,​K,​D,​A,​M extends <a href="../map">Map</a>&lt;K,​D&gt;&gt;<br><a href="collector">Collector</a>&lt;T,​?,​M&gt;</code></td> <th scope="row"><code><a href="#groupingBy(java.util.function.Function,java.util.function.Supplier,java.util.stream.Collector)">groupingBy</a>​(<a href="../function/function">Function</a>&lt;? super T,​? extends K&gt; classifier,
          <a href="../function/supplier">Supplier</a>&lt;M&gt; mapFactory,
          <a href="collector">Collector</a>&lt;? super T,​A,​D&gt; downstream)</code></th> <td> <p>Returns a <code>Collector</code> implementing a cascaded "group by" operation on input elements of type <code>T</code>, grouping elements according to a classification function, and then performing a reduction operation on the values associated with a given key using the specified downstream <code>Collector</code>.</p> </td> </tr> <tr id="i9"> <td><code>static &lt;T,​K,​A,​D&gt;<br><a href="collector">Collector</a>&lt;T,​?,​<a href="../map">Map</a>&lt;K,​D&gt;&gt;</code></td> <th scope="row"><code><a href="#groupingBy(java.util.function.Function,java.util.stream.Collector)">groupingBy</a>​(<a href="../function/function">Function</a>&lt;? super T,​? extends K&gt; classifier,
          <a href="collector">Collector</a>&lt;? super T,​A,​D&gt; downstream)</code></th> <td> <p>Returns a <code>Collector</code> implementing a cascaded "group by" operation on input elements of type <code>T</code>, grouping elements according to a classification function, and then performing a reduction operation on the values associated with a given key using the specified downstream <code>Collector</code>.</p> </td> </tr> <tr id="i10"> <td><code>static &lt;T,​K&gt;<br><a href="collector">Collector</a>&lt;T,​?,​<a href="../concurrent/concurrentmap">ConcurrentMap</a>&lt;K,​<a href="../list">List</a>&lt;T&gt;&gt;&gt;</code></td> <th scope="row"><code><a href="#groupingByConcurrent(java.util.function.Function)">groupingByConcurrent</a>​(<a href="../function/function">Function</a>&lt;? super T,​? extends K&gt; classifier)</code></th> <td> <p>Returns a concurrent <code>Collector</code> implementing a "group by" operation on input elements of type <code>T</code>, grouping elements according to a classification function.</p> </td> </tr> <tr id="i11"> <td><code>static &lt;T,​K,​A,​D,​M extends <a href="../concurrent/concurrentmap">ConcurrentMap</a>&lt;K,​D&gt;&gt;<br><a href="collector">Collector</a>&lt;T,​?,​M&gt;</code></td> <th scope="row"><code><a href="#groupingByConcurrent(java.util.function.Function,java.util.function.Supplier,java.util.stream.Collector)">groupingByConcurrent</a>​(<a href="../function/function">Function</a>&lt;? super T,​? extends K&gt; classifier,
                    <a href="../function/supplier">Supplier</a>&lt;M&gt; mapFactory,
                    <a href="collector">Collector</a>&lt;? super T,​A,​D&gt; downstream)</code></th> <td> <p>Returns a concurrent <code>Collector</code> implementing a cascaded "group by" operation on input elements of type <code>T</code>, grouping elements according to a classification function, and then performing a reduction operation on the values associated with a given key using the specified downstream <code>Collector</code>.</p> </td> </tr> <tr id="i12"> <td><code>static &lt;T,​K,​A,​D&gt;<br><a href="collector">Collector</a>&lt;T,​?,​<a href="../concurrent/concurrentmap">ConcurrentMap</a>&lt;K,​D&gt;&gt;</code></td> <th scope="row"><code><a href="#groupingByConcurrent(java.util.function.Function,java.util.stream.Collector)">groupingByConcurrent</a>​(<a href="../function/function">Function</a>&lt;? super T,​? extends K&gt; classifier,
                    <a href="collector">Collector</a>&lt;? super T,​A,​D&gt; downstream)</code></th> <td> <p>Returns a concurrent <code>Collector</code> implementing a cascaded "group by" operation on input elements of type <code>T</code>, grouping elements according to a classification function, and then performing a reduction operation on the values associated with a given key using the specified downstream <code>Collector</code>.</p> </td> </tr> <tr id="i13"> <td><code>static <a href="collector">Collector</a>&lt;<a href="../../lang/charsequence">CharSequence</a>,​?,​<a href="../../lang/string">String</a>&gt;</code></td> <th scope="row"><code><a href="#joining()">joining</a>()</code></th> <td> <p>Returns a <code>Collector</code> that concatenates the input elements into a <code>String</code>, in encounter order.</p> </td> </tr> <tr id="i14"> <td><code>static <a href="collector">Collector</a>&lt;<a href="../../lang/charsequence">CharSequence</a>,​?,​<a href="../../lang/string">String</a>&gt;</code></td> <th scope="row"><code><a href="#joining(java.lang.CharSequence)">joining</a>​(<a href="../../lang/charsequence">CharSequence</a> delimiter)</code></th> <td> <p>Returns a <code>Collector</code> that concatenates the input elements, separated by the specified delimiter, in encounter order.</p> </td> </tr> <tr id="i15"> <td><code>static <a href="collector">Collector</a>&lt;<a href="../../lang/charsequence">CharSequence</a>,​?,​<a href="../../lang/string">String</a>&gt;</code></td> <th scope="row"><code><a href="#joining(java.lang.CharSequence,java.lang.CharSequence,java.lang.CharSequence)">joining</a>​(<a href="../../lang/charsequence">CharSequence</a> delimiter,
       <a href="../../lang/charsequence">CharSequence</a> prefix,
       <a href="../../lang/charsequence">CharSequence</a> suffix)</code></th> <td> <p>Returns a <code>Collector</code> that concatenates the input elements, separated by the specified delimiter, with the specified prefix and suffix, in encounter order.</p> </td> </tr> <tr id="i16"> <td><code>static &lt;T,​U,​A,​R&gt;<br><a href="collector">Collector</a>&lt;T,​?,​R&gt;</code></td> <th scope="row"><code><a href="#mapping(java.util.function.Function,java.util.stream.Collector)">mapping</a>​(<a href="../function/function">Function</a>&lt;? super T,​? extends U&gt; mapper,
       <a href="collector">Collector</a>&lt;? super U,​A,​R&gt; downstream)</code></th> <td> <p>Adapts a <code>Collector</code> accepting elements of type <code>U</code> to one accepting elements of type <code>T</code> by applying a mapping function to each input element before accumulation.</p> </td> </tr> <tr id="i17"> <td><code>static &lt;T&gt; <a href="collector">Collector</a>&lt;T,​?,​<a href="../optional">Optional</a>&lt;T&gt;&gt;</code></td> <th scope="row"><code><a href="#maxBy(java.util.Comparator)">maxBy</a>​(<a href="../comparator">Comparator</a>&lt;? super T&gt; comparator)</code></th> <td> <p>Returns a <code>Collector</code> that produces the maximal element according to a given <code>Comparator</code>, described as an <code>Optional&lt;T&gt;</code>.</p> </td> </tr> <tr id="i18"> <td><code>static &lt;T&gt; <a href="collector">Collector</a>&lt;T,​?,​<a href="../optional">Optional</a>&lt;T&gt;&gt;</code></td> <th scope="row"><code><a href="#minBy(java.util.Comparator)">minBy</a>​(<a href="../comparator">Comparator</a>&lt;? super T&gt; comparator)</code></th> <td> <p>Returns a <code>Collector</code> that produces the minimal element according to a given <code>Comparator</code>, described as an <code>Optional&lt;T&gt;</code>.</p> </td> </tr> <tr id="i19"> <td><code>static &lt;T&gt; <a href="collector">Collector</a>&lt;T,​?,​<a href="../map">Map</a>&lt;<a href="../../lang/boolean">Boolean</a>,​<a href="../list">List</a>&lt;T&gt;&gt;&gt;</code></td> <th scope="row"><code><a href="#partitioningBy(java.util.function.Predicate)">partitioningBy</a>​(<a href="../function/predicate">Predicate</a>&lt;? super T&gt; predicate)</code></th> <td> <p>Returns a <code>Collector</code> which partitions the input elements according to a <code>Predicate</code>, and organizes them into a <code>Map&lt;Boolean, List&lt;T&gt;&gt;</code>.</p> </td> </tr> <tr id="i20"> <td><code>static &lt;T,​D,​A&gt;<br><a href="collector">Collector</a>&lt;T,​?,​<a href="../map">Map</a>&lt;<a href="../../lang/boolean">Boolean</a>,​D&gt;&gt;</code></td> <th scope="row"><code><a href="#partitioningBy(java.util.function.Predicate,java.util.stream.Collector)">partitioningBy</a>​(<a href="../function/predicate">Predicate</a>&lt;? super T&gt; predicate,
              <a href="collector">Collector</a>&lt;? super T,​A,​D&gt; downstream)</code></th> <td> <p>Returns a <code>Collector</code> which partitions the input elements according to a <code>Predicate</code>, reduces the values in each partition according to another <code>Collector</code>, and organizes them into a <code>Map&lt;Boolean, D&gt;</code> whose values are the result of the downstream reduction.</p> </td> </tr> <tr id="i21"> <td><code>static &lt;T&gt; <a href="collector">Collector</a>&lt;T,​?,​<a href="../optional">Optional</a>&lt;T&gt;&gt;</code></td> <th scope="row"><code><a href="#reducing(java.util.function.BinaryOperator)">reducing</a>​(<a href="../function/binaryoperator">BinaryOperator</a>&lt;T&gt; op)</code></th> <td> <p>Returns a <code>Collector</code> which performs a reduction of its input elements under a specified <code>BinaryOperator</code>.</p> </td> </tr> <tr id="i22"> <td><code>static &lt;T&gt; <a href="collector">Collector</a>&lt;T,​?,​T&gt;</code></td> <th scope="row"><code><a href="#reducing(T,java.util.function.BinaryOperator)">reducing</a>​(T identity,
        <a href="../function/binaryoperator">BinaryOperator</a>&lt;T&gt; op)</code></th> <td> <p>Returns a <code>Collector</code> which performs a reduction of its input elements under a specified <code>BinaryOperator</code> using the provided identity.</p> </td> </tr> <tr id="i23"> <td><code>static &lt;T,​U&gt;<br><a href="collector">Collector</a>&lt;T,​?,​U&gt;</code></td> <th scope="row"><code><a href="#reducing(U,java.util.function.Function,java.util.function.BinaryOperator)">reducing</a>​(U identity,
        <a href="../function/function">Function</a>&lt;? super T,​? extends U&gt; mapper,
        <a href="../function/binaryoperator">BinaryOperator</a>&lt;U&gt; op)</code></th> <td> <p>Returns a <code>Collector</code> which performs a reduction of its input elements under a specified mapping function and <code>BinaryOperator</code>.</p> </td> </tr> <tr id="i24"> <td><code>static &lt;T&gt; <a href="collector">Collector</a>&lt;T,​?,​<a href="../doublesummarystatistics">DoubleSummaryStatistics</a>&gt;</code></td> <th scope="row"><code><a href="#summarizingDouble(java.util.function.ToDoubleFunction)">summarizingDouble</a>​(<a href="../function/todoublefunction">ToDoubleFunction</a>&lt;? super T&gt; mapper)</code></th> <td> <p>Returns a <code>Collector</code> which applies an <code>double</code>-producing mapping function to each input element, and returns summary statistics for the resulting values.</p> </td> </tr> <tr id="i25"> <td><code>static &lt;T&gt; <a href="collector">Collector</a>&lt;T,​?,​<a href="../intsummarystatistics">IntSummaryStatistics</a>&gt;</code></td> <th scope="row"><code><a href="#summarizingInt(java.util.function.ToIntFunction)">summarizingInt</a>​(<a href="../function/tointfunction">ToIntFunction</a>&lt;? super T&gt; mapper)</code></th> <td> <p>Returns a <code>Collector</code> which applies an <code>int</code>-producing mapping function to each input element, and returns summary statistics for the resulting values.</p> </td> </tr> <tr id="i26"> <td><code>static &lt;T&gt; <a href="collector">Collector</a>&lt;T,​?,​<a href="../longsummarystatistics">LongSummaryStatistics</a>&gt;</code></td> <th scope="row"><code><a href="#summarizingLong(java.util.function.ToLongFunction)">summarizingLong</a>​(<a href="../function/tolongfunction">ToLongFunction</a>&lt;? super T&gt; mapper)</code></th> <td> <p>Returns a <code>Collector</code> which applies an <code>long</code>-producing mapping function to each input element, and returns summary statistics for the resulting values.</p> </td> </tr> <tr id="i27"> <td><code>static &lt;T&gt; <a href="collector">Collector</a>&lt;T,​?,​<a href="../../lang/double">Double</a>&gt;</code></td> <th scope="row"><code><a href="#summingDouble(java.util.function.ToDoubleFunction)">summingDouble</a>​(<a href="../function/todoublefunction">ToDoubleFunction</a>&lt;? super T&gt; mapper)</code></th> <td> <p>Returns a <code>Collector</code> that produces the sum of a double-valued function applied to the input elements.</p> </td> </tr> <tr id="i28"> <td><code>static &lt;T&gt; <a href="collector">Collector</a>&lt;T,​?,​<a href="../../lang/integer">Integer</a>&gt;</code></td> <th scope="row"><code><a href="#summingInt(java.util.function.ToIntFunction)">summingInt</a>​(<a href="../function/tointfunction">ToIntFunction</a>&lt;? super T&gt; mapper)</code></th> <td> <p>Returns a <code>Collector</code> that produces the sum of a integer-valued function applied to the input elements.</p> </td> </tr> <tr id="i29"> <td><code>static &lt;T&gt; <a href="collector">Collector</a>&lt;T,​?,​<a href="../../lang/long">Long</a>&gt;</code></td> <th scope="row"><code><a href="#summingLong(java.util.function.ToLongFunction)">summingLong</a>​(<a href="../function/tolongfunction">ToLongFunction</a>&lt;? super T&gt; mapper)</code></th> <td> <p>Returns a <code>Collector</code> that produces the sum of a long-valued function applied to the input elements.</p> </td> </tr> <tr id="i30"> <td><code>static &lt;T,​C extends <a href="../collection">Collection</a>&lt;T&gt;&gt;<br><a href="collector">Collector</a>&lt;T,​?,​C&gt;</code></td> <th scope="row"><code><a href="#toCollection(java.util.function.Supplier)">toCollection</a>​(<a href="../function/supplier">Supplier</a>&lt;C&gt; collectionFactory)</code></th> <td> <p>Returns a <code>Collector</code> that accumulates the input elements into a new <code>Collection</code>, in encounter order.</p> </td> </tr> <tr id="i31"> <td><code>static &lt;T,​K,​U&gt;<br><a href="collector">Collector</a>&lt;T,​?,​<a href="../concurrent/concurrentmap">ConcurrentMap</a>&lt;K,​U&gt;&gt;</code></td> <th scope="row"><code><a href="#toConcurrentMap(java.util.function.Function,java.util.function.Function)">toConcurrentMap</a>​(<a href="../function/function">Function</a>&lt;? super T,​? extends K&gt; keyMapper,
               <a href="../function/function">Function</a>&lt;? super T,​? extends U&gt; valueMapper)</code></th> <td> <p>Returns a concurrent <code>Collector</code> that accumulates elements into a <code>ConcurrentMap</code> whose keys and values are the result of applying the provided mapping functions to the input elements.</p> </td> </tr> <tr id="i32"> <td><code>static &lt;T,​K,​U&gt;<br><a href="collector">Collector</a>&lt;T,​?,​<a href="../concurrent/concurrentmap">ConcurrentMap</a>&lt;K,​U&gt;&gt;</code></td> <th scope="row"><code><a href="#toConcurrentMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator)">toConcurrentMap</a>​(<a href="../function/function">Function</a>&lt;? super T,​? extends K&gt; keyMapper,
               <a href="../function/function">Function</a>&lt;? super T,​? extends U&gt; valueMapper,
               <a href="../function/binaryoperator">BinaryOperator</a>&lt;U&gt; mergeFunction)</code></th> <td> <p>Returns a concurrent <code>Collector</code> that accumulates elements into a <code>ConcurrentMap</code> whose keys and values are the result of applying the provided mapping functions to the input elements.</p> </td> </tr> <tr id="i33"> <td><code>static &lt;T,​K,​U,​M extends <a href="../concurrent/concurrentmap">ConcurrentMap</a>&lt;K,​U&gt;&gt;<br><a href="collector">Collector</a>&lt;T,​?,​M&gt;</code></td> <th scope="row"><code><a href="#toConcurrentMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator,java.util.function.Supplier)">toConcurrentMap</a>​(<a href="../function/function">Function</a>&lt;? super T,​? extends K&gt; keyMapper,
               <a href="../function/function">Function</a>&lt;? super T,​? extends U&gt; valueMapper,
               <a href="../function/binaryoperator">BinaryOperator</a>&lt;U&gt; mergeFunction,
               <a href="../function/supplier">Supplier</a>&lt;M&gt; mapFactory)</code></th> <td> <p>Returns a concurrent <code>Collector</code> that accumulates elements into a <code>ConcurrentMap</code> whose keys and values are the result of applying the provided mapping functions to the input elements.</p> </td> </tr> <tr id="i34"> <td><code>static &lt;T&gt; <a href="collector">Collector</a>&lt;T,​?,​<a href="../list">List</a>&lt;T&gt;&gt;</code></td> <th scope="row"><code><a href="#toList()">toList</a>()</code></th> <td> <p>Returns a <code>Collector</code> that accumulates the input elements into a new <code>List</code>.</p> </td> </tr> <tr id="i35"> <td><code>static &lt;T,​K,​U&gt;<br><a href="collector">Collector</a>&lt;T,​?,​<a href="../map">Map</a>&lt;K,​U&gt;&gt;</code></td> <th scope="row"><code><a href="#toMap(java.util.function.Function,java.util.function.Function)">toMap</a>​(<a href="../function/function">Function</a>&lt;? super T,​? extends K&gt; keyMapper,
     <a href="../function/function">Function</a>&lt;? super T,​? extends U&gt; valueMapper)</code></th> <td> <p>Returns a <code>Collector</code> that accumulates elements into a <code>Map</code> whose keys and values are the result of applying the provided mapping functions to the input elements.</p> </td> </tr> <tr id="i36"> <td><code>static &lt;T,​K,​U&gt;<br><a href="collector">Collector</a>&lt;T,​?,​<a href="../map">Map</a>&lt;K,​U&gt;&gt;</code></td> <th scope="row"><code><a href="#toMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator)">toMap</a>​(<a href="../function/function">Function</a>&lt;? super T,​? extends K&gt; keyMapper,
     <a href="../function/function">Function</a>&lt;? super T,​? extends U&gt; valueMapper,
     <a href="../function/binaryoperator">BinaryOperator</a>&lt;U&gt; mergeFunction)</code></th> <td> <p>Returns a <code>Collector</code> that accumulates elements into a <code>Map</code> whose keys and values are the result of applying the provided mapping functions to the input elements.</p> </td> </tr> <tr id="i37"> <td><code>static &lt;T,​K,​U,​M extends <a href="../map">Map</a>&lt;K,​U&gt;&gt;<br><a href="collector">Collector</a>&lt;T,​?,​M&gt;</code></td> <th scope="row"><code><a href="#toMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator,java.util.function.Supplier)">toMap</a>​(<a href="../function/function">Function</a>&lt;? super T,​? extends K&gt; keyMapper,
     <a href="../function/function">Function</a>&lt;? super T,​? extends U&gt; valueMapper,
     <a href="../function/binaryoperator">BinaryOperator</a>&lt;U&gt; mergeFunction,
     <a href="../function/supplier">Supplier</a>&lt;M&gt; mapFactory)</code></th> <td> <p>Returns a <code>Collector</code> that accumulates elements into a <code>Map</code> whose keys and values are the result of applying the provided mapping functions to the input elements.</p> </td> </tr> <tr id="i38"> <td><code>static &lt;T&gt; <a href="collector">Collector</a>&lt;T,​?,​<a href="../set">Set</a>&lt;T&gt;&gt;</code></td> <th scope="row"><code><a href="#toSet()">toSet</a>()</code></th> <td> <p>Returns a <code>Collector</code> that accumulates the input elements into a new <code>Set</code>.</p> </td> </tr> <tr id="i39"> <td><code>static &lt;T&gt; <a href="collector">Collector</a>&lt;T,​?,​<a href="../list">List</a>&lt;T&gt;&gt;</code></td> <th scope="row"><code><a href="#toUnmodifiableList()">toUnmodifiableList</a>()</code></th> <td> <p>Returns a <code>Collector</code> that accumulates the input elements into an <a href="../list#unmodifiable">unmodifiable List</a> in encounter order.</p> </td> </tr> <tr id="i40"> <td><code>static &lt;T,​K,​U&gt;<br><a href="collector">Collector</a>&lt;T,​?,​<a href="../map">Map</a>&lt;K,​U&gt;&gt;</code></td> <th scope="row"><code><a href="#toUnmodifiableMap(java.util.function.Function,java.util.function.Function)">toUnmodifiableMap</a>​(<a href="../function/function">Function</a>&lt;? super T,​? extends K&gt; keyMapper,
                 <a href="../function/function">Function</a>&lt;? super T,​? extends U&gt; valueMapper)</code></th> <td> <p>Returns a <code>Collector</code> that accumulates the input elements into an <a href="../map#unmodifiable">unmodifiable Map</a>, whose keys and values are the result of applying the provided mapping functions to the input elements.</p> </td> </tr> <tr id="i41"> <td><code>static &lt;T,​K,​U&gt;<br><a href="collector">Collector</a>&lt;T,​?,​<a href="../map">Map</a>&lt;K,​U&gt;&gt;</code></td> <th scope="row"><code><a href="#toUnmodifiableMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator)">toUnmodifiableMap</a>​(<a href="../function/function">Function</a>&lt;? super T,​? extends K&gt; keyMapper,
                 <a href="../function/function">Function</a>&lt;? super T,​? extends U&gt; valueMapper,
                 <a href="../function/binaryoperator">BinaryOperator</a>&lt;U&gt; mergeFunction)</code></th> <td> <p>Returns a <code>Collector</code> that accumulates the input elements into an <a href="../map#unmodifiable">unmodifiable Map</a>, whose keys and values are the result of applying the provided mapping functions to the input elements.</p> </td> </tr> <tr id="i42"> <td><code>static &lt;T&gt; <a href="collector">Collector</a>&lt;T,​?,​<a href="../set">Set</a>&lt;T&gt;&gt;</code></td> <th scope="row"><code><a href="#toUnmodifiableSet()">toUnmodifiableSet</a>()</code></th> <td> <p>Returns a <code>Collector</code> that accumulates the input elements into an <a href="../set#unmodifiable">unmodifiable Set</a>.</p> </td> </tr> </table>  <h2 id="methods.inherited.from.class.java.lang.Object">Methods declared in class java.lang.<a href="../../lang/object">Object</a>
</h2> <code><a href="../../lang/object#clone()">clone</a>, <a href="../../lang/object#equals(java.lang.Object)">equals</a>, <a href="../../lang/object#finalize()">finalize</a>, <a href="../../lang/object#getClass()">getClass</a>, <a href="../../lang/object#hashCode()">hashCode</a>, <a href="../../lang/object#notify()">notify</a>, <a href="../../lang/object#notifyAll()">notifyAll</a>, <a href="../../lang/object#toString()">toString</a>, <a href="../../lang/object#wait()">wait</a>, <a href="../../lang/object#wait(long)">wait</a>, <a href="../../lang/object#wait(long,int)">wait</a></code>  </section>   <div>   <section role="region">  <h2 id="method.detail">Methods</h2>   <h3 id="toCollection(java.util.function.Supplier)">toCollection</h3> <pre data-language="java">public static &lt;T,C extends Collection&lt;T&gt;&gt; Collector&lt;T,​?,​C&gt; toCollection​(Supplier&lt;C&gt; collectionFactory)</pre> <p>Returns a <code>Collector</code> that accumulates the input elements into a new <code>Collection</code>, in encounter order. The <code>Collection</code> is created by the provided factory.</p> <dl> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the type of the input elements</dd> <dd>
<code>C</code> - the type of the resulting <code>Collection</code>
</dd> <dt>Parameters:</dt> <dd>
<code>collectionFactory</code> - a supplier providing a new empty <code>Collection</code> into which the results will be inserted</dd> <dt>Returns:</dt> <dd>a <code>Collector</code> which collects all the input elements into a <code>Collection</code>, in encounter order</dd> </dl>    <h3 id="toList()">toList</h3> <pre data-language="java">public static &lt;T&gt; Collector&lt;T,?,​List&lt;T&gt;&gt; toList()</pre> <p>Returns a <code>Collector</code> that accumulates the input elements into a new <code>List</code>. There are no guarantees on the type, mutability, serializability, or thread-safety of the <code>List</code> returned; if more control over the returned <code>List</code> is required, use <a href="#toCollection(java.util.function.Supplier)"><code>toCollection(Supplier)</code></a>.</p> <dl> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the type of the input elements</dd> <dt>Returns:</dt> <dd>a <code>Collector</code> which collects all the input elements into a <code>List</code>, in encounter order</dd> </dl>    <h3 id="toUnmodifiableList()">toUnmodifiableList</h3> <pre data-language="java">public static &lt;T&gt; Collector&lt;T,?,​List&lt;T&gt;&gt; toUnmodifiableList()</pre> <p>Returns a <code>Collector</code> that accumulates the input elements into an <a href="../list#unmodifiable">unmodifiable List</a> in encounter order. The returned Collector disallows null values and will throw <code>NullPointerException</code> if it is presented with a null value.</p> <dl> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the type of the input elements</dd> <dt>Returns:</dt> <dd>a <code>Collector</code> that accumulates the input elements into an <a href="../list#unmodifiable">unmodifiable List</a> in encounter order</dd> <dt>Since:</dt> <dd>10</dd> </dl>    <h3 id="toSet()">toSet</h3> <pre data-language="java">public static &lt;T&gt; Collector&lt;T,?,​Set&lt;T&gt;&gt; toSet()</pre> <div>
<p>Returns a <code>Collector</code> that accumulates the input elements into a new <code>Set</code>. There are no guarantees on the type, mutability, serializability, or thread-safety of the <code>Set</code> returned; if more control over the returned <code>Set</code> is required, use <a href="#toCollection(java.util.function.Supplier)"><code>toCollection(Supplier)</code></a>. </p>
<p>This is an <a href="collector.characteristics#UNORDERED"><code>unordered</code></a> Collector.</p>
</div> <dl> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the type of the input elements</dd> <dt>Returns:</dt> <dd>a <code>Collector</code> which collects all the input elements into a <code>Set</code>
</dd> </dl>    <h3 id="toUnmodifiableSet()">toUnmodifiableSet</h3> <pre data-language="java">public static &lt;T&gt; Collector&lt;T,?,​Set&lt;T&gt;&gt; toUnmodifiableSet()</pre> <div>
<p>Returns a <code>Collector</code> that accumulates the input elements into an <a href="../set#unmodifiable">unmodifiable Set</a>. The returned Collector disallows null values and will throw <code>NullPointerException</code> if it is presented with a null value. If the input contains duplicate elements, an arbitrary element of the duplicates is preserved. </p>
<p>This is an <a href="collector.characteristics#UNORDERED"><code>unordered</code></a> Collector.</p>
</div> <dl> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the type of the input elements</dd> <dt>Returns:</dt> <dd>a <code>Collector</code> that accumulates the input elements into an <a href="../set#unmodifiable">unmodifiable Set</a>
</dd> <dt>Since:</dt> <dd>10</dd> </dl>    <h3 id="joining()">joining</h3> <pre data-language="java">public static Collector&lt;CharSequence,?,​String&gt; joining()</pre> <p>Returns a <code>Collector</code> that concatenates the input elements into a <code>String</code>, in encounter order.</p> <dl> <dt>Returns:</dt> <dd>a <code>Collector</code> that concatenates the input elements into a <code>String</code>, in encounter order</dd> </dl>    <h3 id="joining(java.lang.CharSequence)">joining</h3> <pre data-language="java">public static Collector&lt;CharSequence,?,​String&gt; joining​(CharSequence delimiter)</pre> <p>Returns a <code>Collector</code> that concatenates the input elements, separated by the specified delimiter, in encounter order.</p> <dl> <dt>Parameters:</dt> <dd>
<code>delimiter</code> - the delimiter to be used between each element</dd> <dt>Returns:</dt> <dd>A <code>Collector</code> which concatenates CharSequence elements, separated by the specified delimiter, in encounter order</dd> </dl>    <h3 id="joining(java.lang.CharSequence,java.lang.CharSequence,java.lang.CharSequence)">joining</h3> <pre data-language="java">public static Collector&lt;CharSequence,?,​String&gt; joining​(CharSequence delimiter,
                                                                   CharSequence prefix,
                                                                   CharSequence suffix)</pre> <p>Returns a <code>Collector</code> that concatenates the input elements, separated by the specified delimiter, with the specified prefix and suffix, in encounter order.</p> <dl> <dt>Parameters:</dt> <dd>
<code>delimiter</code> - the delimiter to be used between each element</dd> <dd>
<code>prefix</code> - the sequence of characters to be used at the beginning of the joined result</dd> <dd>
<code>suffix</code> - the sequence of characters to be used at the end of the joined result</dd> <dt>Returns:</dt> <dd>A <code>Collector</code> which concatenates CharSequence elements, separated by the specified delimiter, in encounter order</dd> </dl>    <h3 id="mapping(java.util.function.Function,java.util.stream.Collector)">mapping</h3> <pre data-language="java">public static &lt;T,U,​A,​R&gt; Collector&lt;T,​?,​R&gt; mapping​(Function&lt;? super T,​? extends U&gt; mapper,
                                                                               Collector&lt;? super U,​A,​R&gt; downstream)</pre> <p>Adapts a <code>Collector</code> accepting elements of type <code>U</code> to one accepting elements of type <code>T</code> by applying a mapping function to each input element before accumulation.</p> <dl> <dt>API Note:</dt> <dd>The <code>mapping()</code> collectors are most useful when used in a multi-level reduction, such as downstream of a <code>groupingBy</code> or <code>partitioningBy</code>. For example, given a stream of <code>Person</code>, to accumulate the set of last names in each city: <pre data-language="java">Map&lt;City, Set&lt;String&gt;&gt; lastNamesByCity
   = people.stream().collect(
     groupingBy(Person::getCity,
                mapping(Person::getLastName,
                        toSet())));</pre>
</dd> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the type of the input elements</dd> <dd>
<code>U</code> - type of elements accepted by downstream collector</dd> <dd>
<code>A</code> - intermediate accumulation type of the downstream collector</dd> <dd>
<code>R</code> - result type of collector</dd> <dt>Parameters:</dt> <dd>
<code>mapper</code> - a function to be applied to the input elements</dd> <dd>
<code>downstream</code> - a collector which will accept mapped values</dd> <dt>Returns:</dt> <dd>a collector which applies the mapping function to the input elements and provides the mapped results to the downstream collector</dd> </dl>    <h3 id="flatMapping(java.util.function.Function,java.util.stream.Collector)">flatMapping</h3> <pre data-language="java">public static &lt;T,U,​A,​R&gt; Collector&lt;T,​?,​R&gt; flatMapping​(Function&lt;? super T,​? extends Stream&lt;? extends U&gt;&gt; mapper,
                                                                                   Collector&lt;? super U,​A,​R&gt; downstream)</pre> <p>Adapts a <code>Collector</code> accepting elements of type <code>U</code> to one accepting elements of type <code>T</code> by applying a flat mapping function to each input element before accumulation. The flat mapping function maps an input element to a <a href="stream"><code>stream</code></a> covering zero or more output elements that are then accumulated downstream. Each mapped stream is <a href="basestream#close()"><code>closed</code></a> after its contents have been placed downstream. (If a mapped stream is <code>null</code> an empty stream is used, instead.)</p> <dl> <dt>API Note:</dt> <dd>The <code>flatMapping()</code> collectors are most useful when used in a multi-level reduction, such as downstream of a <code>groupingBy</code> or <code>partitioningBy</code>. For example, given a stream of <code>Order</code>, to accumulate the set of line items for each customer: <pre data-language="java">Map&lt;String, Set&lt;LineItem&gt;&gt; itemsByCustomerName
   = orders.stream().collect(
     groupingBy(Order::getCustomerName,
                flatMapping(order -&gt; order.getLineItems().stream(),
                            toSet())));</pre>
</dd> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the type of the input elements</dd> <dd>
<code>U</code> - type of elements accepted by downstream collector</dd> <dd>
<code>A</code> - intermediate accumulation type of the downstream collector</dd> <dd>
<code>R</code> - result type of collector</dd> <dt>Parameters:</dt> <dd>
<code>mapper</code> - a function to be applied to the input elements, which returns a stream of results</dd> <dd>
<code>downstream</code> - a collector which will receive the elements of the stream returned by mapper</dd> <dt>Returns:</dt> <dd>a collector which applies the mapping function to the input elements and provides the flat mapped results to the downstream collector</dd> <dt>Since:</dt> <dd>9</dd> </dl>    <h3 id="filtering(java.util.function.Predicate,java.util.stream.Collector)">filtering</h3> <pre data-language="java">public static &lt;T,A,​R&gt; Collector&lt;T,​?,​R&gt; filtering​(Predicate&lt;? super T&gt; predicate,
                                                                         Collector&lt;? super T,​A,​R&gt; downstream)</pre> <p>Adapts a <code>Collector</code> to one accepting elements of the same type <code>T</code> by applying the predicate to each input element and only accumulating if the predicate returns <code>true</code>.</p> <dl> <dt>API Note:</dt> <dd>The <code>filtering()</code> collectors are most useful when used in a multi-level reduction, such as downstream of a <code>groupingBy</code> or <code>partitioningBy</code>. For example, given a stream of <code>Employee</code>, to accumulate the employees in each department that have a salary above a certain threshold: <pre data-language="java">Map&lt;Department, Set&lt;Employee&gt;&gt; wellPaidEmployeesByDepartment
   = employees.stream().collect(
     groupingBy(Employee::getDepartment,
                filtering(e -&gt; e.getSalary() &gt; 2000,
                          toSet())));</pre> A filtering collector differs from a stream's <code>filter()</code> operation. In this example, suppose there are no employees whose salary is above the threshold in some department. Using a filtering collector as shown above would result in a mapping from that department to an empty <code>Set</code>. If a stream <code>filter()</code> operation were done instead, there would be no mapping for that department at all.</dd> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the type of the input elements</dd> <dd>
<code>A</code> - intermediate accumulation type of the downstream collector</dd> <dd>
<code>R</code> - result type of collector</dd> <dt>Parameters:</dt> <dd>
<code>predicate</code> - a predicate to be applied to the input elements</dd> <dd>
<code>downstream</code> - a collector which will accept values that match the predicate</dd> <dt>Returns:</dt> <dd>a collector which applies the predicate to the input elements and provides matching elements to the downstream collector</dd> <dt>Since:</dt> <dd>9</dd> </dl>    <h3 id="collectingAndThen(java.util.stream.Collector,java.util.function.Function)">collectingAndThen</h3> <pre data-language="java">public static &lt;T,A,​R,​RR&gt; Collector&lt;T,​A,​RR&gt; collectingAndThen​(Collector&lt;T,​A,​R&gt; downstream,
                                                                                           Function&lt;R,​RR&gt; finisher)</pre> <p>Adapts a <code>Collector</code> to perform an additional finishing transformation. For example, one could adapt the <a href="#toList()"><code>toList()</code></a> collector to always produce an immutable list with: <pre data-language="java">List&lt;String&gt; list = people.stream().collect(
   collectingAndThen(toList(),
                     Collections::unmodifiableList));</pre></p> <dl> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the type of the input elements</dd> <dd>
<code>A</code> - intermediate accumulation type of the downstream collector</dd> <dd>
<code>R</code> - result type of the downstream collector</dd> <dd>
<code>RR</code> - result type of the resulting collector</dd> <dt>Parameters:</dt> <dd>
<code>downstream</code> - a collector</dd> <dd>
<code>finisher</code> - a function to be applied to the final result of the downstream collector</dd> <dt>Returns:</dt> <dd>a collector which performs the action of the downstream collector, followed by an additional finishing step</dd> </dl>    <h3 id="counting()">counting</h3> <pre data-language="java">public static &lt;T&gt; Collector&lt;T,?,​Long&gt; counting()</pre> <p>Returns a <code>Collector</code> accepting elements of type <code>T</code> that counts the number of input elements. If no elements are present, the result is 0.</p> <dl> <dt>Implementation Requirements:</dt> <dd>This produces a result equivalent to: <pre data-language="java">reducing(0L, e -&gt; 1L, Long::sum)</pre>
</dd> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the type of the input elements</dd> <dt>Returns:</dt> <dd>a <code>Collector</code> that counts the input elements</dd> </dl>    <h3 id="minBy(java.util.Comparator)">minBy</h3> <pre data-language="java">public static &lt;T&gt; Collector&lt;T,?,​Optional&lt;T&gt;&gt; minBy​(Comparator&lt;? super T&gt; comparator)</pre> <p>Returns a <code>Collector</code> that produces the minimal element according to a given <code>Comparator</code>, described as an <code>Optional&lt;T&gt;</code>.</p> <dl> <dt>Implementation Requirements:</dt> <dd>This produces a result equivalent to: <pre data-language="java">reducing(BinaryOperator.minBy(comparator))</pre>
</dd> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the type of the input elements</dd> <dt>Parameters:</dt> <dd>
<code>comparator</code> - a <code>Comparator</code> for comparing elements</dd> <dt>Returns:</dt> <dd>a <code>Collector</code> that produces the minimal value</dd> </dl>    <h3 id="maxBy(java.util.Comparator)">maxBy</h3> <pre data-language="java">public static &lt;T&gt; Collector&lt;T,?,​Optional&lt;T&gt;&gt; maxBy​(Comparator&lt;? super T&gt; comparator)</pre> <p>Returns a <code>Collector</code> that produces the maximal element according to a given <code>Comparator</code>, described as an <code>Optional&lt;T&gt;</code>.</p> <dl> <dt>Implementation Requirements:</dt> <dd>This produces a result equivalent to: <pre data-language="java">reducing(BinaryOperator.maxBy(comparator))</pre>
</dd> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the type of the input elements</dd> <dt>Parameters:</dt> <dd>
<code>comparator</code> - a <code>Comparator</code> for comparing elements</dd> <dt>Returns:</dt> <dd>a <code>Collector</code> that produces the maximal value</dd> </dl>    <h3 id="summingInt(java.util.function.ToIntFunction)">summingInt</h3> <pre data-language="java">public static &lt;T&gt; Collector&lt;T,?,​Integer&gt; summingInt​(ToIntFunction&lt;? super T&gt; mapper)</pre> <p>Returns a <code>Collector</code> that produces the sum of a integer-valued function applied to the input elements. If no elements are present, the result is 0.</p> <dl> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the type of the input elements</dd> <dt>Parameters:</dt> <dd>
<code>mapper</code> - a function extracting the property to be summed</dd> <dt>Returns:</dt> <dd>a <code>Collector</code> that produces the sum of a derived property</dd> </dl>    <h3 id="summingLong(java.util.function.ToLongFunction)">summingLong</h3> <pre data-language="java">public static &lt;T&gt; Collector&lt;T,?,​Long&gt; summingLong​(ToLongFunction&lt;? super T&gt; mapper)</pre> <p>Returns a <code>Collector</code> that produces the sum of a long-valued function applied to the input elements. If no elements are present, the result is 0.</p> <dl> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the type of the input elements</dd> <dt>Parameters:</dt> <dd>
<code>mapper</code> - a function extracting the property to be summed</dd> <dt>Returns:</dt> <dd>a <code>Collector</code> that produces the sum of a derived property</dd> </dl>    <h3 id="summingDouble(java.util.function.ToDoubleFunction)">summingDouble</h3> <pre data-language="java">public static &lt;T&gt; Collector&lt;T,?,​Double&gt; summingDouble​(ToDoubleFunction&lt;? super T&gt; mapper)</pre> <div>
<p>Returns a <code>Collector</code> that produces the sum of a double-valued function applied to the input elements. If no elements are present, the result is 0. </p>
<p>The sum returned can vary depending upon the order in which values are recorded, due to accumulated rounding error in addition of values of differing magnitudes. Values sorted by increasing absolute magnitude tend to yield more accurate results. If any recorded value is a <code>NaN</code> or the sum is at any point a <code>NaN</code> then the sum will be <code>NaN</code>.</p>
</div> <dl> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the type of the input elements</dd> <dt>Parameters:</dt> <dd>
<code>mapper</code> - a function extracting the property to be summed</dd> <dt>Returns:</dt> <dd>a <code>Collector</code> that produces the sum of a derived property</dd> </dl>    <h3 id="averagingInt(java.util.function.ToIntFunction)">averagingInt</h3> <pre data-language="java">public static &lt;T&gt; Collector&lt;T,?,​Double&gt; averagingInt​(ToIntFunction&lt;? super T&gt; mapper)</pre> <p>Returns a <code>Collector</code> that produces the arithmetic mean of an integer-valued function applied to the input elements. If no elements are present, the result is 0.</p> <dl> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the type of the input elements</dd> <dt>Parameters:</dt> <dd>
<code>mapper</code> - a function extracting the property to be averaged</dd> <dt>Returns:</dt> <dd>a <code>Collector</code> that produces the arithmetic mean of a derived property</dd> </dl>    <h3 id="averagingLong(java.util.function.ToLongFunction)">averagingLong</h3> <pre data-language="java">public static &lt;T&gt; Collector&lt;T,?,​Double&gt; averagingLong​(ToLongFunction&lt;? super T&gt; mapper)</pre> <p>Returns a <code>Collector</code> that produces the arithmetic mean of a long-valued function applied to the input elements. If no elements are present, the result is 0.</p> <dl> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the type of the input elements</dd> <dt>Parameters:</dt> <dd>
<code>mapper</code> - a function extracting the property to be averaged</dd> <dt>Returns:</dt> <dd>a <code>Collector</code> that produces the arithmetic mean of a derived property</dd> </dl>    <h3 id="averagingDouble(java.util.function.ToDoubleFunction)">averagingDouble</h3> <pre data-language="java">public static &lt;T&gt; Collector&lt;T,?,​Double&gt; averagingDouble​(ToDoubleFunction&lt;? super T&gt; mapper)</pre> <div>
<p>Returns a <code>Collector</code> that produces the arithmetic mean of a double-valued function applied to the input elements. If no elements are present, the result is 0. </p>
<p>The average returned can vary depending upon the order in which values are recorded, due to accumulated rounding error in addition of values of differing magnitudes. Values sorted by increasing absolute magnitude tend to yield more accurate results. If any recorded value is a <code>NaN</code> or the sum is at any point a <code>NaN</code> then the average will be <code>NaN</code>.</p>
</div> <dl> <dt>Implementation Note:</dt> <dd>The <code>double</code> format can represent all consecutive integers in the range -2<sup>53</sup> to 2<sup>53</sup>. If the pipeline has more than 2<sup>53</sup> values, the divisor in the average computation will saturate at 2<sup>53</sup>, leading to additional numerical errors.</dd> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the type of the input elements</dd> <dt>Parameters:</dt> <dd>
<code>mapper</code> - a function extracting the property to be averaged</dd> <dt>Returns:</dt> <dd>a <code>Collector</code> that produces the arithmetic mean of a derived property</dd> </dl>    <h3 id="reducing(java.lang.Object,java.util.function.BinaryOperator)">reducing</h3> <pre data-language="java">public static &lt;T&gt; Collector&lt;T,?,​T&gt; reducing​(T identity,
                                                        BinaryOperator&lt;T&gt; op)</pre> <p>Returns a <code>Collector</code> which performs a reduction of its input elements under a specified <code>BinaryOperator</code> using the provided identity.</p> <dl> <dt>API Note:</dt> <dd>The <code>reducing()</code> collectors are most useful when used in a multi-level reduction, downstream of <code>groupingBy</code> or <code>partitioningBy</code>. To perform a simple reduction on a stream, use <a href="stream#reduce(T,java.util.function.BinaryOperator)"><code>Stream.reduce(Object, BinaryOperator)</code></a>} instead.</dd> <dt>Type Parameters:</dt> <dd>
<code>T</code> - element type for the input and output of the reduction</dd> <dt>Parameters:</dt> <dd>
<code>identity</code> - the identity value for the reduction (also, the value that is returned when there are no input elements)</dd> <dd>
<code>op</code> - a <code>BinaryOperator&lt;T&gt;</code> used to reduce the input elements</dd> <dt>Returns:</dt> <dd>a <code>Collector</code> which implements the reduction operation</dd> <dt>See Also:</dt> <dd>
<a href="#reducing(java.util.function.BinaryOperator)"><code>reducing(BinaryOperator)</code></a>, <a href="#reducing(U,java.util.function.Function,java.util.function.BinaryOperator)"><code>reducing(Object, Function, BinaryOperator)</code></a>
</dd> </dl>    <h3 id="reducing(java.util.function.BinaryOperator)">reducing</h3> <pre data-language="java">public static &lt;T&gt; Collector&lt;T,?,​Optional&lt;T&gt;&gt; reducing​(BinaryOperator&lt;T&gt; op)</pre> <p>Returns a <code>Collector</code> which performs a reduction of its input elements under a specified <code>BinaryOperator</code>. The result is described as an <code>Optional&lt;T&gt;</code>.</p> <dl> <dt>API Note:</dt> <dd>The <code>reducing()</code> collectors are most useful when used in a multi-level reduction, downstream of <code>groupingBy</code> or <code>partitioningBy</code>. To perform a simple reduction on a stream, use <a href="stream#reduce(java.util.function.BinaryOperator)"><code>Stream.reduce(BinaryOperator)</code></a> instead. <p>For example, given a stream of <code>Person</code>, to calculate tallest person in each city: </p>
<pre data-language="java">Comparator&lt;Person&gt; byHeight = Comparator.comparing(Person::getHeight);
 Map&lt;City, Optional&lt;Person&gt;&gt; tallestByCity
   = people.stream().collect(
     groupingBy(Person::getCity,
                reducing(BinaryOperator.maxBy(byHeight))));</pre>
</dd> <dt>Type Parameters:</dt> <dd>
<code>T</code> - element type for the input and output of the reduction</dd> <dt>Parameters:</dt> <dd>
<code>op</code> - a <code>BinaryOperator&lt;T&gt;</code> used to reduce the input elements</dd> <dt>Returns:</dt> <dd>a <code>Collector</code> which implements the reduction operation</dd> <dt>See Also:</dt> <dd>
<a href="#reducing(T,java.util.function.BinaryOperator)"><code>reducing(Object, BinaryOperator)</code></a>, <a href="#reducing(U,java.util.function.Function,java.util.function.BinaryOperator)"><code>reducing(Object, Function, BinaryOperator)</code></a>
</dd> </dl>    <h3 id="reducing(java.lang.Object,java.util.function.Function,java.util.function.BinaryOperator)">reducing</h3> <pre data-language="java">public static &lt;T,U&gt; Collector&lt;T,​?,​U&gt; reducing​(U identity,
                                                                Function&lt;? super T,​? extends U&gt; mapper,
                                                                BinaryOperator&lt;U&gt; op)</pre> <p>Returns a <code>Collector</code> which performs a reduction of its input elements under a specified mapping function and <code>BinaryOperator</code>. This is a generalization of <a href="#reducing(T,java.util.function.BinaryOperator)"><code>reducing(Object, BinaryOperator)</code></a> which allows a transformation of the elements before reduction.</p> <dl> <dt>API Note:</dt> <dd>The <code>reducing()</code> collectors are most useful when used in a multi-level reduction, downstream of <code>groupingBy</code> or <code>partitioningBy</code>. To perform a simple map-reduce on a stream, use <a href="stream#map(java.util.function.Function)"><code>Stream.map(Function)</code></a> and <a href="stream#reduce(T,java.util.function.BinaryOperator)"><code>Stream.reduce(Object, BinaryOperator)</code></a> instead. <p>For example, given a stream of <code>Person</code>, to calculate the longest last name of residents in each city: </p>
<pre data-language="java">Comparator&lt;String&gt; byLength = Comparator.comparing(String::length);
 Map&lt;City, String&gt; longestLastNameByCity
   = people.stream().collect(
     groupingBy(Person::getCity,
                reducing("",
                         Person::getLastName,
                         BinaryOperator.maxBy(byLength))));</pre>
</dd> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the type of the input elements</dd> <dd>
<code>U</code> - the type of the mapped values</dd> <dt>Parameters:</dt> <dd>
<code>identity</code> - the identity value for the reduction (also, the value that is returned when there are no input elements)</dd> <dd>
<code>mapper</code> - a mapping function to apply to each input value</dd> <dd>
<code>op</code> - a <code>BinaryOperator&lt;U&gt;</code> used to reduce the mapped values</dd> <dt>Returns:</dt> <dd>a <code>Collector</code> implementing the map-reduce operation</dd> <dt>See Also:</dt> <dd>
<a href="#reducing(T,java.util.function.BinaryOperator)"><code>reducing(Object, BinaryOperator)</code></a>, <a href="#reducing(java.util.function.BinaryOperator)"><code>reducing(BinaryOperator)</code></a>
</dd> </dl>    <h3 id="groupingBy(java.util.function.Function)">groupingBy</h3> <pre data-language="java">public static &lt;T,K&gt; Collector&lt;T,​?,​Map&lt;K,​List&lt;T&gt;&gt;&gt; groupingBy​(Function&lt;? super T,​? extends K&gt; classifier)</pre> <div>
<p>Returns a <code>Collector</code> implementing a "group by" operation on input elements of type <code>T</code>, grouping elements according to a classification function, and returning the results in a <code>Map</code>. </p>
<p>The classification function maps elements to some key type <code>K</code>. The collector produces a <code>Map&lt;K, List&lt;T&gt;&gt;</code> whose keys are the values resulting from applying the classification function to the input elements, and whose corresponding values are <code>List</code>s containing the input elements which map to the associated key under the classification function. </p>
<p>There are no guarantees on the type, mutability, serializability, or thread-safety of the <code>Map</code> or <code>List</code> objects returned.</p>
</div> <dl> <dt>Implementation Requirements:</dt> <dd>This produces a result similar to: <pre data-language="java">groupingBy(classifier, toList());</pre>
</dd> <dt>Implementation Note:</dt> <dd>The returned <code>Collector</code> is not concurrent. For parallel stream pipelines, the <code>combiner</code> function operates by merging the keys from one map into another, which can be an expensive operation. If preservation of the order in which elements appear in the resulting <code>Map</code> collector is not required, using <a href="#groupingByConcurrent(java.util.function.Function)"><code>groupingByConcurrent(Function)</code></a> may offer better parallel performance.</dd> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the type of the input elements</dd> <dd>
<code>K</code> - the type of the keys</dd> <dt>Parameters:</dt> <dd>
<code>classifier</code> - the classifier function mapping input elements to keys</dd> <dt>Returns:</dt> <dd>a <code>Collector</code> implementing the group-by operation</dd> <dt>See Also:</dt> <dd>
<a href="#groupingBy(java.util.function.Function,java.util.stream.Collector)"><code>groupingBy(Function, Collector)</code></a>, <a href="#groupingBy(java.util.function.Function,java.util.function.Supplier,java.util.stream.Collector)"><code>groupingBy(Function, Supplier, Collector)</code></a>, <a href="#groupingByConcurrent(java.util.function.Function)"><code>groupingByConcurrent(Function)</code></a>
</dd> </dl>    <h3 id="groupingBy(java.util.function.Function,java.util.stream.Collector)">groupingBy</h3> <pre data-language="java">public static &lt;T,K,​A,​D&gt; Collector&lt;T,​?,​Map&lt;K,​D&gt;&gt; groupingBy​(Function&lt;? super T,​? extends K&gt; classifier,
                                                                                               Collector&lt;? super T,​A,​D&gt; downstream)</pre> <div>
<p>Returns a <code>Collector</code> implementing a cascaded "group by" operation on input elements of type <code>T</code>, grouping elements according to a classification function, and then performing a reduction operation on the values associated with a given key using the specified downstream <code>Collector</code>. </p>
<p>The classification function maps elements to some key type <code>K</code>. The downstream collector operates on elements of type <code>T</code> and produces a result of type <code>D</code>. The resulting collector produces a <code>Map&lt;K, D&gt;</code>. </p>
<p>There are no guarantees on the type, mutability, serializability, or thread-safety of the <code>Map</code> returned. </p>
<p>For example, to compute the set of last names of people in each city: </p>
<pre data-language="java">Map&lt;City, Set&lt;String&gt;&gt; namesByCity
   = people.stream().collect(
     groupingBy(Person::getCity,
                mapping(Person::getLastName,
                        toSet())));</pre>
</div> <dl> <dt>Implementation Note:</dt> <dd>The returned <code>Collector</code> is not concurrent. For parallel stream pipelines, the <code>combiner</code> function operates by merging the keys from one map into another, which can be an expensive operation. If preservation of the order in which elements are presented to the downstream collector is not required, using <a href="#groupingByConcurrent(java.util.function.Function,java.util.stream.Collector)"><code>groupingByConcurrent(Function, Collector)</code></a> may offer better parallel performance.</dd> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the type of the input elements</dd> <dd>
<code>K</code> - the type of the keys</dd> <dd>
<code>A</code> - the intermediate accumulation type of the downstream collector</dd> <dd>
<code>D</code> - the result type of the downstream reduction</dd> <dt>Parameters:</dt> <dd>
<code>classifier</code> - a classifier function mapping input elements to keys</dd> <dd>
<code>downstream</code> - a <code>Collector</code> implementing the downstream reduction</dd> <dt>Returns:</dt> <dd>a <code>Collector</code> implementing the cascaded group-by operation</dd> <dt>See Also:</dt> <dd>
<a href="#groupingBy(java.util.function.Function)"><code>groupingBy(Function)</code></a>, <a href="#groupingBy(java.util.function.Function,java.util.function.Supplier,java.util.stream.Collector)"><code>groupingBy(Function, Supplier, Collector)</code></a>, <a href="#groupingByConcurrent(java.util.function.Function,java.util.stream.Collector)"><code>groupingByConcurrent(Function, Collector)</code></a>
</dd> </dl>    <h3 id="groupingBy(java.util.function.Function,java.util.function.Supplier,java.util.stream.Collector)">groupingBy</h3> <pre data-language="java">public static &lt;T,K,​D,​A,​M extends Map&lt;K,​D&gt;&gt; Collector&lt;T,​?,​M&gt; groupingBy​(Function&lt;? super T,​? extends K&gt; classifier,
                                                                                                                 Supplier&lt;M&gt; mapFactory,
                                                                                                                 Collector&lt;? super T,​A,​D&gt; downstream)</pre> <div>
<p>Returns a <code>Collector</code> implementing a cascaded "group by" operation on input elements of type <code>T</code>, grouping elements according to a classification function, and then performing a reduction operation on the values associated with a given key using the specified downstream <code>Collector</code>. The <code>Map</code> produced by the Collector is created with the supplied factory function. </p>
<p>The classification function maps elements to some key type <code>K</code>. The downstream collector operates on elements of type <code>T</code> and produces a result of type <code>D</code>. The resulting collector produces a <code>Map&lt;K, D&gt;</code>. </p>
<p>For example, to compute the set of last names of people in each city, where the city names are sorted: </p>
<pre data-language="java">Map&lt;City, Set&lt;String&gt;&gt; namesByCity
   = people.stream().collect(
     groupingBy(Person::getCity,
                TreeMap::new,
                mapping(Person::getLastName,
                        toSet())));</pre>
</div> <dl> <dt>Implementation Note:</dt> <dd>The returned <code>Collector</code> is not concurrent. For parallel stream pipelines, the <code>combiner</code> function operates by merging the keys from one map into another, which can be an expensive operation. If preservation of the order in which elements are presented to the downstream collector is not required, using <a href="#groupingByConcurrent(java.util.function.Function,java.util.function.Supplier,java.util.stream.Collector)"><code>groupingByConcurrent(Function, Supplier, Collector)</code></a> may offer better parallel performance.</dd> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the type of the input elements</dd> <dd>
<code>K</code> - the type of the keys</dd> <dd>
<code>A</code> - the intermediate accumulation type of the downstream collector</dd> <dd>
<code>D</code> - the result type of the downstream reduction</dd> <dd>
<code>M</code> - the type of the resulting <code>Map</code>
</dd> <dt>Parameters:</dt> <dd>
<code>classifier</code> - a classifier function mapping input elements to keys</dd> <dd>
<code>downstream</code> - a <code>Collector</code> implementing the downstream reduction</dd> <dd>
<code>mapFactory</code> - a supplier providing a new empty <code>Map</code> into which the results will be inserted</dd> <dt>Returns:</dt> <dd>a <code>Collector</code> implementing the cascaded group-by operation</dd> <dt>See Also:</dt> <dd>
<a href="#groupingBy(java.util.function.Function,java.util.stream.Collector)"><code>groupingBy(Function, Collector)</code></a>, <a href="#groupingBy(java.util.function.Function)"><code>groupingBy(Function)</code></a>, <a href="#groupingByConcurrent(java.util.function.Function,java.util.function.Supplier,java.util.stream.Collector)"><code>groupingByConcurrent(Function, Supplier, Collector)</code></a>
</dd> </dl>    <h3 id="groupingByConcurrent(java.util.function.Function)">groupingByConcurrent</h3> <pre data-language="java">public static &lt;T,K&gt; Collector&lt;T,​?,​ConcurrentMap&lt;K,​List&lt;T&gt;&gt;&gt; groupingByConcurrent​(Function&lt;? super T,​? extends K&gt; classifier)</pre> <div>
<p>Returns a concurrent <code>Collector</code> implementing a "group by" operation on input elements of type <code>T</code>, grouping elements according to a classification function. </p>
<p>This is a <a href="collector.characteristics#CONCURRENT"><code>concurrent</code></a> and <a href="collector.characteristics#UNORDERED"><code>unordered</code></a> Collector. </p>
<p>The classification function maps elements to some key type <code>K</code>. The collector produces a <code>ConcurrentMap&lt;K, List&lt;T&gt;&gt;</code> whose keys are the values resulting from applying the classification function to the input elements, and whose corresponding values are <code>List</code>s containing the input elements which map to the associated key under the classification function. </p>
<p>There are no guarantees on the type, mutability, or serializability of the <code>ConcurrentMap</code> or <code>List</code> objects returned, or of the thread-safety of the <code>List</code> objects returned.</p>
</div> <dl> <dt>Implementation Requirements:</dt> <dd>This produces a result similar to: <pre data-language="java">groupingByConcurrent(classifier, toList());</pre>
</dd> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the type of the input elements</dd> <dd>
<code>K</code> - the type of the keys</dd> <dt>Parameters:</dt> <dd>
<code>classifier</code> - a classifier function mapping input elements to keys</dd> <dt>Returns:</dt> <dd>a concurrent, unordered <code>Collector</code> implementing the group-by operation</dd> <dt>See Also:</dt> <dd>
<a href="#groupingBy(java.util.function.Function)"><code>groupingBy(Function)</code></a>, <a href="#groupingByConcurrent(java.util.function.Function,java.util.stream.Collector)"><code>groupingByConcurrent(Function, Collector)</code></a>, <a href="#groupingByConcurrent(java.util.function.Function,java.util.function.Supplier,java.util.stream.Collector)"><code>groupingByConcurrent(Function, Supplier, Collector)</code></a>
</dd> </dl>    <h3 id="groupingByConcurrent(java.util.function.Function,java.util.stream.Collector)">groupingByConcurrent</h3> <pre data-language="java">public static &lt;T,K,​A,​D&gt; Collector&lt;T,​?,​ConcurrentMap&lt;K,​D&gt;&gt; groupingByConcurrent​(Function&lt;? super T,​? extends K&gt; classifier,
                                                                                                                   Collector&lt;? super T,​A,​D&gt; downstream)</pre> <div>
<p>Returns a concurrent <code>Collector</code> implementing a cascaded "group by" operation on input elements of type <code>T</code>, grouping elements according to a classification function, and then performing a reduction operation on the values associated with a given key using the specified downstream <code>Collector</code>. </p>
<p>This is a <a href="collector.characteristics#CONCURRENT"><code>concurrent</code></a> and <a href="collector.characteristics#UNORDERED"><code>unordered</code></a> Collector. </p>
<p>The classification function maps elements to some key type <code>K</code>. The downstream collector operates on elements of type <code>T</code> and produces a result of type <code>D</code>. The resulting collector produces a <code>ConcurrentMap&lt;K, D&gt;</code>. </p>
<p>There are no guarantees on the type, mutability, or serializability of the <code>ConcurrentMap</code> returned. </p>
<p>For example, to compute the set of last names of people in each city, where the city names are sorted: </p>
<pre data-language="java">ConcurrentMap&lt;City, Set&lt;String&gt;&gt; namesByCity
   = people.stream().collect(
     groupingByConcurrent(Person::getCity,
                          mapping(Person::getLastName,
                                  toSet())));</pre>
</div> <dl> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the type of the input elements</dd> <dd>
<code>K</code> - the type of the keys</dd> <dd>
<code>A</code> - the intermediate accumulation type of the downstream collector</dd> <dd>
<code>D</code> - the result type of the downstream reduction</dd> <dt>Parameters:</dt> <dd>
<code>classifier</code> - a classifier function mapping input elements to keys</dd> <dd>
<code>downstream</code> - a <code>Collector</code> implementing the downstream reduction</dd> <dt>Returns:</dt> <dd>a concurrent, unordered <code>Collector</code> implementing the cascaded group-by operation</dd> <dt>See Also:</dt> <dd>
<a href="#groupingBy(java.util.function.Function,java.util.stream.Collector)"><code>groupingBy(Function, Collector)</code></a>, <a href="#groupingByConcurrent(java.util.function.Function)"><code>groupingByConcurrent(Function)</code></a>, <a href="#groupingByConcurrent(java.util.function.Function,java.util.function.Supplier,java.util.stream.Collector)"><code>groupingByConcurrent(Function, Supplier, Collector)</code></a>
</dd> </dl>    <h3 id="groupingByConcurrent(java.util.function.Function,java.util.function.Supplier,java.util.stream.Collector)">groupingByConcurrent</h3> <pre data-language="java">public static &lt;T,K,​A,​D,​M extends ConcurrentMap&lt;K,​D&gt;&gt; Collector&lt;T,​?,​M&gt; groupingByConcurrent​(Function&lt;? super T,​? extends K&gt; classifier,
                                                                                                                                     Supplier&lt;M&gt; mapFactory,
                                                                                                                                     Collector&lt;? super T,​A,​D&gt; downstream)</pre> <div>
<p>Returns a concurrent <code>Collector</code> implementing a cascaded "group by" operation on input elements of type <code>T</code>, grouping elements according to a classification function, and then performing a reduction operation on the values associated with a given key using the specified downstream <code>Collector</code>. The <code>ConcurrentMap</code> produced by the Collector is created with the supplied factory function. </p>
<p>This is a <a href="collector.characteristics#CONCURRENT"><code>concurrent</code></a> and <a href="collector.characteristics#UNORDERED"><code>unordered</code></a> Collector. </p>
<p>The classification function maps elements to some key type <code>K</code>. The downstream collector operates on elements of type <code>T</code> and produces a result of type <code>D</code>. The resulting collector produces a <code>ConcurrentMap&lt;K, D&gt;</code>. </p>
<p>For example, to compute the set of last names of people in each city, where the city names are sorted: </p>
<pre data-language="java">ConcurrentMap&lt;City, Set&lt;String&gt;&gt; namesByCity
   = people.stream().collect(
     groupingByConcurrent(Person::getCity,
                          ConcurrentSkipListMap::new,
                          mapping(Person::getLastName,
                                  toSet())));</pre>
</div> <dl> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the type of the input elements</dd> <dd>
<code>K</code> - the type of the keys</dd> <dd>
<code>A</code> - the intermediate accumulation type of the downstream collector</dd> <dd>
<code>D</code> - the result type of the downstream reduction</dd> <dd>
<code>M</code> - the type of the resulting <code>ConcurrentMap</code>
</dd> <dt>Parameters:</dt> <dd>
<code>classifier</code> - a classifier function mapping input elements to keys</dd> <dd>
<code>downstream</code> - a <code>Collector</code> implementing the downstream reduction</dd> <dd>
<code>mapFactory</code> - a supplier providing a new empty <code>ConcurrentMap</code> into which the results will be inserted</dd> <dt>Returns:</dt> <dd>a concurrent, unordered <code>Collector</code> implementing the cascaded group-by operation</dd> <dt>See Also:</dt> <dd>
<a href="#groupingByConcurrent(java.util.function.Function)"><code>groupingByConcurrent(Function)</code></a>, <a href="#groupingByConcurrent(java.util.function.Function,java.util.stream.Collector)"><code>groupingByConcurrent(Function, Collector)</code></a>, <a href="#groupingBy(java.util.function.Function,java.util.function.Supplier,java.util.stream.Collector)"><code>groupingBy(Function, Supplier, Collector)</code></a>
</dd> </dl>    <h3 id="partitioningBy(java.util.function.Predicate)">partitioningBy</h3> <pre data-language="java">public static &lt;T&gt; Collector&lt;T,?,​Map&lt;Boolean,​List&lt;T&gt;&gt;&gt; partitioningBy​(Predicate&lt;? super T&gt; predicate)</pre> <p>Returns a <code>Collector</code> which partitions the input elements according to a <code>Predicate</code>, and organizes them into a <code>Map&lt;Boolean, List&lt;T&gt;&gt;</code>. The returned <code>Map</code> always contains mappings for both <code>false</code> and <code>true</code> keys. There are no guarantees on the type, mutability, serializability, or thread-safety of the <code>Map</code> or <code>List</code> returned.</p> <dl> <dt>API Note:</dt> <dd>If a partition has no elements, its value in the result Map will be an empty List.</dd> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the type of the input elements</dd> <dt>Parameters:</dt> <dd>
<code>predicate</code> - a predicate used for classifying input elements</dd> <dt>Returns:</dt> <dd>a <code>Collector</code> implementing the partitioning operation</dd> <dt>See Also:</dt> <dd><a href="#partitioningBy(java.util.function.Predicate,java.util.stream.Collector)"><code>partitioningBy(Predicate, Collector)</code></a></dd> </dl>    <h3 id="partitioningBy(java.util.function.Predicate,java.util.stream.Collector)">partitioningBy</h3> <pre data-language="java">public static &lt;T,D,​A&gt; Collector&lt;T,​?,​Map&lt;Boolean,​D&gt;&gt; partitioningBy​(Predicate&lt;? super T&gt; predicate,
                                                                                                 Collector&lt;? super T,​A,​D&gt; downstream)</pre> <div>
<p>Returns a <code>Collector</code> which partitions the input elements according to a <code>Predicate</code>, reduces the values in each partition according to another <code>Collector</code>, and organizes them into a <code>Map&lt;Boolean, D&gt;</code> whose values are the result of the downstream reduction. </p>
<p> The returned <code>Map</code> always contains mappings for both <code>false</code> and <code>true</code> keys. There are no guarantees on the type, mutability, serializability, or thread-safety of the <code>Map</code> returned.</p>
</div> <dl> <dt>API Note:</dt> <dd>If a partition has no elements, its value in the result Map will be obtained by calling the downstream collector's supplier function and then applying the finisher function.</dd> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the type of the input elements</dd> <dd>
<code>A</code> - the intermediate accumulation type of the downstream collector</dd> <dd>
<code>D</code> - the result type of the downstream reduction</dd> <dt>Parameters:</dt> <dd>
<code>predicate</code> - a predicate used for classifying input elements</dd> <dd>
<code>downstream</code> - a <code>Collector</code> implementing the downstream reduction</dd> <dt>Returns:</dt> <dd>a <code>Collector</code> implementing the cascaded partitioning operation</dd> <dt>See Also:</dt> <dd><a href="#partitioningBy(java.util.function.Predicate)"><code>partitioningBy(Predicate)</code></a></dd> </dl>    <h3 id="toMap(java.util.function.Function,java.util.function.Function)">toMap</h3> <pre data-language="java">public static &lt;T,K,​U&gt; Collector&lt;T,​?,​Map&lt;K,​U&gt;&gt; toMap​(Function&lt;? super T,​? extends K&gt; keyMapper,
                                                                                  Function&lt;? super T,​? extends U&gt; valueMapper)</pre> <div>
<p>Returns a <code>Collector</code> that accumulates elements into a <code>Map</code> whose keys and values are the result of applying the provided mapping functions to the input elements. </p>
<p>If the mapped keys contain duplicates (according to <a href="../../lang/object#equals(java.lang.Object)"><code>Object.equals(Object)</code></a>), an <code>IllegalStateException</code> is thrown when the collection operation is performed. If the mapped keys might have duplicates, use <a href="#toMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator)"><code>toMap(Function, Function, BinaryOperator)</code></a> instead. </p>
<p>There are no guarantees on the type, mutability, serializability, or thread-safety of the <code>Map</code> returned.</p>
</div> <dl> <dt>API Note:</dt> <dd>It is common for either the key or the value to be the input elements. In this case, the utility method <a href="../function/function#identity()"><code>Function.identity()</code></a> may be helpful. For example, the following produces a <code>Map</code> mapping students to their grade point average: <pre data-language="java">Map&lt;Student, Double&gt; studentToGPA
   = students.stream().collect(
     toMap(Function.identity(),
           student -&gt; computeGPA(student)));</pre> And the following produces a <code>Map</code> mapping a unique identifier to students: <pre data-language="java">Map&lt;String, Student&gt; studentIdToStudent
   = students.stream().collect(
     toMap(Student::getId,
           Function.identity()));</pre>
</dd> <dt>Implementation Note:</dt> <dd>The returned <code>Collector</code> is not concurrent. For parallel stream pipelines, the <code>combiner</code> function operates by merging the keys from one map into another, which can be an expensive operation. If it is not required that results are inserted into the <code>Map</code> in encounter order, using <a href="#toConcurrentMap(java.util.function.Function,java.util.function.Function)"><code>toConcurrentMap(Function, Function)</code></a> may offer better parallel performance.</dd> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the type of the input elements</dd> <dd>
<code>K</code> - the output type of the key mapping function</dd> <dd>
<code>U</code> - the output type of the value mapping function</dd> <dt>Parameters:</dt> <dd>
<code>keyMapper</code> - a mapping function to produce keys</dd> <dd>
<code>valueMapper</code> - a mapping function to produce values</dd> <dt>Returns:</dt> <dd>a <code>Collector</code> which collects elements into a <code>Map</code> whose keys and values are the result of applying mapping functions to the input elements</dd> <dt>See Also:</dt> <dd>
<a href="#toMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator)"><code>toMap(Function, Function, BinaryOperator)</code></a>, <a href="#toMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator,java.util.function.Supplier)"><code>toMap(Function, Function, BinaryOperator, Supplier)</code></a>, <a href="#toConcurrentMap(java.util.function.Function,java.util.function.Function)"><code>toConcurrentMap(Function, Function)</code></a>
</dd> </dl>    <h3 id="toUnmodifiableMap(java.util.function.Function,java.util.function.Function)">toUnmodifiableMap</h3> <pre data-language="java">public static &lt;T,K,​U&gt; Collector&lt;T,​?,​Map&lt;K,​U&gt;&gt; toUnmodifiableMap​(Function&lt;? super T,​? extends K&gt; keyMapper,
                                                                                              Function&lt;? super T,​? extends U&gt; valueMapper)</pre> <div>
<p>Returns a <code>Collector</code> that accumulates the input elements into an <a href="../map#unmodifiable">unmodifiable Map</a>, whose keys and values are the result of applying the provided mapping functions to the input elements. </p>
<p>If the mapped keys contain duplicates (according to <a href="../../lang/object#equals(java.lang.Object)"><code>Object.equals(Object)</code></a>), an <code>IllegalStateException</code> is thrown when the collection operation is performed. If the mapped keys might have duplicates, use <a href="#toUnmodifiableMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator)"><code>toUnmodifiableMap(Function, Function, BinaryOperator)</code></a> to handle merging of the values. </p>
<p>The returned Collector disallows null keys and values. If either mapping function returns null, <code>NullPointerException</code> will be thrown.</p>
</div> <dl> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the type of the input elements</dd> <dd>
<code>K</code> - the output type of the key mapping function</dd> <dd>
<code>U</code> - the output type of the value mapping function</dd> <dt>Parameters:</dt> <dd>
<code>keyMapper</code> - a mapping function to produce keys, must be non-null</dd> <dd>
<code>valueMapper</code> - a mapping function to produce values, must be non-null</dd> <dt>Returns:</dt> <dd>a <code>Collector</code> that accumulates the input elements into an <a href="../map#unmodifiable">unmodifiable Map</a>, whose keys and values are the result of applying the provided mapping functions to the input elements</dd> <dt>Throws:</dt> <dd>
<code><a href="../../lang/nullpointerexception">NullPointerException</a></code> - if either keyMapper or valueMapper is null</dd> <dt>Since:</dt> <dd>10</dd> <dt>See Also:</dt> <dd><a href="#toUnmodifiableMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator)"><code>toUnmodifiableMap(Function, Function, BinaryOperator)</code></a></dd> </dl>    <h3 id="toMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator)">toMap</h3> <pre data-language="java">public static &lt;T,K,​U&gt; Collector&lt;T,​?,​Map&lt;K,​U&gt;&gt; toMap​(Function&lt;? super T,​? extends K&gt; keyMapper,
                                                                                  Function&lt;? super T,​? extends U&gt; valueMapper,
                                                                                  BinaryOperator&lt;U&gt; mergeFunction)</pre> <div>
<p>Returns a <code>Collector</code> that accumulates elements into a <code>Map</code> whose keys and values are the result of applying the provided mapping functions to the input elements. </p>
<p>If the mapped keys contain duplicates (according to <a href="../../lang/object#equals(java.lang.Object)"><code>Object.equals(Object)</code></a>), the value mapping function is applied to each equal element, and the results are merged using the provided merging function. </p>
<p>There are no guarantees on the type, mutability, serializability, or thread-safety of the <code>Map</code> returned.</p>
</div> <dl> <dt>API Note:</dt> <dd>There are multiple ways to deal with collisions between multiple elements mapping to the same key. The other forms of <code>toMap</code> simply use a merge function that throws unconditionally, but you can easily write more flexible merge policies. For example, if you have a stream of <code>Person</code>, and you want to produce a "phone book" mapping name to address, but it is possible that two persons have the same name, you can do as follows to gracefully deal with these collisions, and produce a <code>Map</code> mapping names to a concatenated list of addresses: <pre data-language="java">Map&lt;String, String&gt; phoneBook
   = people.stream().collect(
     toMap(Person::getName,
           Person::getAddress,
           (s, a) -&gt; s + ", " + a));</pre>
</dd> <dt>Implementation Note:</dt> <dd>The returned <code>Collector</code> is not concurrent. For parallel stream pipelines, the <code>combiner</code> function operates by merging the keys from one map into another, which can be an expensive operation. If it is not required that results are merged into the <code>Map</code> in encounter order, using <a href="#toConcurrentMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator)"><code>toConcurrentMap(Function, Function, BinaryOperator)</code></a> may offer better parallel performance.</dd> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the type of the input elements</dd> <dd>
<code>K</code> - the output type of the key mapping function</dd> <dd>
<code>U</code> - the output type of the value mapping function</dd> <dt>Parameters:</dt> <dd>
<code>keyMapper</code> - a mapping function to produce keys</dd> <dd>
<code>valueMapper</code> - a mapping function to produce values</dd> <dd>
<code>mergeFunction</code> - a merge function, used to resolve collisions between values associated with the same key, as supplied to <a href="../map#merge(K,V,java.util.function.BiFunction)"><code>Map.merge(Object, Object, BiFunction)</code></a>
</dd> <dt>Returns:</dt> <dd>a <code>Collector</code> which collects elements into a <code>Map</code> whose keys are the result of applying a key mapping function to the input elements, and whose values are the result of applying a value mapping function to all input elements equal to the key and combining them using the merge function</dd> <dt>See Also:</dt> <dd>
<a href="#toMap(java.util.function.Function,java.util.function.Function)"><code>toMap(Function, Function)</code></a>, <a href="#toMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator,java.util.function.Supplier)"><code>toMap(Function, Function, BinaryOperator, Supplier)</code></a>, <a href="#toConcurrentMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator)"><code>toConcurrentMap(Function, Function, BinaryOperator)</code></a>
</dd> </dl>    <h3 id="toUnmodifiableMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator)">toUnmodifiableMap</h3> <pre data-language="java">public static &lt;T,K,​U&gt; Collector&lt;T,​?,​Map&lt;K,​U&gt;&gt; toUnmodifiableMap​(Function&lt;? super T,​? extends K&gt; keyMapper,
                                                                                              Function&lt;? super T,​? extends U&gt; valueMapper,
                                                                                              BinaryOperator&lt;U&gt; mergeFunction)</pre> <div>
<p>Returns a <code>Collector</code> that accumulates the input elements into an <a href="../map#unmodifiable">unmodifiable Map</a>, whose keys and values are the result of applying the provided mapping functions to the input elements. </p>
<p>If the mapped keys contain duplicates (according to <a href="../../lang/object#equals(java.lang.Object)"><code>Object.equals(Object)</code></a>), the value mapping function is applied to each equal element, and the results are merged using the provided merging function. </p>
<p>The returned Collector disallows null keys and values. If either mapping function returns null, <code>NullPointerException</code> will be thrown.</p>
</div> <dl> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the type of the input elements</dd> <dd>
<code>K</code> - the output type of the key mapping function</dd> <dd>
<code>U</code> - the output type of the value mapping function</dd> <dt>Parameters:</dt> <dd>
<code>keyMapper</code> - a mapping function to produce keys, must be non-null</dd> <dd>
<code>valueMapper</code> - a mapping function to produce values, must be non-null</dd> <dd>
<code>mergeFunction</code> - a merge function, used to resolve collisions between values associated with the same key, as supplied to <a href="../map#merge(K,V,java.util.function.BiFunction)"><code>Map.merge(Object, Object, BiFunction)</code></a>, must be non-null</dd> <dt>Returns:</dt> <dd>a <code>Collector</code> that accumulates the input elements into an <a href="../map#unmodifiable">unmodifiable Map</a>, whose keys and values are the result of applying the provided mapping functions to the input elements</dd> <dt>Throws:</dt> <dd>
<code><a href="../../lang/nullpointerexception">NullPointerException</a></code> - if the keyMapper, valueMapper, or mergeFunction is null</dd> <dt>Since:</dt> <dd>10</dd> <dt>See Also:</dt> <dd><a href="#toUnmodifiableMap(java.util.function.Function,java.util.function.Function)"><code>toUnmodifiableMap(Function, Function)</code></a></dd> </dl>    <h3 id="toMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator,java.util.function.Supplier)">toMap</h3> <pre data-language="java">public static &lt;T,K,​U,​M extends Map&lt;K,​U&gt;&gt; Collector&lt;T,​?,​M&gt; toMap​(Function&lt;? super T,​? extends K&gt; keyMapper,
                                                                                                    Function&lt;? super T,​? extends U&gt; valueMapper,
                                                                                                    BinaryOperator&lt;U&gt; mergeFunction,
                                                                                                    Supplier&lt;M&gt; mapFactory)</pre> <div>
<p>Returns a <code>Collector</code> that accumulates elements into a <code>Map</code> whose keys and values are the result of applying the provided mapping functions to the input elements. </p>
<p>If the mapped keys contain duplicates (according to <a href="../../lang/object#equals(java.lang.Object)"><code>Object.equals(Object)</code></a>), the value mapping function is applied to each equal element, and the results are merged using the provided merging function. The <code>Map</code> is created by a provided supplier function.</p>
</div> <dl> <dt>Implementation Note:</dt> <dd>The returned <code>Collector</code> is not concurrent. For parallel stream pipelines, the <code>combiner</code> function operates by merging the keys from one map into another, which can be an expensive operation. If it is not required that results are merged into the <code>Map</code> in encounter order, using <a href="#toConcurrentMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator,java.util.function.Supplier)"><code>toConcurrentMap(Function, Function, BinaryOperator, Supplier)</code></a> may offer better parallel performance.</dd> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the type of the input elements</dd> <dd>
<code>K</code> - the output type of the key mapping function</dd> <dd>
<code>U</code> - the output type of the value mapping function</dd> <dd>
<code>M</code> - the type of the resulting <code>Map</code>
</dd> <dt>Parameters:</dt> <dd>
<code>keyMapper</code> - a mapping function to produce keys</dd> <dd>
<code>valueMapper</code> - a mapping function to produce values</dd> <dd>
<code>mergeFunction</code> - a merge function, used to resolve collisions between values associated with the same key, as supplied to <a href="../map#merge(K,V,java.util.function.BiFunction)"><code>Map.merge(Object, Object, BiFunction)</code></a>
</dd> <dd>
<code>mapFactory</code> - a supplier providing a new empty <code>Map</code> into which the results will be inserted</dd> <dt>Returns:</dt> <dd>a <code>Collector</code> which collects elements into a <code>Map</code> whose keys are the result of applying a key mapping function to the input elements, and whose values are the result of applying a value mapping function to all input elements equal to the key and combining them using the merge function</dd> <dt>See Also:</dt> <dd>
<a href="#toMap(java.util.function.Function,java.util.function.Function)"><code>toMap(Function, Function)</code></a>, <a href="#toMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator)"><code>toMap(Function, Function, BinaryOperator)</code></a>, <a href="#toConcurrentMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator,java.util.function.Supplier)"><code>toConcurrentMap(Function, Function, BinaryOperator, Supplier)</code></a>
</dd> </dl>    <h3 id="toConcurrentMap(java.util.function.Function,java.util.function.Function)">toConcurrentMap</h3> <pre data-language="java">public static &lt;T,K,​U&gt; Collector&lt;T,​?,​ConcurrentMap&lt;K,​U&gt;&gt; toConcurrentMap​(Function&lt;? super T,​? extends K&gt; keyMapper,
                                                                                                      Function&lt;? super T,​? extends U&gt; valueMapper)</pre> <div>
<p>Returns a concurrent <code>Collector</code> that accumulates elements into a <code>ConcurrentMap</code> whose keys and values are the result of applying the provided mapping functions to the input elements. </p>
<p>If the mapped keys contain duplicates (according to <a href="../../lang/object#equals(java.lang.Object)"><code>Object.equals(Object)</code></a>), an <code>IllegalStateException</code> is thrown when the collection operation is performed. If the mapped keys may have duplicates, use <a href="#toConcurrentMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator)"><code>toConcurrentMap(Function, Function, BinaryOperator)</code></a> instead. </p>
<p>There are no guarantees on the type, mutability, or serializability of the <code>ConcurrentMap</code> returned.</p>
</div> <dl> <dt>API Note:</dt> <dd>It is common for either the key or the value to be the input elements. In this case, the utility method <a href="../function/function#identity()"><code>Function.identity()</code></a> may be helpful. For example, the following produces a <code>ConcurrentMap</code> mapping students to their grade point average: <pre data-language="java">ConcurrentMap&lt;Student, Double&gt; studentToGPA
   = students.stream().collect(
     toConcurrentMap(Function.identity(),
                     student -&gt; computeGPA(student)));</pre> And the following produces a <code>ConcurrentMap</code> mapping a unique identifier to students: <pre data-language="java">ConcurrentMap&lt;String, Student&gt; studentIdToStudent
   = students.stream().collect(
     toConcurrentMap(Student::getId,
                     Function.identity()));</pre> <p>This is a <a href="collector.characteristics#CONCURRENT"><code>concurrent</code></a> and <a href="collector.characteristics#UNORDERED"><code>unordered</code></a> Collector.</p>
</dd> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the type of the input elements</dd> <dd>
<code>K</code> - the output type of the key mapping function</dd> <dd>
<code>U</code> - the output type of the value mapping function</dd> <dt>Parameters:</dt> <dd>
<code>keyMapper</code> - the mapping function to produce keys</dd> <dd>
<code>valueMapper</code> - the mapping function to produce values</dd> <dt>Returns:</dt> <dd>a concurrent, unordered <code>Collector</code> which collects elements into a <code>ConcurrentMap</code> whose keys are the result of applying a key mapping function to the input elements, and whose values are the result of applying a value mapping function to the input elements</dd> <dt>See Also:</dt> <dd>
<a href="#toMap(java.util.function.Function,java.util.function.Function)"><code>toMap(Function, Function)</code></a>, <a href="#toConcurrentMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator)"><code>toConcurrentMap(Function, Function, BinaryOperator)</code></a>, <a href="#toConcurrentMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator,java.util.function.Supplier)"><code>toConcurrentMap(Function, Function, BinaryOperator, Supplier)</code></a>
</dd> </dl>    <h3 id="toConcurrentMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator)">toConcurrentMap</h3> <pre data-language="java">public static &lt;T,K,​U&gt; Collector&lt;T,​?,​ConcurrentMap&lt;K,​U&gt;&gt; toConcurrentMap​(Function&lt;? super T,​? extends K&gt; keyMapper,
                                                                                                      Function&lt;? super T,​? extends U&gt; valueMapper,
                                                                                                      BinaryOperator&lt;U&gt; mergeFunction)</pre> <div>
<p>Returns a concurrent <code>Collector</code> that accumulates elements into a <code>ConcurrentMap</code> whose keys and values are the result of applying the provided mapping functions to the input elements. </p>
<p>If the mapped keys contain duplicates (according to <a href="../../lang/object#equals(java.lang.Object)"><code>Object.equals(Object)</code></a>), the value mapping function is applied to each equal element, and the results are merged using the provided merging function. </p>
<p>There are no guarantees on the type, mutability, or serializability of the <code>ConcurrentMap</code> returned.</p>
</div> <dl> <dt>API Note:</dt> <dd>There are multiple ways to deal with collisions between multiple elements mapping to the same key. The other forms of <code>toConcurrentMap</code> simply use a merge function that throws unconditionally, but you can easily write more flexible merge policies. For example, if you have a stream of <code>Person</code>, and you want to produce a "phone book" mapping name to address, but it is possible that two persons have the same name, you can do as follows to gracefully deal with these collisions, and produce a <code>ConcurrentMap</code> mapping names to a concatenated list of addresses: <pre data-language="java">ConcurrentMap&lt;String, String&gt; phoneBook
   = people.stream().collect(
     toConcurrentMap(Person::getName,
                     Person::getAddress,
                     (s, a) -&gt; s + ", " + a));</pre> <p>This is a <a href="collector.characteristics#CONCURRENT"><code>concurrent</code></a> and <a href="collector.characteristics#UNORDERED"><code>unordered</code></a> Collector.</p>
</dd> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the type of the input elements</dd> <dd>
<code>K</code> - the output type of the key mapping function</dd> <dd>
<code>U</code> - the output type of the value mapping function</dd> <dt>Parameters:</dt> <dd>
<code>keyMapper</code> - a mapping function to produce keys</dd> <dd>
<code>valueMapper</code> - a mapping function to produce values</dd> <dd>
<code>mergeFunction</code> - a merge function, used to resolve collisions between values associated with the same key, as supplied to <a href="../map#merge(K,V,java.util.function.BiFunction)"><code>Map.merge(Object, Object, BiFunction)</code></a>
</dd> <dt>Returns:</dt> <dd>a concurrent, unordered <code>Collector</code> which collects elements into a <code>ConcurrentMap</code> whose keys are the result of applying a key mapping function to the input elements, and whose values are the result of applying a value mapping function to all input elements equal to the key and combining them using the merge function</dd> <dt>See Also:</dt> <dd>
<a href="#toConcurrentMap(java.util.function.Function,java.util.function.Function)"><code>toConcurrentMap(Function, Function)</code></a>, <a href="#toConcurrentMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator,java.util.function.Supplier)"><code>toConcurrentMap(Function, Function, BinaryOperator, Supplier)</code></a>, <a href="#toMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator)"><code>toMap(Function, Function, BinaryOperator)</code></a>
</dd> </dl>    <h3 id="toConcurrentMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator,java.util.function.Supplier)">toConcurrentMap</h3> <pre data-language="java">public static &lt;T,K,​U,​M extends ConcurrentMap&lt;K,​U&gt;&gt; Collector&lt;T,​?,​M&gt; toConcurrentMap​(Function&lt;? super T,​? extends K&gt; keyMapper,
                                                                                                                        Function&lt;? super T,​? extends U&gt; valueMapper,
                                                                                                                        BinaryOperator&lt;U&gt; mergeFunction,
                                                                                                                        Supplier&lt;M&gt; mapFactory)</pre> <div>
<p>Returns a concurrent <code>Collector</code> that accumulates elements into a <code>ConcurrentMap</code> whose keys and values are the result of applying the provided mapping functions to the input elements. </p>
<p>If the mapped keys contain duplicates (according to <a href="../../lang/object#equals(java.lang.Object)"><code>Object.equals(Object)</code></a>), the value mapping function is applied to each equal element, and the results are merged using the provided merging function. The <code>ConcurrentMap</code> is created by a provided supplier function. </p>
<p>This is a <a href="collector.characteristics#CONCURRENT"><code>concurrent</code></a> and <a href="collector.characteristics#UNORDERED"><code>unordered</code></a> Collector.</p>
</div> <dl> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the type of the input elements</dd> <dd>
<code>K</code> - the output type of the key mapping function</dd> <dd>
<code>U</code> - the output type of the value mapping function</dd> <dd>
<code>M</code> - the type of the resulting <code>ConcurrentMap</code>
</dd> <dt>Parameters:</dt> <dd>
<code>keyMapper</code> - a mapping function to produce keys</dd> <dd>
<code>valueMapper</code> - a mapping function to produce values</dd> <dd>
<code>mergeFunction</code> - a merge function, used to resolve collisions between values associated with the same key, as supplied to <a href="../map#merge(K,V,java.util.function.BiFunction)"><code>Map.merge(Object, Object, BiFunction)</code></a>
</dd> <dd>
<code>mapFactory</code> - a supplier providing a new empty <code>ConcurrentMap</code> into which the results will be inserted</dd> <dt>Returns:</dt> <dd>a concurrent, unordered <code>Collector</code> which collects elements into a <code>ConcurrentMap</code> whose keys are the result of applying a key mapping function to the input elements, and whose values are the result of applying a value mapping function to all input elements equal to the key and combining them using the merge function</dd> <dt>See Also:</dt> <dd>
<a href="#toConcurrentMap(java.util.function.Function,java.util.function.Function)"><code>toConcurrentMap(Function, Function)</code></a>, <a href="#toConcurrentMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator)"><code>toConcurrentMap(Function, Function, BinaryOperator)</code></a>, <a href="#toMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator,java.util.function.Supplier)"><code>toMap(Function, Function, BinaryOperator, Supplier)</code></a>
</dd> </dl>    <h3 id="summarizingInt(java.util.function.ToIntFunction)">summarizingInt</h3> <pre data-language="java">public static &lt;T&gt; Collector&lt;T,?,​IntSummaryStatistics&gt; summarizingInt​(ToIntFunction&lt;? super T&gt; mapper)</pre> <p>Returns a <code>Collector</code> which applies an <code>int</code>-producing mapping function to each input element, and returns summary statistics for the resulting values.</p> <dl> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the type of the input elements</dd> <dt>Parameters:</dt> <dd>
<code>mapper</code> - a mapping function to apply to each element</dd> <dt>Returns:</dt> <dd>a <code>Collector</code> implementing the summary-statistics reduction</dd> <dt>See Also:</dt> <dd>
<a href="#summarizingDouble(java.util.function.ToDoubleFunction)"><code>summarizingDouble(ToDoubleFunction)</code></a>, <a href="#summarizingLong(java.util.function.ToLongFunction)"><code>summarizingLong(ToLongFunction)</code></a>
</dd> </dl>    <h3 id="summarizingLong(java.util.function.ToLongFunction)">summarizingLong</h3> <pre data-language="java">public static &lt;T&gt; Collector&lt;T,?,​LongSummaryStatistics&gt; summarizingLong​(ToLongFunction&lt;? super T&gt; mapper)</pre> <p>Returns a <code>Collector</code> which applies an <code>long</code>-producing mapping function to each input element, and returns summary statistics for the resulting values.</p> <dl> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the type of the input elements</dd> <dt>Parameters:</dt> <dd>
<code>mapper</code> - the mapping function to apply to each element</dd> <dt>Returns:</dt> <dd>a <code>Collector</code> implementing the summary-statistics reduction</dd> <dt>See Also:</dt> <dd>
<a href="#summarizingDouble(java.util.function.ToDoubleFunction)"><code>summarizingDouble(ToDoubleFunction)</code></a>, <a href="#summarizingInt(java.util.function.ToIntFunction)"><code>summarizingInt(ToIntFunction)</code></a>
</dd> </dl>    <h3 id="summarizingDouble(java.util.function.ToDoubleFunction)">summarizingDouble</h3> <pre data-language="java">public static &lt;T&gt; Collector&lt;T,?,​DoubleSummaryStatistics&gt; summarizingDouble​(ToDoubleFunction&lt;? super T&gt; mapper)</pre> <p>Returns a <code>Collector</code> which applies an <code>double</code>-producing mapping function to each input element, and returns summary statistics for the resulting values.</p> <dl> <dt>Type Parameters:</dt> <dd>
<code>T</code> - the type of the input elements</dd> <dt>Parameters:</dt> <dd>
<code>mapper</code> - a mapping function to apply to each element</dd> <dt>Returns:</dt> <dd>a <code>Collector</code> implementing the summary-statistics reduction</dd> <dt>See Also:</dt> <dd>
<a href="#summarizingLong(java.util.function.ToLongFunction)"><code>summarizingLong(ToLongFunction)</code></a>, <a href="#summarizingInt(java.util.function.ToIntFunction)"><code>summarizingInt(ToIntFunction)</code></a>
</dd> </dl>   </section>  </div>  </main>  <div class="_attribution">
  <p class="_attribution-p">
    &copy; 1993, 2020, Oracle and/or its affiliates. All rights reserved.<br>Documentation extracted from Debian's OpenJDK Development Kit package.<br>Licensed under the GNU General Public License, version 2, with the Classpath Exception.<br>Various third party code in OpenJDK is licensed under different licenses (see Debian package).<br>Java and OpenJDK are trademarks or registered trademarks of Oracle and/or its affiliates.<br>
    <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/stream/Collectors.html" class="_attribution-link">https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/stream/Collectors.html</a>
  </p>
</div>
