  <main role="main">    <h1>Class System.LoggerFinder</h1>   <ul class="inheritance"> <li><a href="object">java.lang.Object</a></li> <li> <ul class="inheritance"> <li>java.lang.System.LoggerFinder</li> </ul> </li> </ul>   <dl> <dt>Enclosing class:</dt> <dd><a href="system">System</a></dd> </dl>  <pre data-language="java">public abstract static class System.LoggerFinder
extends Object</pre> <div>
<p>The <code>LoggerFinder</code> service is responsible for creating, managing, and configuring loggers to the underlying framework it uses. A logger finder is a concrete implementation of this class that has a zero-argument constructor and implements the abstract methods defined by this class. The loggers returned from a logger finder are capable of routing log messages to the logging backend this provider supports. A given invocation of the Java Runtime maintains a single system-wide LoggerFinder instance that is loaded as follows: <ul> <li>First it finds any custom <code>LoggerFinder</code> provider using the <a href="../util/serviceloader"><code>ServiceLoader</code></a> facility with the <a href="classloader#getSystemClassLoader()">system class loader</a>.</li> <li>If no <code>LoggerFinder</code> provider is found, the system default <code>LoggerFinder</code> implementation will be used.</li> </ul> </p>
<p> An application can replace the logging backend <i>even when the java.logging module is present</i>, by simply providing and declaring an implementation of the <a href="system.loggerfinder"><code>System.LoggerFinder</code></a> service. </p>
<p> <b>Default Implementation</b> </p>
<p> The system default <code>LoggerFinder</code> implementation uses <code>java.util.logging</code> as the backend framework when the <code>java.logging</code> module is present. It returns a <a href="system.logger">logger</a> instance that will route log messages to a <a href="../../../java.logging/java/util/logging/logger"><code>java.util.logging.Logger</code></a>. Otherwise, if <code>java.logging</code> is not present, the default implementation will return a simple logger instance that will route log messages of <code>INFO</code> level and above to the console (<code>System.err</code>). </p>
<p> <b>Logging Configuration</b> </p>
<p> <a href="system.logger">Logger</a> instances obtained from the <code>LoggerFinder</code> factory methods are not directly configurable by the application. Configuration is the responsibility of the underlying logging backend, and usually requires using APIs specific to that backend. </p>
<p>For the default <code>LoggerFinder</code> implementation using <code>java.util.logging</code> as its backend, refer to <a href="../../../java.logging/java/util/logging/package-summary"><code>java.util.logging</code></a> for logging configuration. For the default <code>LoggerFinder</code> implementation returning simple loggers when the <code>java.logging</code> module is absent, the configuration is implementation dependent. </p>
<p> Usually an application that uses a logging framework will log messages through a logger facade defined (or supported) by that framework. Applications that wish to use an external framework should log through the facade associated with that framework. </p>
<p> A system class that needs to log messages will typically obtain a <a href="system.logger"><code>System.Logger</code></a> instance to route messages to the logging framework selected by the application. </p>
<p> Libraries and classes that only need loggers to produce log messages should not attempt to configure loggers by themselves, as that would make them dependent from a specific implementation of the <code>LoggerFinder</code> service. </p>
<p> In addition, when a security manager is present, loggers provided to system classes should not be directly configurable through the logging backend without requiring permissions. <br> It is the responsibility of the provider of the concrete <code>LoggerFinder</code> implementation to ensure that these loggers are not configured by untrusted code without proper permission checks, as configuration performed on such loggers usually affects all applications in the same Java Runtime. </p>
<p> <b>Message Levels and Mapping to backend levels</b> </p>
<p> A logger finder is responsible for mapping from a <code>
 System.Logger.Level</code> to a level supported by the logging backend it uses. <br>The default LoggerFinder using <code>java.util.logging</code> as the backend maps <code>System.Logger</code> levels to <a href="../../../java.logging/java/util/logging/level">java.util.logging</a> levels of corresponding severity - as described in <a href="system.logger.level"><code>Logger.Level</code></a>.</p>
</div> <dl> <dt>Since:</dt> <dd>9</dd> <dt>See Also:</dt> <dd>
<a href="system"><code>System</code></a>, <a href="system.logger"><code>System.Logger</code></a>
</dd> </dl>      <section role="region">  <h2 id="constructor.summary">Constructors</h2> <table>  <tr> <th scope="col">Modifier</th> <th scope="col">Constructor</th> <th scope="col">Description</th> </tr> <tr> <td><code>protected </code></td> <th scope="row"><code><a href="#%3Cinit%3E()">LoggerFinder</a>()</code></th> <td> <p>Creates a new instance of <code>LoggerFinder</code>.</p> </td> </tr> </table>  </section>  <section role="region">  <h2 id="method.summary">Methods</h2> <table>  <tr> <th scope="col">Modifier and Type</th> <th scope="col">Method</th> <th scope="col">Description</th> </tr> <tr id="i0"> <td><code><a href="system.logger">System.Logger</a></code></td> <th scope="row"><code><a href="#getLocalizedLogger(java.lang.String,java.util.ResourceBundle,java.lang.Module)">getLocalizedLogger</a>​(<a href="string">String</a> name,
                  <a href="../util/resourcebundle">ResourceBundle</a> bundle,
                  <a href="module">Module</a> module)</code></th> <td> <p>Returns a localizable instance of <a href="system.logger"><code>Logger</code></a> for the given <code>module</code>.</p> </td> </tr> <tr id="i1"> <td><code>abstract <a href="system.logger">System.Logger</a></code></td> <th scope="row"><code><a href="#getLogger(java.lang.String,java.lang.Module)">getLogger</a>​(<a href="string">String</a> name,
         <a href="module">Module</a> module)</code></th> <td> <p>Returns an instance of <a href="system.logger"><code>Logger</code></a> for the given <code>module</code>.</p> </td> </tr> <tr id="i2"> <td><code>static <a href="system.loggerfinder">System.LoggerFinder</a></code></td> <th scope="row"><code><a href="#getLoggerFinder()">getLoggerFinder</a>()</code></th> <td> <p>Returns the <code>LoggerFinder</code> instance.</p> </td> </tr> </table>  <h2 id="methods.inherited.from.class.java.lang.Object">Methods declared in class java.lang.<a href="object">Object</a>
</h2> <code><a href="object#clone()">clone</a>, <a href="object#equals(java.lang.Object)">equals</a>, <a href="object#finalize()">finalize</a>, <a href="object#getClass()">getClass</a>, <a href="object#hashCode()">hashCode</a>, <a href="object#notify()">notify</a>, <a href="object#notifyAll()">notifyAll</a>, <a href="object#toString()">toString</a>, <a href="object#wait()">wait</a>, <a href="object#wait(long)">wait</a>, <a href="object#wait(long,int)">wait</a></code>  </section>   <div>   <section role="region">  <h2 id="constructor.detail">Constructors</h2>   <h3 id="&lt;init&gt;()">LoggerFinder</h3> <pre data-language="java">protected LoggerFinder()</pre> <p>Creates a new instance of <code>LoggerFinder</code>.</p> <dl> <dt>Implementation Note:</dt> <dd>It is recommended that a <code>LoggerFinder</code> service implementation does not perform any heavy initialization in its constructor, in order to avoid possible risks of deadlock or class loading cycles during the instantiation of the service provider.</dd> <dt>Throws:</dt> <dd>
<code><a href="securityexception">SecurityException</a></code> - if a security manager is present and its <code>checkPermission</code> method doesn't allow the <code>RuntimePermission("loggerFinder")</code>.</dd> </dl>   </section>  <section role="region">  <h2 id="method.detail">Methods</h2>   <h3 id="getLogger(java.lang.String,java.lang.Module)">getLogger</h3> <pre data-language="java">public abstract System.Logger getLogger(String name,
                                        Module module)</pre> <p>Returns an instance of <a href="system.logger"><code>Logger</code></a> for the given <code>module</code>.</p> <dl> <dt>Parameters:</dt> <dd>
<code>name</code> - the name of the logger.</dd> <dd>
<code>module</code> - the module for which the logger is being requested.</dd> <dt>Returns:</dt> <dd>a <a href="system.logger"><code>logger</code></a> suitable for use within the given module.</dd> <dt>Throws:</dt> <dd>
<code><a href="nullpointerexception">NullPointerException</a></code> - if <code>name</code> is <code>null</code> or <code>module</code> is <code>null</code>.</dd> <dd>
<code><a href="securityexception">SecurityException</a></code> - if a security manager is present and its <code>checkPermission</code> method doesn't allow the <code>RuntimePermission("loggerFinder")</code>.</dd> </dl>    <h3 id="getLocalizedLogger(java.lang.String,java.util.ResourceBundle,java.lang.Module)">getLocalizedLogger</h3> <pre data-language="java">public System.Logger getLocalizedLogger(String name,
                                        ResourceBundle bundle,
                                        Module module)</pre> <p>Returns a localizable instance of <a href="system.logger"><code>Logger</code></a> for the given <code>module</code>. The returned logger will use the provided resource bundle for message localization.</p> <dl> <dt>Implementation Requirements:</dt> <dd>By default, this method calls <a href="#getLogger(java.lang.String,java.lang.Module)"><code>this.getLogger(name, module)</code></a> to obtain a logger, then wraps that logger in a <a href="system.logger"><code>System.Logger</code></a> instance where all methods that do not take a <a href="../util/resourcebundle"><code>ResourceBundle</code></a> as parameter are redirected to one which does - passing the given <code>bundle</code> for localization. So for instance, a call to <a href="system.logger#log(java.lang.System.Logger.Level,java.lang.String)"><code>Logger.log(Level.INFO, msg)</code></a> will end up as a call to <a href="system.logger#log(java.lang.System.Logger.Level,java.util.ResourceBundle,java.lang.String,java.lang.Object...)"><code>Logger.log(Level.INFO, bundle, msg, (Object[])null)</code></a> on the wrapped logger instance. Note however that by default, string messages returned by <a href="../util/function/supplier"><code>Supplier&lt;String&gt;</code></a> will not be localized, as it is assumed that such strings are messages which are already constructed, rather than keys in a resource bundle. <p> An implementation of <code>LoggerFinder</code> may override this method, for example, when the underlying logging backend provides its own mechanism for localizing log messages, then such a <code>LoggerFinder</code> would be free to return a logger that makes direct use of the mechanism provided by the backend.</p>
</dd> <dt>Parameters:</dt> <dd>
<code>name</code> - the name of the logger.</dd> <dd>
<code>bundle</code> - a resource bundle; can be <code>null</code>.</dd> <dd>
<code>module</code> - the module for which the logger is being requested.</dd> <dt>Returns:</dt> <dd>an instance of <a href="system.logger"><code>Logger</code></a> which will use the provided resource bundle for message localization.</dd> <dt>Throws:</dt> <dd>
<code><a href="nullpointerexception">NullPointerException</a></code> - if <code>name</code> is <code>null</code> or <code>module</code> is <code>null</code>.</dd> <dd>
<code><a href="securityexception">SecurityException</a></code> - if a security manager is present and its <code>checkPermission</code> method doesn't allow the <code>RuntimePermission("loggerFinder")</code>.</dd> </dl>    <h3 id="getLoggerFinder()">getLoggerFinder</h3> <pre data-language="java">public static System.LoggerFinder getLoggerFinder()</pre> <p>Returns the <code>LoggerFinder</code> instance. There is one single system-wide <code>LoggerFinder</code> instance in the Java Runtime. See the class specification of how the <a href="system.loggerfinder"><code>LoggerFinder</code></a> implementation is located and loaded.</p> <dl> <dt>Returns:</dt> <dd>the <a href="system.loggerfinder"><code>LoggerFinder</code></a> instance.</dd> <dt>Throws:</dt> <dd>
<code><a href="securityexception">SecurityException</a></code> - if a security manager is present and its <code>checkPermission</code> method doesn't allow the <code>RuntimePermission("loggerFinder")</code>.</dd> </dl>   </section>  </div>  </main>  <div class="_attribution">
  <p class="_attribution-p">
    &copy; 1993, 2020, Oracle and/or its affiliates. All rights reserved.<br>Documentation extracted from Debian's OpenJDK Development Kit package.<br>Licensed under the GNU General Public License, version 2, with the Classpath Exception.<br>Various third party code in OpenJDK is licensed under different licenses (see Debian package).<br>Java and OpenJDK are trademarks or registered trademarks of Oracle and/or its affiliates.<br>
    <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/System.LoggerFinder.html" class="_attribution-link">https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/System.LoggerFinder.html</a>
  </p>
</div>
