  <main role="main">    <h1>Class Configuration</h1>   <ul class="inheritance"> <li><a href="../object">java.lang.Object</a></li> <li> <ul class="inheritance"> <li>java.lang.module.Configuration</li> </ul> </li> </ul>    <pre data-language="java">public final class Configuration
extends Object</pre> <div>
<p>A configuration that is the result of <a href="package-summary#resolution"> resolution</a> or resolution with <a href="configuration#service-binding">service binding</a>. </p>
<p> A configuration encapsulates the <em>readability graph</em> that is the output of resolution. A readability graph is a directed graph whose vertices are of type <a href="resolvedmodule"><code>ResolvedModule</code></a> and the edges represent the readability amongst the modules. <code>Configuration</code> defines the <a href="#modules()"><code>modules()</code></a> method to get the set of resolved modules in the graph. <code>
 ResolvedModule</code> defines the <a href="resolvedmodule#reads()"><code>reads()</code></a> method to get the set of modules that a resolved module reads. The modules that are read may be in the same configuration or may be in <a href="#parents()"><code>parent</code></a> configurations. </p> <p> Configuration defines the <a href="#resolve(java.lang.module.ModuleFinder,java.util.List,java.lang.module.ModuleFinder,java.util.Collection)"><code>resolve</code></a> method to resolve a collection of root modules, and the <a href="#resolveAndBind(java.lang.module.ModuleFinder,java.util.List,java.lang.module.ModuleFinder,java.util.Collection)"><code>resolveAndBind</code></a> method to do resolution with service binding. There are instance and static variants of both methods. The instance methods create a configuration with the receiver as the parent configuration. The static methods are for more advanced cases where there can be more than one parent configuration. </p> <p> Each <a href="../modulelayer"><code>layer</code></a> of modules in the Java virtual machine is created from a configuration. The configuration for the <a href="../modulelayer#boot()"><code>boot</code></a> layer is obtained by invoking <code>
 ModuleLayer.boot().configuration()</code>. The configuration for the boot layer will often be the parent when creating new configurations. </p> <h2> Example </h2> <p> The following example uses the <a href="#resolve(java.lang.module.ModuleFinder,java.lang.module.ModuleFinder,java.util.Collection)"><code>resolve</code></a> method to resolve a module named <em>myapp</em> with the configuration for the boot layer as the parent configuration. It prints the name of each resolved module and the names of the modules that each module reads. </p> <pre data-language="java">ModuleFinder finder = ModuleFinder.of(dir1, dir2, dir3);

    Configuration parent = ModuleLayer.boot().configuration();

    Configuration cf = parent.resolve(finder, ModuleFinder.of(), Set.of("myapp"));
    cf.modules().forEach(m -&gt; {
        System.out.format("%s -&gt; %s%n",
            m.name(),
            m.reads().stream()
                .map(ResolvedModule::name)
                .collect(Collectors.joining(", ")));
    });</pre>
</div> <dl> <dt>Since:</dt> <dd>9</dd> <dt>See Also:</dt> <dd><a href="../modulelayer"><code>ModuleLayer</code></a></dd> </dl>      <section role="region">  <h2 id="method.summary">Methods</h2> <table>  <tr> <th scope="col">Modifier and Type</th> <th scope="col">Method</th> <th scope="col">Description</th> </tr> <tr id="i0"> <td><code>static <a href="configuration">Configuration</a></code></td> <th scope="row"><code><a href="#empty()">empty</a>()</code></th> <td> <p>Returns the <em>empty</em> configuration.</p> </td> </tr> <tr id="i1"> <td><code><a href="../../util/optional">Optional</a>&lt;<a href="resolvedmodule">ResolvedModule</a>&gt;</code></td> <th scope="row"><code><a href="#findModule(java.lang.String)">findModule</a>​(<a href="../string">String</a> name)</code></th> <td> <p>Finds a resolved module in this configuration, or if not in this configuration, the <a href="#parents()">parent</a> configurations.</p> </td> </tr> <tr id="i2"> <td><code><a href="../../util/set">Set</a>&lt;<a href="resolvedmodule">ResolvedModule</a>&gt;</code></td> <th scope="row"><code><a href="#modules()">modules</a>()</code></th> <td> <p>Returns an immutable set of the resolved modules in this configuration.</p> </td> </tr> <tr id="i3"> <td><code><a href="../../util/list">List</a>&lt;<a href="configuration">Configuration</a>&gt;</code></td> <th scope="row"><code><a href="#parents()">parents</a>()</code></th> <td> <p>Returns an unmodifiable list of this configuration's parents, in search order.</p> </td> </tr> <tr id="i4"> <td><code><a href="configuration">Configuration</a></code></td> <th scope="row"><code><a href="#resolve(java.lang.module.ModuleFinder,java.lang.module.ModuleFinder,java.util.Collection)">resolve</a>​(<a href="modulefinder">ModuleFinder</a> before,
       <a href="modulefinder">ModuleFinder</a> after,
       <a href="../../util/collection">Collection</a>&lt;<a href="../string">String</a>&gt; roots)</code></th> <td> <p>Resolves a collection of root modules, with this configuration as its parent, to create a new configuration.</p> </td> </tr> <tr id="i5"> <td><code>static <a href="configuration">Configuration</a></code></td> <th scope="row"><code><a href="#resolve(java.lang.module.ModuleFinder,java.util.List,java.lang.module.ModuleFinder,java.util.Collection)">resolve</a>​(<a href="modulefinder">ModuleFinder</a> before,
       <a href="../../util/list">List</a>&lt;<a href="configuration">Configuration</a>&gt; parents,
       <a href="modulefinder">ModuleFinder</a> after,
       <a href="../../util/collection">Collection</a>&lt;<a href="../string">String</a>&gt; roots)</code></th> <td> <p>Resolves a collection of root modules to create a configuration.</p> </td> </tr> <tr id="i6"> <td><code><a href="configuration">Configuration</a></code></td> <th scope="row"><code><a href="#resolveAndBind(java.lang.module.ModuleFinder,java.lang.module.ModuleFinder,java.util.Collection)">resolveAndBind</a>​(<a href="modulefinder">ModuleFinder</a> before,
              <a href="modulefinder">ModuleFinder</a> after,
              <a href="../../util/collection">Collection</a>&lt;<a href="../string">String</a>&gt; roots)</code></th> <td> <p>Resolves a collection of root modules, with service binding, and with this configuration as its parent, to create a new configuration.</p> </td> </tr> <tr id="i7"> <td><code>static <a href="configuration">Configuration</a></code></td> <th scope="row"><code><a href="#resolveAndBind(java.lang.module.ModuleFinder,java.util.List,java.lang.module.ModuleFinder,java.util.Collection)">resolveAndBind</a>​(<a href="modulefinder">ModuleFinder</a> before,
              <a href="../../util/list">List</a>&lt;<a href="configuration">Configuration</a>&gt; parents,
              <a href="modulefinder">ModuleFinder</a> after,
              <a href="../../util/collection">Collection</a>&lt;<a href="../string">String</a>&gt; roots)</code></th> <td> <p>Resolves a collection of root modules, with service binding, to create configuration.</p> </td> </tr> <tr id="i8"> <td><code><a href="../string">String</a></code></td> <th scope="row"><code><a href="#toString()">toString</a>()</code></th> <td> <p>Returns a string describing this configuration.</p> </td> </tr> </table>  <h2 id="methods.inherited.from.class.java.lang.Object">Methods declared in class java.lang.<a href="../object">Object</a>
</h2> <code><a href="../object#clone()">clone</a>, <a href="../object#equals(java.lang.Object)">equals</a>, <a href="../object#finalize()">finalize</a>, <a href="../object#getClass()">getClass</a>, <a href="../object#hashCode()">hashCode</a>, <a href="../object#notify()">notify</a>, <a href="../object#notifyAll()">notifyAll</a>, <a href="../object#wait()">wait</a>, <a href="../object#wait(long)">wait</a>, <a href="../object#wait(long,int)">wait</a></code>  </section>   <div>   <section role="region">  <h2 id="method.detail">Methods</h2>   <h3 id="resolve(java.lang.module.ModuleFinder,java.lang.module.ModuleFinder,java.util.Collection)">resolve</h3> <pre data-language="java">public Configuration resolve(ModuleFinder before,
                             ModuleFinder after,
                             Collection&lt;String&gt; roots)</pre> <p>Resolves a collection of root modules, with this configuration as its parent, to create a new configuration. This method works exactly as specified by the static <a href="#resolve(java.lang.module.ModuleFinder,java.util.List,java.lang.module.ModuleFinder,java.util.Collection)"><code>resolve</code></a> method when invoked with this configuration as the parent. In other words, if this configuration is <code>cf</code> then this method is equivalent to invoking: <pre data-language="java">Configuration.resolve(before, List.of(cf), after, roots);</pre></p> <dl> <dt>Parameters:</dt> <dd>
<code>before</code> - The <em>before</em> module finder to find modules</dd> <dd>
<code>after</code> - The <em>after</em> module finder to locate modules when not located by the <code>before</code> module finder or in parent configurations</dd> <dd>
<code>roots</code> - The possibly-empty collection of module names of the modules to resolve</dd> <dt>Returns:</dt> <dd>The configuration that is the result of resolving the given root modules</dd> <dt>Throws:</dt> <dd>
<code><a href="findexception">FindException</a></code> - If resolution fails for any of the observability-related reasons specified by the static <code>resolve</code> method</dd> <dd>
<code><a href="resolutionexception">ResolutionException</a></code> - If resolution fails any of the consistency checks specified by the static <code>resolve</code> method</dd> <dd>
<code><a href="../securityexception">SecurityException</a></code> - If locating a module is denied by the security manager</dd> </dl>    <h3 id="resolveAndBind(java.lang.module.ModuleFinder,java.lang.module.ModuleFinder,java.util.Collection)">resolveAndBind</h3> <pre data-language="java">public Configuration resolveAndBind(ModuleFinder before,
                                    ModuleFinder after,
                                    Collection&lt;String&gt; roots)</pre> <p>Resolves a collection of root modules, with service binding, and with this configuration as its parent, to create a new configuration. This method works exactly as specified by the static <a href="#resolveAndBind(java.lang.module.ModuleFinder,java.util.List,java.lang.module.ModuleFinder,java.util.Collection)"><code>resolveAndBind</code></a> method when invoked with this configuration as the parent. In other words, if this configuration is <code>cf</code> then this method is equivalent to invoking: <pre data-language="java">Configuration.resolveAndBind(before, List.of(cf), after, roots);</pre></p> <dl> <dt>Parameters:</dt> <dd>
<code>before</code> - The <em>before</em> module finder to find modules</dd> <dd>
<code>after</code> - The <em>after</em> module finder to locate modules when not located by the <code>before</code> module finder or in parent configurations</dd> <dd>
<code>roots</code> - The possibly-empty collection of module names of the modules to resolve</dd> <dt>Returns:</dt> <dd>The configuration that is the result of resolving, with service binding, the given root modules</dd> <dt>Throws:</dt> <dd>
<code><a href="findexception">FindException</a></code> - If resolution fails for any of the observability-related reasons specified by the static <code>resolve</code> method</dd> <dd>
<code><a href="resolutionexception">ResolutionException</a></code> - If resolution fails any of the consistency checks specified by the static <code>resolve</code> method</dd> <dd>
<code><a href="../securityexception">SecurityException</a></code> - If locating a module is denied by the security manager</dd> </dl>    <h3 id="resolve(java.lang.module.ModuleFinder,java.util.List,java.lang.module.ModuleFinder,java.util.Collection)">resolve</h3> <pre data-language="java">public static Configuration resolve(ModuleFinder before,
                                    List&lt;Configuration&gt; parents,
                                    ModuleFinder after,
                                    Collection&lt;String&gt; roots)</pre> <div>
<p>Resolves a collection of root modules to create a configuration. </p>
<p> Each root module is located using the given <code>before</code> module finder. If a module is not found then it is located in the parent configuration as if by invoking the <a href="#findModule(java.lang.String)"><code>findModule</code></a> method on each parent in iteration order. If not found then the module is located using the given <code>after</code> module finder. The same search order is used to locate transitive dependences. Root modules or dependences that are located in a parent configuration are resolved no further and are not included in the resulting configuration. </p> <p> When all modules have been enumerated then a readability graph is computed, and in conjunction with the module exports and service use, checked for consistency. </p> <p> Resolution may fail with <code>FindException</code> for the following <em>observability-related</em> reasons: </p> <ul> <li><p> A root module, or a direct or transitive dependency, is not found. </p></li> <li><p> An error occurs when attempting to find a module. Possible errors include I/O errors, errors detected parsing a module descriptor (<code>module-info.class</code>) or two versions of the same module are found in the same directory. </p></li> </ul> <p> Resolution may fail with <code>ResolutionException</code> if any of the following consistency checks fail: </p> <ul> <li><p> A cycle is detected, say where module <code>m1</code> requires module <code>m2</code> and <code>m2</code> requires <code>m1</code>. </p></li> <li><p> A module reads two or more modules with the same name. This includes the case where a module reads another with the same name as itself. </p></li> <li><p> Two or more modules in the configuration export the same package to a module that reads both. This includes the case where a module <code>M</code> containing package <code>p</code> reads another module that exports <code>p</code> to <code>M</code>. </p></li> <li><p> A module <code>M</code> declares that it "<code>uses p.S</code>" or "<code>provides p.S with ...</code>" but package <code>p</code> is neither in module <code>M</code> nor exported to <code>M</code> by any module that <code>M</code> reads. </p></li> </ul>
</div> <dl> <dt>Implementation Note:</dt> <dd>In the implementation then observability of modules may depend on referential integrity or other checks that ensure different builds of tightly coupled modules or modules for specific operating systems or architectures are not combined in the same configuration.</dd> <dt>Parameters:</dt> <dd>
<code>before</code> - The <em>before</em> module finder to find modules</dd> <dd>
<code>parents</code> - The list parent configurations in search order</dd> <dd>
<code>after</code> - The <em>after</em> module finder to locate modules when not located by the <code>before</code> module finder or in parent configurations</dd> <dd>
<code>roots</code> - The possibly-empty collection of module names of the modules to resolve</dd> <dt>Returns:</dt> <dd>The configuration that is the result of resolving the given root modules</dd> <dt>Throws:</dt> <dd>
<code><a href="findexception">FindException</a></code> - If resolution fails for any of observability-related reasons specified above</dd> <dd>
<code><a href="resolutionexception">ResolutionException</a></code> - If resolution fails for any of the consistency checks specified above</dd> <dd>
<code><a href="../illegalargumentexception">IllegalArgumentException</a></code> - If the list of parents is empty, or the list has two or more parents with modules for different target operating systems, architectures, or versions</dd> <dd>
<code><a href="../securityexception">SecurityException</a></code> - If locating a module is denied by the security manager</dd> </dl>    <h3 id="resolveAndBind(java.lang.module.ModuleFinder,java.util.List,java.lang.module.ModuleFinder,java.util.Collection)">resolveAndBind</h3> <pre data-language="java">public static Configuration resolveAndBind(ModuleFinder before,
                                           List&lt;Configuration&gt; parents,
                                           ModuleFinder after,
                                           Collection&lt;String&gt; roots)</pre> <div>
<p>Resolves a collection of root modules, with service binding, to create configuration. </p>
<p> This method works exactly as specified by <a href="#resolve(java.lang.module.ModuleFinder,java.util.List,java.lang.module.ModuleFinder,java.util.Collection)"><code>resolve</code></a> except that the graph of resolved modules is augmented with modules induced by the service-use dependence relation. </p> <p>More specifically, the root modules are resolved as if by calling <code id="service-binding">resolve</code>. The resolved modules, and all modules in the parent configurations, with <a href="moduledescriptor#uses()"><code>service dependences</code></a> are then examined. All modules found by the given module finders that <a href="moduledescriptor#provides()"><code>provide</code></a> an implementation of one or more of the service types are added to the module graph and then resolved as if by calling the <code>
 resolve</code> method. Adding modules to the module graph may introduce new service-use dependences and so the process works iteratively until no more modules are added. </p> <p> As service binding involves resolution then it may fail with <code>
 FindException</code> or <code>ResolutionException</code> for exactly the same reasons specified in <code>resolve</code>. </p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>before</code> - The <em>before</em> module finder to find modules</dd> <dd>
<code>parents</code> - The list parent configurations in search order</dd> <dd>
<code>after</code> - The <em>after</em> module finder to locate modules when not located by the <code>before</code> module finder or in parent configurations</dd> <dd>
<code>roots</code> - The possibly-empty collection of module names of the modules to resolve</dd> <dt>Returns:</dt> <dd>The configuration that is the result of resolving, with service binding, the given root modules</dd> <dt>Throws:</dt> <dd>
<code><a href="findexception">FindException</a></code> - If resolution fails for any of the observability-related reasons specified by the static <code>resolve</code> method</dd> <dd>
<code><a href="resolutionexception">ResolutionException</a></code> - If resolution fails any of the consistency checks specified by the static <code>resolve</code> method</dd> <dd>
<code><a href="../illegalargumentexception">IllegalArgumentException</a></code> - If the list of parents is empty, or the list has two or more parents with modules for different target operating systems, architectures, or versions</dd> <dd>
<code><a href="../securityexception">SecurityException</a></code> - If locating a module is denied by the security manager</dd> </dl>    <h3 id="empty()">empty</h3> <pre data-language="java">public static Configuration empty()</pre> <p>Returns the <em>empty</em> configuration. There are no modules in the empty configuration. It has no parents.</p> <dl> <dt>Returns:</dt> <dd>The empty configuration</dd> </dl>    <h3 id="parents()">parents</h3> <pre data-language="java">public List&lt;Configuration&gt; parents()</pre> <p>Returns an unmodifiable list of this configuration's parents, in search order. If this is the <a href="#empty()">empty configuration</a> then an empty list is returned.</p> <dl> <dt>Returns:</dt> <dd>A possibly-empty unmodifiable list of this parent configurations</dd> </dl>    <h3 id="modules()">modules</h3> <pre data-language="java">public Set&lt;ResolvedModule&gt; modules()</pre> <p>Returns an immutable set of the resolved modules in this configuration.</p> <dl> <dt>Returns:</dt> <dd>A possibly-empty unmodifiable set of the resolved modules in this configuration</dd> </dl>    <h3 id="findModule(java.lang.String)">findModule</h3> <pre data-language="java">public Optional&lt;ResolvedModule&gt; findModule(String name)</pre> <p>Finds a resolved module in this configuration, or if not in this configuration, the <a href="#parents()">parent</a> configurations. Finding a module in parent configurations is equivalent to invoking <code>findModule</code> on each parent, in search order, until the module is found or all parents have been searched. In a <em>tree of configurations</em> then this is equivalent to a depth-first search.</p> <dl> <dt>Parameters:</dt> <dd>
<code>name</code> - The module name of the resolved module to find</dd> <dt>Returns:</dt> <dd>The resolved module with the given name or an empty <code>
         Optional</code> if there isn't a module with this name in this configuration or any parent configurations</dd> </dl>    <h3 id="toString()">toString</h3> <pre data-language="java">public String toString()</pre> <p>Returns a string describing this configuration.</p> <dl> <dt>Overrides:</dt> <dd>
<code><a href="../object#toString()">toString</a></code> in class <code><a href="../object">Object</a></code>
</dd> <dt>Returns:</dt> <dd>A possibly empty string describing this configuration</dd> </dl>   </section>  </div>  </main>  <div class="_attribution">
  <p class="_attribution-p">
    &copy; 1993, 2020, Oracle and/or its affiliates. All rights reserved.<br>Documentation extracted from Debian's OpenJDK Development Kit package.<br>Licensed under the GNU General Public License, version 2, with the Classpath Exception.<br>Various third party code in OpenJDK is licensed under different licenses (see Debian package).<br>Java and OpenJDK are trademarks or registered trademarks of Oracle and/or its affiliates.<br>
    <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/module/Configuration.html" class="_attribution-link">https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/module/Configuration.html</a>
  </p>
</div>
