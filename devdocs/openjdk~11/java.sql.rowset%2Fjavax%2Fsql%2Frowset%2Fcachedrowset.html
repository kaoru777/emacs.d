  <main role="main">    <h1>Interface CachedRowSet</h1>     <dl> <dt>All Superinterfaces:</dt> <dd>
<code><a href="../../../../java.base/java/lang/autocloseable">AutoCloseable</a></code>, <code><a href="joinable">Joinable</a></code>, <code><a href="../../../../java.sql/java/sql/resultset">ResultSet</a></code>, <code><a href="../../../../java.sql/javax/sql/rowset">RowSet</a></code>, <code><a href="../../../../java.sql/java/sql/wrapper">Wrapper</a></code>
</dd> </dl> <dl> <dt>All Known Subinterfaces:</dt> <dd>
<code><a href="filteredrowset">FilteredRowSet</a></code>, <code><a href="joinrowset">JoinRowSet</a></code>, <code><a href="webrowset">WebRowSet</a></code>
</dd> </dl>  <pre data-language="java">public interface CachedRowSet
extends RowSet, Joinable</pre> <div>
<p>The interface that all standard implementations of <code>CachedRowSet</code> must implement. </p>
<p> The reference implementation of the <code>CachedRowSet</code> interface provided by Oracle Corporation is a standard implementation. Developers may use this implementation just as it is, they may extend it, or they may choose to write their own implementations of this interface. </p>
<p> A <code>CachedRowSet</code> object is a container for rows of data that caches its rows in memory, which makes it possible to operate without always being connected to its data source. Further, it is a JavaBeansâ„¢ component and is scrollable, updatable, and serializable. A <code>CachedRowSet</code> object typically contains rows from a result set, but it can also contain rows from any file with a tabular format, such as a spread sheet. The reference implementation supports getting data only from a <code>ResultSet</code> object, but developers can extend the <code>SyncProvider</code> implementations to provide access to other tabular data sources. </p>
<p> An application can modify the data in a <code>CachedRowSet</code> object, and those modifications can then be propagated back to the source of the data. </p>
<p> A <code>CachedRowSet</code> object is a <i>disconnected</i> rowset, which means that it makes use of a connection to its data source only briefly. It connects to its data source while it is reading data to populate itself with rows and again while it is propagating changes back to its underlying data source. The rest of the time, a <code>CachedRowSet</code> object is disconnected, including while its data is being modified. Being disconnected makes a <code>RowSet</code> object much leaner and therefore much easier to pass to another component. For example, a disconnected <code>RowSet</code> object can be serialized and passed over the wire to a thin client such as a personal digital assistant (PDA). </p>
<h2>1.0 Creating a <code>CachedRowSet</code> Object</h2> The following line of code uses the default constructor for <code>CachedRowSet</code> supplied in the reference implementation (RI) to create a default <code>CachedRowSet</code> object. <pre data-language="java">CachedRowSetImpl crs = new CachedRowSetImpl();</pre> This new <code>CachedRowSet</code> object will have its properties set to the default properties of a <code>BaseRowSet</code> object, and, in addition, it will have an <code>RIOptimisticProvider</code> object as its synchronization provider. <code>RIOptimisticProvider</code>, one of two <code>SyncProvider</code> implementations included in the RI, is the default provider that the <code>SyncFactory</code> singleton will supply when no synchronization provider is specified. <p> A <code>SyncProvider</code> object provides a <code>CachedRowSet</code> object with a reader (a <code>RowSetReader</code> object) for reading data from a data source to populate itself with data. A reader can be implemented to read data from a <code>ResultSet</code> object or from a file with a tabular format. A <code>SyncProvider</code> object also provides a writer (a <code>RowSetWriter</code> object) for synchronizing any modifications to the <code>CachedRowSet</code> object's data made while it was disconnected with the data in the underlying data source. </p>
<p> A writer can be implemented to exercise various degrees of care in checking for conflicts and in avoiding them. (A conflict occurs when a value in the data source has been changed after the rowset populated itself with that value.) The <code>RIOptimisticProvider</code> implementation assumes there will be few or no conflicts and therefore sets no locks. It updates the data source with values from the <code>CachedRowSet</code> object only if there are no conflicts. Other writers can be implemented so that they always write modified data to the data source, which can be accomplished either by not checking for conflicts or, on the other end of the spectrum, by setting locks sufficient to prevent data in the data source from being changed. Still other writer implementations can be somewhere in between. </p>
<p> A <code>CachedRowSet</code> object may use any <code>SyncProvider</code> implementation that has been registered with the <code>SyncFactory</code> singleton. An application can find out which <code>SyncProvider</code> implementations have been registered by calling the following line of code. </p>
<pre data-language="java">java.util.Enumeration providers = SyncFactory.getRegisteredProviders();</pre> <p> There are two ways for a <code>CachedRowSet</code> object to specify which <code>SyncProvider</code> object it will use. </p>
<ul> <li>Supplying the name of the implementation to the constructor<br> The following line of code creates the <code>CachedRowSet</code> object <i>crs2</i> that is initialized with default values except that its <code>SyncProvider</code> object is the one specified. <pre data-language="java">CachedRowSetImpl crs2 = new CachedRowSetImpl(
                                 "com.fred.providers.HighAvailabilityProvider");</pre> </li>
<li>Setting the <code>SyncProvider</code> using the <code>CachedRowSet</code> method <code>setSyncProvider</code><br> The following line of code resets the <code>SyncProvider</code> object for <i>crs</i>, the <code>CachedRowSet</code> object created with the default constructor. <pre data-language="java">crs.setSyncProvider("com.fred.providers.HighAvailabilityProvider");</pre> </li>
</ul> See the comments for <code>SyncFactory</code> and <code>SyncProvider</code> for more details. <h2>2.0 Retrieving Data from a <code>CachedRowSet</code> Object</h2> Data is retrieved from a <code>CachedRowSet</code> object by using the getter methods inherited from the <code>ResultSet</code> interface. The following examples, in which <code>crs</code> is a <code>CachedRowSet</code> object, demonstrate how to iterate through the rows, retrieving the column values in each row. The first example uses the version of the getter methods that take a column number; the second example uses the version that takes a column name. Column numbers are generally used when the <code>RowSet</code> object's command is of the form <code>SELECT * FROM TABLENAME</code>; column names are most commonly used when the command specifies columns by name. <pre data-language="java">while (crs.next()) {
        String name = crs.getString(1);
        int id = crs.getInt(2);
        Clob comment = crs.getClob(3);
        short dept = crs.getShort(4);
        System.out.println(name + "  " + id + "  " + comment + "  " + dept);
    }</pre> <pre data-language="java">while (crs.next()) {
        String name = crs.getString("NAME");
        int id = crs.getInt("ID");
        Clob comment = crs.getClob("COM");
        short dept = crs.getShort("DEPT");
        System.out.println(name + "  " + id + "  " + comment + "  " + dept);
    }</pre> <h3>2.1 Retrieving <code>RowSetMetaData</code>
</h3> An application can get information about the columns in a <code>CachedRowSet</code> object by calling <code>ResultSetMetaData</code> and <code>RowSetMetaData</code> methods on a <code>RowSetMetaData</code> object. The following code fragment, in which <i>crs</i> is a <code>CachedRowSet</code> object, illustrates the process. The first line creates a <code>RowSetMetaData</code> object with information about the columns in <i>crs</i>. The method <code>getMetaData</code>, inherited from the <code>ResultSet</code> interface, returns a <code>ResultSetMetaData</code> object, which is cast to a <code>RowSetMetaData</code> object before being assigned to the variable <i>rsmd</i>. The second line finds out how many columns <i>jrs</i> has, and the third line gets the JDBC type of values stored in the second column of <code>jrs</code>. <pre data-language="java">RowSetMetaData rsmd = (RowSetMetaData)crs.getMetaData();
     int count = rsmd.getColumnCount();
     int type = rsmd.getColumnType(2);</pre> The <code>RowSetMetaData</code> interface differs from the <code>ResultSetMetaData</code> interface in two ways. <ul> <li>
<i>It includes <code>setter</code> methods:</i> A <code>RowSet</code> object uses these methods internally when it is populated with data from a different <code>ResultSet</code> object. </li>
<li>
<i>It contains fewer <code>getter</code> methods:</i> Some <code>ResultSetMetaData</code> methods to not apply to a <code>RowSet</code> object. For example, methods retrieving whether a column value is writable or read only do not apply because all of a <code>RowSet</code> object's columns will be writable or read only, depending on whether the rowset is updatable or not. </li>
</ul> NOTE: In order to return a <code>RowSetMetaData</code> object, implementations must override the <code>getMetaData()</code> method defined in <code>java.sql.ResultSet</code> and return a <code>RowSetMetaData</code> object. <h2>3.0 Updating a <code>CachedRowSet</code> Object</h2> Updating a <code>CachedRowSet</code> object is similar to updating a <code>ResultSet</code> object, but because the rowset is not connected to its data source while it is being updated, it must take an additional step to effect changes in its underlying data source. After calling the method <code>updateRow</code> or <code>insertRow</code>, a <code>CachedRowSet</code> object must also call the method <code>acceptChanges</code> to have updates written to the data source. The following example, in which the cursor is on a row in the <code>CachedRowSet</code> object <i>crs</i>, shows the code required to update two column values in the current row and also update the <code>RowSet</code> object's underlying data source. <pre data-language="java">crs.updateShort(3, 58);
     crs.updateInt(4, 150000);
     crs.updateRow();
     crs.acceptChanges();</pre> <p> The next example demonstrates moving to the insert row, building a new row on the insert row, inserting it into the rowset, and then calling the method <code>acceptChanges</code> to add the new row to the underlying data source. Note that as with the getter methods, the updater methods may take either a column index or a column name to designate the column being acted upon. </p>
<pre data-language="java">crs.moveToInsertRow();
     crs.updateString("Name", "Shakespeare");
     crs.updateInt("ID", 10098347);
     crs.updateShort("Age", 58);
     crs.updateInt("Sal", 150000);
     crs.insertRow();
     crs.moveToCurrentRow();
     crs.acceptChanges();</pre> <p> NOTE: Where the <code>insertRow()</code> method inserts the contents of a <code>CachedRowSet</code> object's insert row is implementation-defined. The reference implementation for the <code>CachedRowSet</code> interface inserts a new row immediately following the current row, but it could be implemented to insert new rows in any number of other places. </p>
<p> Another thing to note about these examples is how they use the method <code>acceptChanges</code>. It is this method that propagates changes in a <code>CachedRowSet</code> object back to the underlying data source, calling on the <code>RowSet</code> object's writer internally to write changes to the data source. To do this, the writer has to incur the expense of establishing a connection with that data source. The preceding two code fragments call the method <code>acceptChanges</code> immediately after calling <code>updateRow</code> or <code>insertRow</code>. However, when there are multiple rows being changed, it is more efficient to call <code>acceptChanges</code> after all calls to <code>updateRow</code> and <code>insertRow</code> have been made. If <code>acceptChanges</code> is called only once, only one connection needs to be established. </p>
<h2>4.0 Updating the Underlying Data Source</h2> When the method <code>acceptChanges</code> is executed, the <code>CachedRowSet</code> object's writer, a <code>RowSetWriterImpl</code> object, is called behind the scenes to write the changes made to the rowset to the underlying data source. The writer is implemented to make a connection to the data source and write updates to it. <p> A writer is made available through an implementation of the <code>SyncProvider</code> interface, as discussed in section 1, "Creating a <code>CachedRowSet</code> Object." The default reference implementation provider, <code>RIOptimisticProvider</code>, has its writer implemented to use an optimistic concurrency control mechanism. That is, it maintains no locks in the underlying database while the rowset is disconnected from the database and simply checks to see if there are any conflicts before writing data to the data source. If there are any conflicts, it does not write anything to the data source. </p>
<p> The reader/writer facility provided by the <code>SyncProvider</code> class is pluggable, allowing for the customization of data retrieval and updating. If a different concurrency control mechanism is desired, a different implementation of <code>SyncProvider</code> can be plugged in using the method <code>setSyncProvider</code>. </p>
<p> In order to use the optimistic concurrency control routine, the <code>RIOptimisticProvider</code> maintains both its current value and its original value (the value it had immediately preceding the current value). Note that if no changes have been made to the data in a <code>RowSet</code> object, its current values and its original values are the same, both being the values with which the <code>RowSet</code> object was initially populated. However, once any values in the <code>RowSet</code> object have been changed, the current values and the original values will be different, though at this stage, the original values are still the initial values. With any subsequent changes to data in a <code>RowSet</code> object, its original values and current values will still differ, but its original values will be the values that were previously the current values. </p>
<p> Keeping track of original values allows the writer to compare the <code>RowSet</code> object's original value with the value in the database. If the values in the database differ from the <code>RowSet</code> object's original values, which means that the values in the database have been changed, there is a conflict. Whether a writer checks for conflicts, what degree of checking it does, and how it handles conflicts all depend on how it is implemented. </p>
<h2>5.0 Registering and Notifying Listeners</h2> Being JavaBeans components, all rowsets participate in the JavaBeans event model, inheriting methods for registering listeners and notifying them of changes from the <code>BaseRowSet</code> class. A listener for a <code>CachedRowSet</code> object is a component that wants to be notified whenever there is a change in the rowset. For example, if a <code>CachedRowSet</code> object contains the results of a query and those results are being displayed in, say, a table and a bar graph, the table and bar graph could be registered as listeners with the rowset so that they can update themselves to reflect changes. To become listeners, the table and bar graph classes must implement the <code>RowSetListener</code> interface. Then they can be added to the <code>CachedRowSet</code> object's list of listeners, as is illustrated in the following lines of code. <pre data-language="java">crs.addRowSetListener(table);
    crs.addRowSetListener(barGraph);</pre> Each <code>CachedRowSet</code> method that moves the cursor or changes data also notifies registered listeners of the changes, so <code>table</code> and <code>barGraph</code> will be notified when there is a change in <code>crs</code>. <h2>6.0 Passing Data to Thin Clients</h2> One of the main reasons to use a <code>CachedRowSet</code> object is to pass data between different components of an application. Because it is serializable, a <code>CachedRowSet</code> object can be used, for example, to send the result of a query executed by an enterprise JavaBeans component running in a server environment over a network to a client running in a web browser. <p> While a <code>CachedRowSet</code> object is disconnected, it can be much leaner than a <code>ResultSet</code> object with the same data. As a result, it can be especially suitable for sending data to a thin client such as a PDA, where it would be inappropriate to use a JDBC driver due to resource limitations or security considerations. Thus, a <code>CachedRowSet</code> object provides a means to "get rows in" without the need to implement the full JDBC API. </p>
<h2>7.0 Scrolling and Updating</h2> A second major use for <code>CachedRowSet</code> objects is to provide scrolling and updating for <code>ResultSet</code> objects that do not provide these capabilities themselves. In other words, a <code>CachedRowSet</code> object can be used to augment the capabilities of a JDBC technology-enabled driver (hereafter called a "JDBC driver") when the DBMS does not provide full support for scrolling and updating. To achieve the effect of making a non-scrollable and read-only <code>ResultSet</code> object scrollable and updatable, a programmer simply needs to create a <code>CachedRowSet</code> object populated with that <code>ResultSet</code> object's data. This is demonstrated in the following code fragment, where <code>stmt</code> is a <code>Statement</code> object. <pre data-language="java">ResultSet rs = stmt.executeQuery("SELECT * FROM EMPLOYEES");
    CachedRowSetImpl crs = new CachedRowSetImpl();
    crs.populate(rs);</pre> <p> The object <code>crs</code> now contains the data from the table <code>EMPLOYEES</code>, just as the object <code>rs</code> does. The difference is that the cursor for <code>crs</code> can be moved forward, backward, or to a particular row even if the cursor for <code>rs</code> can move only forward. In addition, <code>crs</code> is updatable even if <code>rs</code> is not because by default, a <code>CachedRowSet</code> object is both scrollable and updatable. </p>
<p> In summary, a <code>CachedRowSet</code> object can be thought of as simply a disconnected set of rows that are being cached outside of a data source. Being thin and serializable, it can easily be sent across a wire, and it is well suited to sending data to a thin client. However, a <code>CachedRowSet</code> object does have a limitation: It is limited in size by the amount of data it can store in memory at one time. </p>
<h2>8.0 Getting Universal Data Access</h2> Another advantage of the <code>CachedRowSet</code> class is that it makes it possible to retrieve and store data from sources other than a relational database. The reader for a rowset can be implemented to read and populate its rowset with data from any tabular data source, including a spreadsheet or flat file. Because both a <code>CachedRowSet</code> object and its metadata can be created from scratch, a component that acts as a factory for rowsets can use this capability to create a rowset containing data from non-SQL data sources. Nevertheless, it is expected that most of the time, <code>CachedRowSet</code> objects will contain data that was fetched from an SQL database using the JDBC API. <h2>9.0 Setting Properties</h2> All rowsets maintain a set of properties, which will usually be set using a tool. The number and kinds of properties a rowset has will vary, depending on what the rowset does and how it gets its data. For example, rowsets that get their data from a <code>ResultSet</code> object need to set the properties that are required for making a database connection. If a rowset uses the <code>DriverManager</code> facility to make a connection, it needs to set a property for the JDBC URL that identifies the appropriate driver, and it needs to set the properties that give the user name and password. If, on the other hand, the rowset uses a <code>DataSource</code> object to make the connection, which is the preferred method, it does not need to set the property for the JDBC URL. Instead, it needs to set properties for the logical name of the data source, for the user name, and for the password. <p> NOTE: In order to use a <code>DataSource</code> object for making a connection, the <code>DataSource</code> object must have been registered with a naming service that uses the Java Naming and Directory Interfaceâ„¢ (JNDI) API. This registration is usually done by a person acting in the capacity of a system administrator. </p>
<p> In order to be able to populate itself with data from a database, a rowset needs to set a command property. This property is a query that is a <code>PreparedStatement</code> object, which allows the query to have parameter placeholders that are set at run time, as opposed to design time. To set these placeholder parameters with values, a rowset provides setter methods for setting values of each data type, similar to the setter methods provided by the <code>PreparedStatement</code> interface. </p>
<p> The following code fragment illustrates how the <code>CachedRowSet</code> object <code>crs</code> might have its command property set. Note that if a tool is used to set properties, this is the code that the tool would use. </p>
<pre data-language="java">crs.setCommand("SELECT FIRST_NAME, LAST_NAME, ADDRESS FROM CUSTOMERS " +
                   "WHERE CREDIT_LIMIT &gt; ? AND REGION = ?");</pre> <p> The values that will be used to set the command's placeholder parameters are contained in the <code>RowSet</code> object's <code>params</code> field, which is a <code>Vector</code> object. The <code>CachedRowSet</code> class provides a set of setter methods for setting the elements in its <code>params</code> field. The following code fragment demonstrates setting the two parameters in the query from the previous example. </p>
<pre data-language="java">crs.setInt(1, 5000);
    crs.setString(2, "West");</pre> <p> The <code>params</code> field now contains two elements, each of which is an array two elements long. The first element is the parameter number; the second is the value to be set. In this case, the first element of <code>params</code> is <code>1</code>, <code>5000</code>, and the second element is <code>2</code>, <code>"West"</code>. When an application calls the method <code>execute</code>, it will in turn call on this <code>RowSet</code> object's reader, which will in turn invoke its <code>readData</code> method. As part of its implementation, <code>readData</code> will get the values in <code>params</code> and use them to set the command's placeholder parameters. The following code fragment gives an idea of how the reader does this, after obtaining the <code>Connection</code> object <code>con</code>. </p>
<pre data-language="java">PreparedStatement pstmt = con.prepareStatement(crs.getCommand());
    reader.decodeParams();
    // decodeParams figures out which setter methods to use and does something
    // like the following:
    //    for (i = 0; i &lt; params.length; i++) {
    //        pstmt.setObject(i + 1, params[i]);
    //    }</pre> <p> At this point, the command for <code>crs</code> is the query <code>"SELECT
 FIRST_NAME, LAST_NAME, ADDRESS FROM CUSTOMERS WHERE CREDIT_LIMIT &gt; 5000
 AND REGION = "West"</code>. After the <code>readData</code> method executes this command with the following line of code, it will have the data from <code>rs</code> with which to populate <code>crs</code>. </p>
<pre data-language="java">ResultSet rs = pstmt.executeQuery();</pre> <p> The preceding code fragments give an idea of what goes on behind the scenes; they would not appear in an application, which would not invoke methods like <code>readData</code> and <code>decodeParams</code>. In contrast, the following code fragment shows what an application might do. It sets the rowset's command, sets the command's parameters, and executes the command. Simply by calling the <code>execute</code> method, <code>crs</code> populates itself with the requested data from the table <code>CUSTOMERS</code>. </p>
<pre data-language="java">crs.setCommand("SELECT FIRST_NAME, LAST_NAME, ADDRESS FROM CUSTOMERS" +
                   "WHERE CREDIT_LIMIT &gt; ? AND REGION = ?");
    crs.setInt(1, 5000);
    crs.setString(2, "West");
    crs.execute();</pre> <h2>10.0 Paging Data</h2> Because a <code>CachedRowSet</code> object stores data in memory, the amount of data that it can contain at any one time is determined by the amount of memory available. To get around this limitation, a <code>CachedRowSet</code> object can retrieve data from a <code>ResultSet</code> object in chunks of data, called <i>pages</i>. To take advantage of this mechanism, an application sets the number of rows to be included in a page using the method <code>setPageSize</code>. In other words, if the page size is set to five, a chunk of five rows of data will be fetched from the data source at one time. An application can also optionally set the maximum number of rows that may be fetched at one time. If the maximum number of rows is set to zero, or no maximum number of rows is set, there is no limit to the number of rows that may be fetched at a time. <p> After properties have been set, the <code>CachedRowSet</code> object must be populated with data using either the method <code>populate</code> or the method <code>execute</code>. The following lines of code demonstrate using the method <code>populate</code>. Note that this version of the method takes two parameters, a <code>ResultSet</code> handle and the row in the <code>ResultSet</code> object from which to start retrieving rows. </p>
<pre data-language="java">CachedRowSet crs = new CachedRowSetImpl();
     crs.setMaxRows(20);
     crs.setPageSize(4);
     crs.populate(rsHandle, 10);</pre> When this code runs, <i>crs</i> will be populated with four rows from <i>rsHandle</i> starting with the tenth row. <p> The next code fragment shows populating a <code>CachedRowSet</code> object using the method <code>execute</code>, which may or may not take a <code>Connection</code> object as a parameter. This code passes <code>execute</code> the <code>Connection</code> object <i>conHandle</i>. </p>
<p> Note that there are two differences between the following code fragment and the previous one. First, the method <code>setMaxRows</code> is not called, so there is no limit set for the number of rows that <i>crs</i> may contain. (Remember that <i>crs</i> always has the overriding limit of how much data it can store in memory.) The second difference is that the you cannot pass the method <code>execute</code> the number of the row in the <code>ResultSet</code> object from which to start retrieving rows. This method always starts with the first row. </p>
<pre data-language="java">CachedRowSet crs = new CachedRowSetImpl();
     crs.setPageSize(5);
     crs.execute(conHandle);</pre> After this code has run, <i>crs</i> will contain five rows of data from the <code>ResultSet</code> object produced by the command for <i>crs</i>. The writer for <i>crs</i> will use <i>conHandle</i> to connect to the data source and execute the command for <i>crs</i>. An application is then able to operate on the data in <i>crs</i> in the same way that it would operate on data in any other <code>CachedRowSet</code> object. <p> To access the next page (chunk of data), an application calls the method <code>nextPage</code>. This method creates a new <code>CachedRowSet</code> object and fills it with the next page of data. For example, assume that the <code>CachedRowSet</code> object's command returns a <code>ResultSet</code> object <i>rs</i> with 1000 rows of data. If the page size has been set to 100, the first call to the method <code>nextPage</code> will create a <code>CachedRowSet</code> object containing the first 100 rows of <i>rs</i>. After doing what it needs to do with the data in these first 100 rows, the application can again call the method <code>nextPage</code> to create another <code>CachedRowSet</code> object with the second 100 rows from <i>rs</i>. The data from the first <code>CachedRowSet</code> object will no longer be in memory because it is replaced with the data from the second <code>CachedRowSet</code> object. After the tenth call to the method <code>nextPage</code>, the tenth <code>CachedRowSet</code> object will contain the last 100 rows of data from <i>rs</i>, which are stored in memory. At any given time, the data from only one <code>CachedRowSet</code> object is stored in memory. </p>
<p> The method <code>nextPage</code> returns <code>true</code> as long as the current page is not the last page of rows and <code>false</code> when there are no more pages. It can therefore be used in a <code>while</code> loop to retrieve all of the pages, as is demonstrated in the following lines of code. </p>
<pre data-language="java">CachedRowSet crs = CachedRowSetImpl();
     crs.setPageSize(100);
     crs.execute(conHandle);

     while(crs.nextPage()) {
         while(crs.next()) {
             . . . // operate on chunks (of 100 rows each) in crs,
                   // row by row
         }
     }</pre> After this code fragment has been run, the application will have traversed all 1000 rows, but it will have had no more than 100 rows in memory at a time. <p> The <code>CachedRowSet</code> interface also defines the method <code>previousPage</code>. Just as the method <code>nextPage</code> is analogous to the <code>ResultSet</code> method <code>next</code>, the method <code>previousPage</code> is analogous to the <code>ResultSet</code> method <code>previous</code>. Similar to the method <code>nextPage</code>, <code>previousPage</code> creates a <code>CachedRowSet</code> object containing the number of rows set as the page size. So, for instance, the method <code>previousPage</code> could be used in a <code>while</code> loop at the end of the preceding code fragment to navigate back through the pages from the last page to the first page. The method <code>previousPage</code> is also similar to <code>nextPage</code> in that it can be used in a <code>while</code> loop, except that it returns <code>true</code> as long as there is another page preceding it and <code>false</code> when there are no more pages ahead of it. </p>
<p> By positioning the cursor after the last row for each page, as is done in the following code fragment, the method <code>previous</code> navigates from the last row to the first row in each page. The code could also have left the cursor before the first row on each page and then used the method <code>next</code> in a <code>while</code> loop to navigate each page from the first row to the last row. </p>
<p> The following code fragment assumes a continuation from the previous code fragment, meaning that the cursor for the tenth <code>CachedRowSet</code> object is on the last row. The code moves the cursor to after the last row so that the first call to the method <code>previous</code> will put the cursor back on the last row. After going through all of the rows in the last page (the <code>CachedRowSet</code> object <i>crs</i>), the code then enters the <code>while</code> loop to get to the ninth page, go through the rows backwards, go to the eighth page, go through the rows backwards, and so on to the first row of the first page. </p>
<pre data-language="java">crs.afterLast();
     while(crs.previous())  {
         . . . // navigate through the rows, last to first
     {
     while(crs.previousPage())  {
         crs.afterLast();
         while(crs.previous())  {
             . . . // go from the last row to the first row of each page
         }
     }</pre>
</div> <dl> <dt>Since:</dt> <dd>1.5</dd> </dl>      <section role="region">  <h2 id="field.summary">Fields</h2> <table>  <tr> <th scope="col">Modifier and Type</th> <th scope="col">Field</th> <th scope="col">Description</th> </tr> <tr> <td><code>static boolean</code></td> <th scope="row"><code><a href="#COMMIT_ON_ACCEPT_CHANGES">COMMIT_ON_ACCEPT_CHANGES</a></code></th> <td> <p><strong>Deprecated.</strong> <div>Because this field is final (it is part of an interface), its value cannot be changed.</div> </p> </td> </tr> </table>  <h2 id="fields.inherited.from.class.java.sql.ResultSet">Fields declared in interface java.sql.<a href="../../../../java.sql/java/sql/resultset">ResultSet</a>
</h2> <code><a href="../../../../java.sql/java/sql/resultset#CLOSE_CURSORS_AT_COMMIT">CLOSE_CURSORS_AT_COMMIT</a>, <a href="../../../../java.sql/java/sql/resultset#CONCUR_READ_ONLY">CONCUR_READ_ONLY</a>, <a href="../../../../java.sql/java/sql/resultset#CONCUR_UPDATABLE">CONCUR_UPDATABLE</a>, <a href="../../../../java.sql/java/sql/resultset#FETCH_FORWARD">FETCH_FORWARD</a>, <a href="../../../../java.sql/java/sql/resultset#FETCH_REVERSE">FETCH_REVERSE</a>, <a href="../../../../java.sql/java/sql/resultset#FETCH_UNKNOWN">FETCH_UNKNOWN</a>, <a href="../../../../java.sql/java/sql/resultset#HOLD_CURSORS_OVER_COMMIT">HOLD_CURSORS_OVER_COMMIT</a>, <a href="../../../../java.sql/java/sql/resultset#TYPE_FORWARD_ONLY">TYPE_FORWARD_ONLY</a>, <a href="../../../../java.sql/java/sql/resultset#TYPE_SCROLL_INSENSITIVE">TYPE_SCROLL_INSENSITIVE</a>, <a href="../../../../java.sql/java/sql/resultset#TYPE_SCROLL_SENSITIVE">TYPE_SCROLL_SENSITIVE</a></code>  </section>  <section role="region">  <h2 id="method.summary">Methods</h2> <table>  <tr> <th scope="col">Modifier and Type</th> <th scope="col">Method</th> <th scope="col">Description</th> </tr> <tr id="i0"> <td><code>void</code></td> <th scope="row"><code><a href="#acceptChanges()">acceptChanges</a>()</code></th> <td> <p>Propagates row update, insert and delete changes made to this <code>CachedRowSet</code> object to the underlying data source.</p> </td> </tr> <tr id="i1"> <td><code>void</code></td> <th scope="row"><code><a href="#acceptChanges(java.sql.Connection)">acceptChanges</a>â€‹(<a href="../../../../java.sql/java/sql/connection">Connection</a>Â con)</code></th> <td> <p>Propagates all row update, insert and delete changes to the data source backing this <code>CachedRowSet</code> object using the specified <code>Connection</code> object to establish a connection to the data source.</p> </td> </tr> <tr id="i2"> <td><code>boolean</code></td> <th scope="row"><code><a href="#columnUpdated(int)">columnUpdated</a>â€‹(intÂ idx)</code></th> <td> <p>Indicates whether the designated column in the current row of this <code>CachedRowSet</code> object has been updated.</p> </td> </tr> <tr id="i3"> <td><code>boolean</code></td> <th scope="row"><code><a href="#columnUpdated(java.lang.String)">columnUpdated</a>â€‹(<a href="../../../../java.base/java/lang/string">String</a>Â columnName)</code></th> <td> <p>Indicates whether the designated column in the current row of this <code>CachedRowSet</code> object has been updated.</p> </td> </tr> <tr id="i4"> <td><code>void</code></td> <th scope="row"><code><a href="#commit()">commit</a>()</code></th> <td> <p>Each <code>CachedRowSet</code> object's <code>SyncProvider</code> contains a <code>Connection</code> object from the <code>ResultSet</code> or JDBC properties passed to it's constructors.</p> </td> </tr> <tr id="i5"> <td><code><a href="cachedrowset">CachedRowSet</a></code></td> <th scope="row"><code><a href="#createCopy()">createCopy</a>()</code></th> <td> <p>Creates a <code>RowSet</code> object that is a deep copy of the data in this <code>CachedRowSet</code> object.</p> </td> </tr> <tr id="i6"> <td><code><a href="cachedrowset">CachedRowSet</a></code></td> <th scope="row"><code><a href="#createCopyNoConstraints()">createCopyNoConstraints</a>()</code></th> <td> <p>Creates a <code>CachedRowSet</code> object that is a deep copy of this <code>CachedRowSet</code> object's data but is independent of it.</p> </td> </tr> <tr id="i7"> <td><code><a href="cachedrowset">CachedRowSet</a></code></td> <th scope="row"><code><a href="#createCopySchema()">createCopySchema</a>()</code></th> <td> <p>Creates a <code>CachedRowSet</code> object that is an empty copy of this <code>CachedRowSet</code> object.</p> </td> </tr> <tr id="i8"> <td><code><a href="../../../../java.sql/javax/sql/rowset">RowSet</a></code></td> <th scope="row"><code><a href="#createShared()">createShared</a>()</code></th> <td> <p>Returns a new <code>RowSet</code> object backed by the same data as that of this <code>CachedRowSet</code> object.</p> </td> </tr> <tr id="i9"> <td><code>void</code></td> <th scope="row"><code><a href="#execute(java.sql.Connection)">execute</a>â€‹(<a href="../../../../java.sql/java/sql/connection">Connection</a>Â conn)</code></th> <td> <p>Populates this <code>CachedRowSet</code> object with data, using the given connection to produce the result set from which the data will be read.</p> </td> </tr> <tr id="i10"> <td><code>int[]</code></td> <th scope="row"><code><a href="#getKeyColumns()">getKeyColumns</a>()</code></th> <td> <p>Returns an array containing one or more column numbers indicating the columns that form a key that uniquely identifies a row in this <code>CachedRowSet</code> object.</p> </td> </tr> <tr id="i11"> <td><code><a href="../../../../java.sql/java/sql/resultset">ResultSet</a></code></td> <th scope="row"><code><a href="#getOriginal()">getOriginal</a>()</code></th> <td> <p>Returns a <code>ResultSet</code> object containing the original value of this <code>CachedRowSet</code> object.</p> </td> </tr> <tr id="i12"> <td><code><a href="../../../../java.sql/java/sql/resultset">ResultSet</a></code></td> <th scope="row"><code><a href="#getOriginalRow()">getOriginalRow</a>()</code></th> <td> <p>Returns a <code>ResultSet</code> object containing the original value for the current row only of this <code>CachedRowSet</code> object.</p> </td> </tr> <tr id="i13"> <td><code>int</code></td> <th scope="row"><code><a href="#getPageSize()">getPageSize</a>()</code></th> <td> <p>Returns the page-size for the <code>CachedRowSet</code> object</p> </td> </tr> <tr id="i14"> <td><code><a href="rowsetwarning">RowSetWarning</a></code></td> <th scope="row"><code><a href="#getRowSetWarnings()">getRowSetWarnings</a>()</code></th> <td> <p>Retrieves the first warning reported by calls on this <code>RowSet</code> object.</p> </td> </tr> <tr id="i15"> <td><code>boolean</code></td> <th scope="row"><code><a href="#getShowDeleted()">getShowDeleted</a>()</code></th> <td> <p>Retrieves a <code>boolean</code> indicating whether rows marked for deletion appear in the set of current rows.</p> </td> </tr> <tr id="i16"> <td><code><a href="spi/syncprovider">SyncProvider</a></code></td> <th scope="row"><code><a href="#getSyncProvider()">getSyncProvider</a>()</code></th> <td> <p>Retrieves the <code>SyncProvider</code> implementation for this <code>CachedRowSet</code> object.</p> </td> </tr> <tr id="i17"> <td><code><a href="../../../../java.base/java/lang/string">String</a></code></td> <th scope="row"><code><a href="#getTableName()">getTableName</a>()</code></th> <td> <p>Returns an identifier for the object (table) that was used to create this <code>CachedRowSet</code> object.</p> </td> </tr> <tr id="i18"> <td><code>boolean</code></td> <th scope="row"><code><a href="#nextPage()">nextPage</a>()</code></th> <td> <p>Increments the current page of the <code>CachedRowSet</code>.</p> </td> </tr> <tr id="i19"> <td><code>void</code></td> <th scope="row"><code><a href="#populate(java.sql.ResultSet)">populate</a>â€‹(<a href="../../../../java.sql/java/sql/resultset">ResultSet</a>Â data)</code></th> <td> <p>Populates this <code>CachedRowSet</code> object with data from the given <code>ResultSet</code> object.</p> </td> </tr> <tr id="i20"> <td><code>void</code></td> <th scope="row"><code><a href="#populate(java.sql.ResultSet,int)">populate</a>â€‹(<a href="../../../../java.sql/java/sql/resultset">ResultSet</a>Â rs,
        intÂ startRow)</code></th> <td> <p>Populates this <code>CachedRowSet</code> object with data from the given <code>ResultSet</code> object.</p> </td> </tr> <tr id="i21"> <td><code>boolean</code></td> <th scope="row"><code><a href="#previousPage()">previousPage</a>()</code></th> <td> <p>Decrements the current page of the <code>CachedRowSet</code>.</p> </td> </tr> <tr id="i22"> <td><code>void</code></td> <th scope="row"><code><a href="#release()">release</a>()</code></th> <td> <p>Releases the current contents of this <code>CachedRowSet</code> object and sends a <code>rowSetChanged</code> event to all registered listeners.</p> </td> </tr> <tr id="i23"> <td><code>void</code></td> <th scope="row"><code><a href="#restoreOriginal()">restoreOriginal</a>()</code></th> <td> <p>Restores this <code>CachedRowSet</code> object to its original value, that is, its value before the last set of changes.</p> </td> </tr> <tr id="i24"> <td><code>void</code></td> <th scope="row"><code><a href="#rollback()">rollback</a>()</code></th> <td> <p>Each <code>CachedRowSet</code> object's <code>SyncProvider</code> contains a <code>Connection</code> object from the original <code>ResultSet</code> or JDBC properties passed to it.</p> </td> </tr> <tr id="i25"> <td><code>void</code></td> <th scope="row"><code><a href="#rollback(java.sql.Savepoint)">rollback</a>â€‹(<a href="../../../../java.sql/java/sql/savepoint">Savepoint</a>Â s)</code></th> <td> <p>Each <code>CachedRowSet</code> object's <code>SyncProvider</code> contains a <code>Connection</code> object from the original <code>ResultSet</code> or JDBC properties passed to it.</p> </td> </tr> <tr id="i26"> <td><code>void</code></td> <th scope="row"><code><a href="#rowSetPopulated(javax.sql.RowSetEvent,int)">rowSetPopulated</a>â€‹(<a href="../../../../java.sql/javax/sql/rowsetevent">RowSetEvent</a>Â event,
               intÂ numRows)</code></th> <td> <p>Notifies registered listeners that a RowSet object in the given RowSetEvent object has populated a number of additional rows.</p> </td> </tr> <tr id="i27"> <td><code>void</code></td> <th scope="row"><code><a href="#setKeyColumns(int%5B%5D)">setKeyColumns</a>â€‹(int[]Â keys)</code></th> <td> <p>Sets this <code>CachedRowSet</code> object's <code>keyCols</code> field with the given array of column numbers, which forms a key for uniquely identifying a row in this <code>CachedRowSet</code> object.</p> </td> </tr> <tr id="i28"> <td><code>void</code></td> <th scope="row"><code><a href="#setMetaData(javax.sql.RowSetMetaData)">setMetaData</a>â€‹(<a href="../../../../java.sql/javax/sql/rowsetmetadata">RowSetMetaData</a>Â md)</code></th> <td> <p>Sets the metadata for this <code>CachedRowSet</code> object with the given <code>RowSetMetaData</code> object.</p> </td> </tr> <tr id="i29"> <td><code>void</code></td> <th scope="row"><code><a href="#setOriginalRow()">setOriginalRow</a>()</code></th> <td> <p>Sets the current row in this <code>CachedRowSet</code> object as the original row.</p> </td> </tr> <tr id="i30"> <td><code>void</code></td> <th scope="row"><code><a href="#setPageSize(int)">setPageSize</a>â€‹(intÂ size)</code></th> <td> <p>Sets the <code>CachedRowSet</code> object's page-size.</p> </td> </tr> <tr id="i31"> <td><code>void</code></td> <th scope="row"><code><a href="#setShowDeleted(boolean)">setShowDeleted</a>â€‹(booleanÂ b)</code></th> <td> <p>Sets the property <code>showDeleted</code> to the given <code>boolean</code> value, which determines whether rows marked for deletion appear in the set of current rows.</p> </td> </tr> <tr id="i32"> <td><code>void</code></td> <th scope="row"><code><a href="#setSyncProvider(java.lang.String)">setSyncProvider</a>â€‹(<a href="../../../../java.base/java/lang/string">String</a>Â provider)</code></th> <td> <p>Sets the <code>SyncProvider</code> object for this <code>CachedRowSet</code> object to the one specified.</p> </td> </tr> <tr id="i33"> <td><code>void</code></td> <th scope="row"><code><a href="#setTableName(java.lang.String)">setTableName</a>â€‹(<a href="../../../../java.base/java/lang/string">String</a>Â tabName)</code></th> <td> <p>Sets the identifier for the table from which this <code>CachedRowSet</code> object was derived to the given table name.</p> </td> </tr> <tr id="i34"> <td><code>int</code></td> <th scope="row"><code><a href="#size()">size</a>()</code></th> <td> <p>Returns the number of rows in this <code>CachedRowSet</code> object.</p> </td> </tr> <tr id="i35"> <td><code><a href="../../../../java.base/java/util/collection">Collection</a>&lt;?&gt;</code></td> <th scope="row"><code><a href="#toCollection()">toCollection</a>()</code></th> <td> <p>Converts this <code>CachedRowSet</code> object to a <code>Collection</code> object that contains all of this <code>CachedRowSet</code> object's data.</p> </td> </tr> <tr id="i36"> <td><code><a href="../../../../java.base/java/util/collection">Collection</a>&lt;?&gt;</code></td> <th scope="row"><code><a href="#toCollection(int)">toCollection</a>â€‹(intÂ column)</code></th> <td> <p>Converts the designated column in this <code>CachedRowSet</code> object to a <code>Collection</code> object.</p> </td> </tr> <tr id="i37"> <td><code><a href="../../../../java.base/java/util/collection">Collection</a>&lt;?&gt;</code></td> <th scope="row"><code><a href="#toCollection(java.lang.String)">toCollection</a>â€‹(<a href="../../../../java.base/java/lang/string">String</a>Â column)</code></th> <td> <p>Converts the designated column in this <code>CachedRowSet</code> object to a <code>Collection</code> object.</p> </td> </tr> <tr id="i38"> <td><code>void</code></td> <th scope="row"><code><a href="#undoDelete()">undoDelete</a>()</code></th> <td> <p>Cancels the deletion of the current row and notifies listeners that a row has changed.</p> </td> </tr> <tr id="i39"> <td><code>void</code></td> <th scope="row"><code><a href="#undoInsert()">undoInsert</a>()</code></th> <td> <p>Immediately removes the current row from this <code>CachedRowSet</code> object if the row has been inserted, and also notifies listeners that a row has changed.</p> </td> </tr> <tr id="i40"> <td><code>void</code></td> <th scope="row"><code><a href="#undoUpdate()">undoUpdate</a>()</code></th> <td> <p>Immediately reverses the last update operation if the row has been modified.</p> </td> </tr> </table>  <h2 id="methods.inherited.from.class.javax.sql.rowset.Joinable">Methods declared in interface javax.sql.rowset.<a href="joinable">Joinable</a>
</h2> <code><a href="joinable#getMatchColumnIndexes()">getMatchColumnIndexes</a>, <a href="joinable#getMatchColumnNames()">getMatchColumnNames</a>, <a href="joinable#setMatchColumn(int)">setMatchColumn</a>, <a href="joinable#setMatchColumn(int%5B%5D)">setMatchColumn</a>, <a href="joinable#setMatchColumn(java.lang.String)">setMatchColumn</a>, <a href="joinable#setMatchColumn(java.lang.String%5B%5D)">setMatchColumn</a>, <a href="joinable#unsetMatchColumn(int)">unsetMatchColumn</a>, <a href="joinable#unsetMatchColumn(int%5B%5D)">unsetMatchColumn</a>, <a href="joinable#unsetMatchColumn(java.lang.String)">unsetMatchColumn</a>, <a href="joinable#unsetMatchColumn(java.lang.String%5B%5D)">unsetMatchColumn</a></code>  <h2 id="methods.inherited.from.class.java.sql.ResultSet">Methods declared in interface java.sql.<a href="../../../../java.sql/java/sql/resultset">ResultSet</a>
</h2> <code><a href="../../../../java.sql/java/sql/resultset#absolute(int)">absolute</a>, <a href="../../../../java.sql/java/sql/resultset#afterLast()">afterLast</a>, <a href="../../../../java.sql/java/sql/resultset#beforeFirst()">beforeFirst</a>, <a href="../../../../java.sql/java/sql/resultset#cancelRowUpdates()">cancelRowUpdates</a>, <a href="../../../../java.sql/java/sql/resultset#clearWarnings()">clearWarnings</a>, <a href="../../../../java.sql/java/sql/resultset#close()">close</a>, <a href="../../../../java.sql/java/sql/resultset#deleteRow()">deleteRow</a>, <a href="../../../../java.sql/java/sql/resultset#findColumn(java.lang.String)">findColumn</a>, <a href="../../../../java.sql/java/sql/resultset#first()">first</a>, <a href="../../../../java.sql/java/sql/resultset#getArray(int)">getArray</a>, <a href="../../../../java.sql/java/sql/resultset#getArray(java.lang.String)">getArray</a>, <a href="../../../../java.sql/java/sql/resultset#getAsciiStream(int)">getAsciiStream</a>, <a href="../../../../java.sql/java/sql/resultset#getAsciiStream(java.lang.String)">getAsciiStream</a>, <a href="../../../../java.sql/java/sql/resultset#getBigDecimal(int)">getBigDecimal</a>, <a href="../../../../java.sql/java/sql/resultset#getBigDecimal(int,int)">getBigDecimal</a>, <a href="../../../../java.sql/java/sql/resultset#getBigDecimal(java.lang.String)">getBigDecimal</a>, <a href="../../../../java.sql/java/sql/resultset#getBigDecimal(java.lang.String,int)">getBigDecimal</a>, <a href="../../../../java.sql/java/sql/resultset#getBinaryStream(int)">getBinaryStream</a>, <a href="../../../../java.sql/java/sql/resultset#getBinaryStream(java.lang.String)">getBinaryStream</a>, <a href="../../../../java.sql/java/sql/resultset#getBlob(int)">getBlob</a>, <a href="../../../../java.sql/java/sql/resultset#getBlob(java.lang.String)">getBlob</a>, <a href="../../../../java.sql/java/sql/resultset#getBoolean(int)">getBoolean</a>, <a href="../../../../java.sql/java/sql/resultset#getBoolean(java.lang.String)">getBoolean</a>, <a href="../../../../java.sql/java/sql/resultset#getByte(int)">getByte</a>, <a href="../../../../java.sql/java/sql/resultset#getByte(java.lang.String)">getByte</a>, <a href="../../../../java.sql/java/sql/resultset#getBytes(int)">getBytes</a>, <a href="../../../../java.sql/java/sql/resultset#getBytes(java.lang.String)">getBytes</a>, <a href="../../../../java.sql/java/sql/resultset#getCharacterStream(int)">getCharacterStream</a>, <a href="../../../../java.sql/java/sql/resultset#getCharacterStream(java.lang.String)">getCharacterStream</a>, <a href="../../../../java.sql/java/sql/resultset#getClob(int)">getClob</a>, <a href="../../../../java.sql/java/sql/resultset#getClob(java.lang.String)">getClob</a>, <a href="../../../../java.sql/java/sql/resultset#getConcurrency()">getConcurrency</a>, <a href="../../../../java.sql/java/sql/resultset#getCursorName()">getCursorName</a>, <a href="../../../../java.sql/java/sql/resultset#getDate(int)">getDate</a>, <a href="../../../../java.sql/java/sql/resultset#getDate(int,java.util.Calendar)">getDate</a>, <a href="../../../../java.sql/java/sql/resultset#getDate(java.lang.String)">getDate</a>, <a href="../../../../java.sql/java/sql/resultset#getDate(java.lang.String,java.util.Calendar)">getDate</a>, <a href="../../../../java.sql/java/sql/resultset#getDouble(int)">getDouble</a>, <a href="../../../../java.sql/java/sql/resultset#getDouble(java.lang.String)">getDouble</a>, <a href="../../../../java.sql/java/sql/resultset#getFetchDirection()">getFetchDirection</a>, <a href="../../../../java.sql/java/sql/resultset#getFetchSize()">getFetchSize</a>, <a href="../../../../java.sql/java/sql/resultset#getFloat(int)">getFloat</a>, <a href="../../../../java.sql/java/sql/resultset#getFloat(java.lang.String)">getFloat</a>, <a href="../../../../java.sql/java/sql/resultset#getHoldability()">getHoldability</a>, <a href="../../../../java.sql/java/sql/resultset#getInt(int)">getInt</a>, <a href="../../../../java.sql/java/sql/resultset#getInt(java.lang.String)">getInt</a>, <a href="../../../../java.sql/java/sql/resultset#getLong(int)">getLong</a>, <a href="../../../../java.sql/java/sql/resultset#getLong(java.lang.String)">getLong</a>, <a href="../../../../java.sql/java/sql/resultset#getMetaData()">getMetaData</a>, <a href="../../../../java.sql/java/sql/resultset#getNCharacterStream(int)">getNCharacterStream</a>, <a href="../../../../java.sql/java/sql/resultset#getNCharacterStream(java.lang.String)">getNCharacterStream</a>, <a href="../../../../java.sql/java/sql/resultset#getNClob(int)">getNClob</a>, <a href="../../../../java.sql/java/sql/resultset#getNClob(java.lang.String)">getNClob</a>, <a href="../../../../java.sql/java/sql/resultset#getNString(int)">getNString</a>, <a href="../../../../java.sql/java/sql/resultset#getNString(java.lang.String)">getNString</a>, <a href="../../../../java.sql/java/sql/resultset#getObject(int)">getObject</a>, <a href="../../../../java.sql/java/sql/resultset#getObject(int,java.lang.Class)">getObject</a>, <a href="../../../../java.sql/java/sql/resultset#getObject(int,java.util.Map)">getObject</a>, <a href="../../../../java.sql/java/sql/resultset#getObject(java.lang.String)">getObject</a>, <a href="../../../../java.sql/java/sql/resultset#getObject(java.lang.String,java.lang.Class)">getObject</a>, <a href="../../../../java.sql/java/sql/resultset#getObject(java.lang.String,java.util.Map)">getObject</a>, <a href="../../../../java.sql/java/sql/resultset#getRef(int)">getRef</a>, <a href="../../../../java.sql/java/sql/resultset#getRef(java.lang.String)">getRef</a>, <a href="../../../../java.sql/java/sql/resultset#getRow()">getRow</a>, <a href="../../../../java.sql/java/sql/resultset#getRowId(int)">getRowId</a>, <a href="../../../../java.sql/java/sql/resultset#getRowId(java.lang.String)">getRowId</a>, <a href="../../../../java.sql/java/sql/resultset#getShort(int)">getShort</a>, <a href="../../../../java.sql/java/sql/resultset#getShort(java.lang.String)">getShort</a>, <a href="../../../../java.sql/java/sql/resultset#getSQLXML(int)">getSQLXML</a>, <a href="../../../../java.sql/java/sql/resultset#getSQLXML(java.lang.String)">getSQLXML</a>, <a href="../../../../java.sql/java/sql/resultset#getStatement()">getStatement</a>, <a href="../../../../java.sql/java/sql/resultset#getString(int)">getString</a>, <a href="../../../../java.sql/java/sql/resultset#getString(java.lang.String)">getString</a>, <a href="../../../../java.sql/java/sql/resultset#getTime(int)">getTime</a>, <a href="../../../../java.sql/java/sql/resultset#getTime(int,java.util.Calendar)">getTime</a>, <a href="../../../../java.sql/java/sql/resultset#getTime(java.lang.String)">getTime</a>, <a href="../../../../java.sql/java/sql/resultset#getTime(java.lang.String,java.util.Calendar)">getTime</a>, <a href="../../../../java.sql/java/sql/resultset#getTimestamp(int)">getTimestamp</a>, <a href="../../../../java.sql/java/sql/resultset#getTimestamp(int,java.util.Calendar)">getTimestamp</a>, <a href="../../../../java.sql/java/sql/resultset#getTimestamp(java.lang.String)">getTimestamp</a>, <a href="../../../../java.sql/java/sql/resultset#getTimestamp(java.lang.String,java.util.Calendar)">getTimestamp</a>, <a href="../../../../java.sql/java/sql/resultset#getType()">getType</a>, <a href="../../../../java.sql/java/sql/resultset#getUnicodeStream(int)">getUnicodeStream</a>, <a href="../../../../java.sql/java/sql/resultset#getUnicodeStream(java.lang.String)">getUnicodeStream</a>, <a href="../../../../java.sql/java/sql/resultset#getURL(int)">getURL</a>, <a href="../../../../java.sql/java/sql/resultset#getURL(java.lang.String)">getURL</a>, <a href="../../../../java.sql/java/sql/resultset#getWarnings()">getWarnings</a>, <a href="../../../../java.sql/java/sql/resultset#insertRow()">insertRow</a>, <a href="../../../../java.sql/java/sql/resultset#isAfterLast()">isAfterLast</a>, <a href="../../../../java.sql/java/sql/resultset#isBeforeFirst()">isBeforeFirst</a>, <a href="../../../../java.sql/java/sql/resultset#isClosed()">isClosed</a>, <a href="../../../../java.sql/java/sql/resultset#isFirst()">isFirst</a>, <a href="../../../../java.sql/java/sql/resultset#isLast()">isLast</a>, <a href="../../../../java.sql/java/sql/resultset#last()">last</a>, <a href="../../../../java.sql/java/sql/resultset#moveToCurrentRow()">moveToCurrentRow</a>, <a href="../../../../java.sql/java/sql/resultset#moveToInsertRow()">moveToInsertRow</a>, <a href="../../../../java.sql/java/sql/resultset#next()">next</a>, <a href="../../../../java.sql/java/sql/resultset#previous()">previous</a>, <a href="../../../../java.sql/java/sql/resultset#refreshRow()">refreshRow</a>, <a href="../../../../java.sql/java/sql/resultset#relative(int)">relative</a>, <a href="../../../../java.sql/java/sql/resultset#rowDeleted()">rowDeleted</a>, <a href="../../../../java.sql/java/sql/resultset#rowInserted()">rowInserted</a>, <a href="../../../../java.sql/java/sql/resultset#rowUpdated()">rowUpdated</a>, <a href="../../../../java.sql/java/sql/resultset#setFetchDirection(int)">setFetchDirection</a>, <a href="../../../../java.sql/java/sql/resultset#setFetchSize(int)">setFetchSize</a>, <a href="../../../../java.sql/java/sql/resultset#updateArray(int,java.sql.Array)">updateArray</a>, <a href="../../../../java.sql/java/sql/resultset#updateArray(java.lang.String,java.sql.Array)">updateArray</a>, <a href="../../../../java.sql/java/sql/resultset#updateAsciiStream(int,java.io.InputStream)">updateAsciiStream</a>, <a href="../../../../java.sql/java/sql/resultset#updateAsciiStream(int,java.io.InputStream,int)">updateAsciiStream</a>, <a href="../../../../java.sql/java/sql/resultset#updateAsciiStream(int,java.io.InputStream,long)">updateAsciiStream</a>, <a href="../../../../java.sql/java/sql/resultset#updateAsciiStream(java.lang.String,java.io.InputStream)">updateAsciiStream</a>, <a href="../../../../java.sql/java/sql/resultset#updateAsciiStream(java.lang.String,java.io.InputStream,int)">updateAsciiStream</a>, <a href="../../../../java.sql/java/sql/resultset#updateAsciiStream(java.lang.String,java.io.InputStream,long)">updateAsciiStream</a>, <a href="../../../../java.sql/java/sql/resultset#updateBigDecimal(int,java.math.BigDecimal)">updateBigDecimal</a>, <a href="../../../../java.sql/java/sql/resultset#updateBigDecimal(java.lang.String,java.math.BigDecimal)">updateBigDecimal</a>, <a href="../../../../java.sql/java/sql/resultset#updateBinaryStream(int,java.io.InputStream)">updateBinaryStream</a>, <a href="../../../../java.sql/java/sql/resultset#updateBinaryStream(int,java.io.InputStream,int)">updateBinaryStream</a>, <a href="../../../../java.sql/java/sql/resultset#updateBinaryStream(int,java.io.InputStream,long)">updateBinaryStream</a>, <a href="../../../../java.sql/java/sql/resultset#updateBinaryStream(java.lang.String,java.io.InputStream)">updateBinaryStream</a>, <a href="../../../../java.sql/java/sql/resultset#updateBinaryStream(java.lang.String,java.io.InputStream,int)">updateBinaryStream</a>, <a href="../../../../java.sql/java/sql/resultset#updateBinaryStream(java.lang.String,java.io.InputStream,long)">updateBinaryStream</a>, <a href="../../../../java.sql/java/sql/resultset#updateBlob(int,java.io.InputStream)">updateBlob</a>, <a href="../../../../java.sql/java/sql/resultset#updateBlob(int,java.io.InputStream,long)">updateBlob</a>, <a href="../../../../java.sql/java/sql/resultset#updateBlob(int,java.sql.Blob)">updateBlob</a>, <a href="../../../../java.sql/java/sql/resultset#updateBlob(java.lang.String,java.io.InputStream)">updateBlob</a>, <a href="../../../../java.sql/java/sql/resultset#updateBlob(java.lang.String,java.io.InputStream,long)">updateBlob</a>, <a href="../../../../java.sql/java/sql/resultset#updateBlob(java.lang.String,java.sql.Blob)">updateBlob</a>, <a href="../../../../java.sql/java/sql/resultset#updateBoolean(int,boolean)">updateBoolean</a>, <a href="../../../../java.sql/java/sql/resultset#updateBoolean(java.lang.String,boolean)">updateBoolean</a>, <a href="../../../../java.sql/java/sql/resultset#updateByte(int,byte)">updateByte</a>, <a href="../../../../java.sql/java/sql/resultset#updateByte(java.lang.String,byte)">updateByte</a>, <a href="../../../../java.sql/java/sql/resultset#updateBytes(int,byte%5B%5D)">updateBytes</a>, <a href="../../../../java.sql/java/sql/resultset#updateBytes(java.lang.String,byte%5B%5D)">updateBytes</a>, <a href="../../../../java.sql/java/sql/resultset#updateCharacterStream(int,java.io.Reader)">updateCharacterStream</a>, <a href="../../../../java.sql/java/sql/resultset#updateCharacterStream(int,java.io.Reader,int)">updateCharacterStream</a>, <a href="../../../../java.sql/java/sql/resultset#updateCharacterStream(int,java.io.Reader,long)">updateCharacterStream</a>, <a href="../../../../java.sql/java/sql/resultset#updateCharacterStream(java.lang.String,java.io.Reader)">updateCharacterStream</a>, <a href="../../../../java.sql/java/sql/resultset#updateCharacterStream(java.lang.String,java.io.Reader,int)">updateCharacterStream</a>, <a href="../../../../java.sql/java/sql/resultset#updateCharacterStream(java.lang.String,java.io.Reader,long)">updateCharacterStream</a>, <a href="../../../../java.sql/java/sql/resultset#updateClob(int,java.io.Reader)">updateClob</a>, <a href="../../../../java.sql/java/sql/resultset#updateClob(int,java.io.Reader,long)">updateClob</a>, <a href="../../../../java.sql/java/sql/resultset#updateClob(int,java.sql.Clob)">updateClob</a>, <a href="../../../../java.sql/java/sql/resultset#updateClob(java.lang.String,java.io.Reader)">updateClob</a>, <a href="../../../../java.sql/java/sql/resultset#updateClob(java.lang.String,java.io.Reader,long)">updateClob</a>, <a href="../../../../java.sql/java/sql/resultset#updateClob(java.lang.String,java.sql.Clob)">updateClob</a>, <a href="../../../../java.sql/java/sql/resultset#updateDate(int,java.sql.Date)">updateDate</a>, <a href="../../../../java.sql/java/sql/resultset#updateDate(java.lang.String,java.sql.Date)">updateDate</a>, <a href="../../../../java.sql/java/sql/resultset#updateDouble(int,double)">updateDouble</a>, <a href="../../../../java.sql/java/sql/resultset#updateDouble(java.lang.String,double)">updateDouble</a>, <a href="../../../../java.sql/java/sql/resultset#updateFloat(int,float)">updateFloat</a>, <a href="../../../../java.sql/java/sql/resultset#updateFloat(java.lang.String,float)">updateFloat</a>, <a href="../../../../java.sql/java/sql/resultset#updateInt(int,int)">updateInt</a>, <a href="../../../../java.sql/java/sql/resultset#updateInt(java.lang.String,int)">updateInt</a>, <a href="../../../../java.sql/java/sql/resultset#updateLong(int,long)">updateLong</a>, <a href="../../../../java.sql/java/sql/resultset#updateLong(java.lang.String,long)">updateLong</a>, <a href="../../../../java.sql/java/sql/resultset#updateNCharacterStream(int,java.io.Reader)">updateNCharacterStream</a>, <a href="../../../../java.sql/java/sql/resultset#updateNCharacterStream(int,java.io.Reader,long)">updateNCharacterStream</a>, <a href="../../../../java.sql/java/sql/resultset#updateNCharacterStream(java.lang.String,java.io.Reader)">updateNCharacterStream</a>, <a href="../../../../java.sql/java/sql/resultset#updateNCharacterStream(java.lang.String,java.io.Reader,long)">updateNCharacterStream</a>, <a href="../../../../java.sql/java/sql/resultset#updateNClob(int,java.io.Reader)">updateNClob</a>, <a href="../../../../java.sql/java/sql/resultset#updateNClob(int,java.io.Reader,long)">updateNClob</a>, <a href="../../../../java.sql/java/sql/resultset#updateNClob(int,java.sql.NClob)">updateNClob</a>, <a href="../../../../java.sql/java/sql/resultset#updateNClob(java.lang.String,java.io.Reader)">updateNClob</a>, <a href="../../../../java.sql/java/sql/resultset#updateNClob(java.lang.String,java.io.Reader,long)">updateNClob</a>, <a href="../../../../java.sql/java/sql/resultset#updateNClob(java.lang.String,java.sql.NClob)">updateNClob</a>, <a href="../../../../java.sql/java/sql/resultset#updateNString(int,java.lang.String)">updateNString</a>, <a href="../../../../java.sql/java/sql/resultset#updateNString(java.lang.String,java.lang.String)">updateNString</a>, <a href="../../../../java.sql/java/sql/resultset#updateNull(int)">updateNull</a>, <a href="../../../../java.sql/java/sql/resultset#updateNull(java.lang.String)">updateNull</a>, <a href="../../../../java.sql/java/sql/resultset#updateObject(int,java.lang.Object)">updateObject</a>, <a href="../../../../java.sql/java/sql/resultset#updateObject(int,java.lang.Object,int)">updateObject</a>, <a href="../../../../java.sql/java/sql/resultset#updateObject(int,java.lang.Object,java.sql.SQLType)">updateObject</a>, <a href="../../../../java.sql/java/sql/resultset#updateObject(int,java.lang.Object,java.sql.SQLType,int)">updateObject</a>, <a href="../../../../java.sql/java/sql/resultset#updateObject(java.lang.String,java.lang.Object)">updateObject</a>, <a href="../../../../java.sql/java/sql/resultset#updateObject(java.lang.String,java.lang.Object,int)">updateObject</a>, <a href="../../../../java.sql/java/sql/resultset#updateObject(java.lang.String,java.lang.Object,java.sql.SQLType)">updateObject</a>, <a href="../../../../java.sql/java/sql/resultset#updateObject(java.lang.String,java.lang.Object,java.sql.SQLType,int)">updateObject</a>, <a href="../../../../java.sql/java/sql/resultset#updateRef(int,java.sql.Ref)">updateRef</a>, <a href="../../../../java.sql/java/sql/resultset#updateRef(java.lang.String,java.sql.Ref)">updateRef</a>, <a href="../../../../java.sql/java/sql/resultset#updateRow()">updateRow</a>, <a href="../../../../java.sql/java/sql/resultset#updateRowId(int,java.sql.RowId)">updateRowId</a>, <a href="../../../../java.sql/java/sql/resultset#updateRowId(java.lang.String,java.sql.RowId)">updateRowId</a>, <a href="../../../../java.sql/java/sql/resultset#updateShort(int,short)">updateShort</a>, <a href="../../../../java.sql/java/sql/resultset#updateShort(java.lang.String,short)">updateShort</a>, <a href="../../../../java.sql/java/sql/resultset#updateSQLXML(int,java.sql.SQLXML)">updateSQLXML</a>, <a href="../../../../java.sql/java/sql/resultset#updateSQLXML(java.lang.String,java.sql.SQLXML)">updateSQLXML</a>, <a href="../../../../java.sql/java/sql/resultset#updateString(int,java.lang.String)">updateString</a>, <a href="../../../../java.sql/java/sql/resultset#updateString(java.lang.String,java.lang.String)">updateString</a>, <a href="../../../../java.sql/java/sql/resultset#updateTime(int,java.sql.Time)">updateTime</a>, <a href="../../../../java.sql/java/sql/resultset#updateTime(java.lang.String,java.sql.Time)">updateTime</a>, <a href="../../../../java.sql/java/sql/resultset#updateTimestamp(int,java.sql.Timestamp)">updateTimestamp</a>, <a href="../../../../java.sql/java/sql/resultset#updateTimestamp(java.lang.String,java.sql.Timestamp)">updateTimestamp</a>, <a href="../../../../java.sql/java/sql/resultset#wasNull()">wasNull</a></code>  <h2 id="methods.inherited.from.class.javax.sql.RowSet">Methods declared in interface javax.sql.<a href="../../../../java.sql/javax/sql/rowset">RowSet</a>
</h2> <code><a href="../../../../java.sql/javax/sql/rowset#addRowSetListener(javax.sql.RowSetListener)">addRowSetListener</a>, <a href="../../../../java.sql/javax/sql/rowset#clearParameters()">clearParameters</a>, <a href="../../../../java.sql/javax/sql/rowset#execute()">execute</a>, <a href="../../../../java.sql/javax/sql/rowset#getCommand()">getCommand</a>, <a href="../../../../java.sql/javax/sql/rowset#getDataSourceName()">getDataSourceName</a>, <a href="../../../../java.sql/javax/sql/rowset#getEscapeProcessing()">getEscapeProcessing</a>, <a href="../../../../java.sql/javax/sql/rowset#getMaxFieldSize()">getMaxFieldSize</a>, <a href="../../../../java.sql/javax/sql/rowset#getMaxRows()">getMaxRows</a>, <a href="../../../../java.sql/javax/sql/rowset#getPassword()">getPassword</a>, <a href="../../../../java.sql/javax/sql/rowset#getQueryTimeout()">getQueryTimeout</a>, <a href="../../../../java.sql/javax/sql/rowset#getTransactionIsolation()">getTransactionIsolation</a>, <a href="../../../../java.sql/javax/sql/rowset#getTypeMap()">getTypeMap</a>, <a href="../../../../java.sql/javax/sql/rowset#getUrl()">getUrl</a>, <a href="../../../../java.sql/javax/sql/rowset#getUsername()">getUsername</a>, <a href="../../../../java.sql/javax/sql/rowset#isReadOnly()">isReadOnly</a>, <a href="../../../../java.sql/javax/sql/rowset#removeRowSetListener(javax.sql.RowSetListener)">removeRowSetListener</a>, <a href="../../../../java.sql/javax/sql/rowset#setArray(int,java.sql.Array)">setArray</a>, <a href="../../../../java.sql/javax/sql/rowset#setAsciiStream(int,java.io.InputStream)">setAsciiStream</a>, <a href="../../../../java.sql/javax/sql/rowset#setAsciiStream(int,java.io.InputStream,int)">setAsciiStream</a>, <a href="../../../../java.sql/javax/sql/rowset#setAsciiStream(java.lang.String,java.io.InputStream)">setAsciiStream</a>, <a href="../../../../java.sql/javax/sql/rowset#setAsciiStream(java.lang.String,java.io.InputStream,int)">setAsciiStream</a>, <a href="../../../../java.sql/javax/sql/rowset#setBigDecimal(int,java.math.BigDecimal)">setBigDecimal</a>, <a href="../../../../java.sql/javax/sql/rowset#setBigDecimal(java.lang.String,java.math.BigDecimal)">setBigDecimal</a>, <a href="../../../../java.sql/javax/sql/rowset#setBinaryStream(int,java.io.InputStream)">setBinaryStream</a>, <a href="../../../../java.sql/javax/sql/rowset#setBinaryStream(int,java.io.InputStream,int)">setBinaryStream</a>, <a href="../../../../java.sql/javax/sql/rowset#setBinaryStream(java.lang.String,java.io.InputStream)">setBinaryStream</a>, <a href="../../../../java.sql/javax/sql/rowset#setBinaryStream(java.lang.String,java.io.InputStream,int)">setBinaryStream</a>, <a href="../../../../java.sql/javax/sql/rowset#setBlob(int,java.io.InputStream)">setBlob</a>, <a href="../../../../java.sql/javax/sql/rowset#setBlob(int,java.io.InputStream,long)">setBlob</a>, <a href="../../../../java.sql/javax/sql/rowset#setBlob(int,java.sql.Blob)">setBlob</a>, <a href="../../../../java.sql/javax/sql/rowset#setBlob(java.lang.String,java.io.InputStream)">setBlob</a>, <a href="../../../../java.sql/javax/sql/rowset#setBlob(java.lang.String,java.io.InputStream,long)">setBlob</a>, <a href="../../../../java.sql/javax/sql/rowset#setBlob(java.lang.String,java.sql.Blob)">setBlob</a>, <a href="../../../../java.sql/javax/sql/rowset#setBoolean(int,boolean)">setBoolean</a>, <a href="../../../../java.sql/javax/sql/rowset#setBoolean(java.lang.String,boolean)">setBoolean</a>, <a href="../../../../java.sql/javax/sql/rowset#setByte(int,byte)">setByte</a>, <a href="../../../../java.sql/javax/sql/rowset#setByte(java.lang.String,byte)">setByte</a>, <a href="../../../../java.sql/javax/sql/rowset#setBytes(int,byte%5B%5D)">setBytes</a>, <a href="../../../../java.sql/javax/sql/rowset#setBytes(java.lang.String,byte%5B%5D)">setBytes</a>, <a href="../../../../java.sql/javax/sql/rowset#setCharacterStream(int,java.io.Reader)">setCharacterStream</a>, <a href="../../../../java.sql/javax/sql/rowset#setCharacterStream(int,java.io.Reader,int)">setCharacterStream</a>, <a href="../../../../java.sql/javax/sql/rowset#setCharacterStream(java.lang.String,java.io.Reader)">setCharacterStream</a>, <a href="../../../../java.sql/javax/sql/rowset#setCharacterStream(java.lang.String,java.io.Reader,int)">setCharacterStream</a>, <a href="../../../../java.sql/javax/sql/rowset#setClob(int,java.io.Reader)">setClob</a>, <a href="../../../../java.sql/javax/sql/rowset#setClob(int,java.io.Reader,long)">setClob</a>, <a href="../../../../java.sql/javax/sql/rowset#setClob(int,java.sql.Clob)">setClob</a>, <a href="../../../../java.sql/javax/sql/rowset#setClob(java.lang.String,java.io.Reader)">setClob</a>, <a href="../../../../java.sql/javax/sql/rowset#setClob(java.lang.String,java.io.Reader,long)">setClob</a>, <a href="../../../../java.sql/javax/sql/rowset#setClob(java.lang.String,java.sql.Clob)">setClob</a>, <a href="../../../../java.sql/javax/sql/rowset#setCommand(java.lang.String)">setCommand</a>, <a href="../../../../java.sql/javax/sql/rowset#setConcurrency(int)">setConcurrency</a>, <a href="../../../../java.sql/javax/sql/rowset#setDataSourceName(java.lang.String)">setDataSourceName</a>, <a href="../../../../java.sql/javax/sql/rowset#setDate(int,java.sql.Date)">setDate</a>, <a href="../../../../java.sql/javax/sql/rowset#setDate(int,java.sql.Date,java.util.Calendar)">setDate</a>, <a href="../../../../java.sql/javax/sql/rowset#setDate(java.lang.String,java.sql.Date)">setDate</a>, <a href="../../../../java.sql/javax/sql/rowset#setDate(java.lang.String,java.sql.Date,java.util.Calendar)">setDate</a>, <a href="../../../../java.sql/javax/sql/rowset#setDouble(int,double)">setDouble</a>, <a href="../../../../java.sql/javax/sql/rowset#setDouble(java.lang.String,double)">setDouble</a>, <a href="../../../../java.sql/javax/sql/rowset#setEscapeProcessing(boolean)">setEscapeProcessing</a>, <a href="../../../../java.sql/javax/sql/rowset#setFloat(int,float)">setFloat</a>, <a href="../../../../java.sql/javax/sql/rowset#setFloat(java.lang.String,float)">setFloat</a>, <a href="../../../../java.sql/javax/sql/rowset#setInt(int,int)">setInt</a>, <a href="../../../../java.sql/javax/sql/rowset#setInt(java.lang.String,int)">setInt</a>, <a href="../../../../java.sql/javax/sql/rowset#setLong(int,long)">setLong</a>, <a href="../../../../java.sql/javax/sql/rowset#setLong(java.lang.String,long)">setLong</a>, <a href="../../../../java.sql/javax/sql/rowset#setMaxFieldSize(int)">setMaxFieldSize</a>, <a href="../../../../java.sql/javax/sql/rowset#setMaxRows(int)">setMaxRows</a>, <a href="../../../../java.sql/javax/sql/rowset#setNCharacterStream(int,java.io.Reader)">setNCharacterStream</a>, <a href="../../../../java.sql/javax/sql/rowset#setNCharacterStream(int,java.io.Reader,long)">setNCharacterStream</a>, <a href="../../../../java.sql/javax/sql/rowset#setNCharacterStream(java.lang.String,java.io.Reader)">setNCharacterStream</a>, <a href="../../../../java.sql/javax/sql/rowset#setNCharacterStream(java.lang.String,java.io.Reader,long)">setNCharacterStream</a>, <a href="../../../../java.sql/javax/sql/rowset#setNClob(int,java.io.Reader)">setNClob</a>, <a href="../../../../java.sql/javax/sql/rowset#setNClob(int,java.io.Reader,long)">setNClob</a>, <a href="../../../../java.sql/javax/sql/rowset#setNClob(int,java.sql.NClob)">setNClob</a>, <a href="../../../../java.sql/javax/sql/rowset#setNClob(java.lang.String,java.io.Reader)">setNClob</a>, <a href="../../../../java.sql/javax/sql/rowset#setNClob(java.lang.String,java.io.Reader,long)">setNClob</a>, <a href="../../../../java.sql/javax/sql/rowset#setNClob(java.lang.String,java.sql.NClob)">setNClob</a>, <a href="../../../../java.sql/javax/sql/rowset#setNString(int,java.lang.String)">setNString</a>, <a href="../../../../java.sql/javax/sql/rowset#setNString(java.lang.String,java.lang.String)">setNString</a>, <a href="../../../../java.sql/javax/sql/rowset#setNull(int,int)">setNull</a>, <a href="../../../../java.sql/javax/sql/rowset#setNull(int,int,java.lang.String)">setNull</a>, <a href="../../../../java.sql/javax/sql/rowset#setNull(java.lang.String,int)">setNull</a>, <a href="../../../../java.sql/javax/sql/rowset#setNull(java.lang.String,int,java.lang.String)">setNull</a>, <a href="../../../../java.sql/javax/sql/rowset#setObject(int,java.lang.Object)">setObject</a>, <a href="../../../../java.sql/javax/sql/rowset#setObject(int,java.lang.Object,int)">setObject</a>, <a href="../../../../java.sql/javax/sql/rowset#setObject(int,java.lang.Object,int,int)">setObject</a>, <a href="../../../../java.sql/javax/sql/rowset#setObject(java.lang.String,java.lang.Object)">setObject</a>, <a href="../../../../java.sql/javax/sql/rowset#setObject(java.lang.String,java.lang.Object,int)">setObject</a>, <a href="../../../../java.sql/javax/sql/rowset#setObject(java.lang.String,java.lang.Object,int,int)">setObject</a>, <a href="../../../../java.sql/javax/sql/rowset#setPassword(java.lang.String)">setPassword</a>, <a href="../../../../java.sql/javax/sql/rowset#setQueryTimeout(int)">setQueryTimeout</a>, <a href="../../../../java.sql/javax/sql/rowset#setReadOnly(boolean)">setReadOnly</a>, <a href="../../../../java.sql/javax/sql/rowset#setRef(int,java.sql.Ref)">setRef</a>, <a href="../../../../java.sql/javax/sql/rowset#setRowId(int,java.sql.RowId)">setRowId</a>, <a href="../../../../java.sql/javax/sql/rowset#setRowId(java.lang.String,java.sql.RowId)">setRowId</a>, <a href="../../../../java.sql/javax/sql/rowset#setShort(int,short)">setShort</a>, <a href="../../../../java.sql/javax/sql/rowset#setShort(java.lang.String,short)">setShort</a>, <a href="../../../../java.sql/javax/sql/rowset#setSQLXML(int,java.sql.SQLXML)">setSQLXML</a>, <a href="../../../../java.sql/javax/sql/rowset#setSQLXML(java.lang.String,java.sql.SQLXML)">setSQLXML</a>, <a href="../../../../java.sql/javax/sql/rowset#setString(int,java.lang.String)">setString</a>, <a href="../../../../java.sql/javax/sql/rowset#setString(java.lang.String,java.lang.String)">setString</a>, <a href="../../../../java.sql/javax/sql/rowset#setTime(int,java.sql.Time)">setTime</a>, <a href="../../../../java.sql/javax/sql/rowset#setTime(int,java.sql.Time,java.util.Calendar)">setTime</a>, <a href="../../../../java.sql/javax/sql/rowset#setTime(java.lang.String,java.sql.Time)">setTime</a>, <a href="../../../../java.sql/javax/sql/rowset#setTime(java.lang.String,java.sql.Time,java.util.Calendar)">setTime</a>, <a href="../../../../java.sql/javax/sql/rowset#setTimestamp(int,java.sql.Timestamp)">setTimestamp</a>, <a href="../../../../java.sql/javax/sql/rowset#setTimestamp(int,java.sql.Timestamp,java.util.Calendar)">setTimestamp</a>, <a href="../../../../java.sql/javax/sql/rowset#setTimestamp(java.lang.String,java.sql.Timestamp)">setTimestamp</a>, <a href="../../../../java.sql/javax/sql/rowset#setTimestamp(java.lang.String,java.sql.Timestamp,java.util.Calendar)">setTimestamp</a>, <a href="../../../../java.sql/javax/sql/rowset#setTransactionIsolation(int)">setTransactionIsolation</a>, <a href="../../../../java.sql/javax/sql/rowset#setType(int)">setType</a>, <a href="../../../../java.sql/javax/sql/rowset#setTypeMap(java.util.Map)">setTypeMap</a>, <a href="../../../../java.sql/javax/sql/rowset#setUrl(java.lang.String)">setUrl</a>, <a href="../../../../java.sql/javax/sql/rowset#setURL(int,java.net.URL)">setURL</a>, <a href="../../../../java.sql/javax/sql/rowset#setUsername(java.lang.String)">setUsername</a></code>  <h2 id="methods.inherited.from.class.java.sql.Wrapper">Methods declared in interface java.sql.<a href="../../../../java.sql/java/sql/wrapper">Wrapper</a>
</h2> <code><a href="../../../../java.sql/java/sql/wrapper#isWrapperFor(java.lang.Class)">isWrapperFor</a>, <a href="../../../../java.sql/java/sql/wrapper#unwrap(java.lang.Class)">unwrap</a></code>  </section>   <div>   <section role="region">  <h2 id="field.detail">Fields</h2>   <h3 id="COMMIT_ON_ACCEPT_CHANGES">COMMIT_ON_ACCEPT_CHANGES</h3> <pre data-language="java">@Deprecated
static finalÂ boolean COMMIT_ON_ACCEPT_CHANGES</pre> <div>
<strong>Deprecated.</strong> <div>Because this field is final (it is part of an interface), its value cannot be changed.</div> </div> <p>Causes the <code>CachedRowSet</code> object's <code>SyncProvider</code> to commit the changes when <code>acceptChanges()</code> is called. If set to false, the changes will <b>not</b> be committed until one of the <code>CachedRowSet</code> interface transaction methods is called.</p> <dl> <dt>See Also:</dt> <dd>
<a href="#commit()"><code>commit()</code></a>, <a href="#rollback()"><code>rollback()</code></a>, <a href="https://docs.oracle.com/en/java/javase/11/docs/api/constant-values.html#javax.sql.rowset.CachedRowSet.COMMIT_ON_ACCEPT_CHANGES">Constant Field Values</a>
</dd> </dl>   </section>  <section role="region">  <h2 id="method.detail">Methods</h2>   <h3 id="populate(java.sql.ResultSet)">populate</h3> <pre data-language="java">voidÂ populate(ResultSetÂ data)
       throws SQLException</pre> <div>
<p>Populates this <code>CachedRowSet</code> object with data from the given <code>ResultSet</code> object. </p>
<p> This method can be used as an alternative to the <code>execute</code> method when an application has a connection to an open <code>ResultSet</code> object. Using the method <code>populate</code> can be more efficient than using the version of the <code>execute</code> method that takes no parameters because it does not open a new connection and re-execute this <code>CachedRowSet</code> object's command. Using the <code>populate</code> method is more a matter of convenience when compared to using the version of <code>execute</code> that takes a <code>ResultSet</code> object.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>data</code> - the <code>ResultSet</code> object containing the data to be read into this <code>CachedRowSet</code> object</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.sql/java/sql/sqlexception">SQLException</a></code> - if a null <code>ResultSet</code> object is supplied or this <code>CachedRowSet</code> object cannot retrieve the associated <code>ResultSetMetaData</code> object</dd> <dt>See Also:</dt> <dd>
<a href="#execute(java.sql.Connection)"><code>execute(java.sql.Connection)</code></a>, <a href="../../../../java.sql/java/sql/resultset"><code>ResultSet</code></a>, <a href="../../../../java.sql/java/sql/resultsetmetadata"><code>ResultSetMetaData</code></a>
</dd> </dl>    <h3 id="execute(java.sql.Connection)">execute</h3> <pre data-language="java">voidÂ execute(ConnectionÂ conn)
      throws SQLException</pre> <div>
<p>Populates this <code>CachedRowSet</code> object with data, using the given connection to produce the result set from which the data will be read. This method should close any database connections that it creates to ensure that this <code>CachedRowSet</code> object is disconnected except when it is reading data from its data source or writing data to its data source. </p>
<p> The reader for this <code>CachedRowSet</code> object will use <i>conn</i> to establish a connection to the data source so that it can execute the rowset's command and read data from the the resulting <code>ResultSet</code> object into this <code>CachedRowSet</code> object. This method also closes <i>conn</i> after it has populated this <code>CachedRowSet</code> object. </p>
<p> If this method is called when an implementation has already been populated, the contents and the metadata are (re)set. Also, if this method is called before the method <code>acceptChanges</code> has been called to commit outstanding updates, those updates are lost.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>conn</code> - a standard JDBC <code>Connection</code> object with valid properties</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.sql/java/sql/sqlexception">SQLException</a></code> - if an invalid <code>Connection</code> object is supplied or an error occurs in establishing the connection to the data source</dd> <dt>See Also:</dt> <dd>
<a href="#populate(java.sql.ResultSet)"><code>populate(java.sql.ResultSet)</code></a>, <a href="../../../../java.sql/java/sql/connection"><code>Connection</code></a>
</dd> </dl>    <h3 id="acceptChanges()">acceptChanges</h3> <pre data-language="java">voidÂ acceptChanges()
            throws SyncProviderException</pre> <div>
<p>Propagates row update, insert and delete changes made to this <code>CachedRowSet</code> object to the underlying data source. </p>
<p> This method calls on this <code>CachedRowSet</code> object's writer to do the work behind the scenes. Standard <code>CachedRowSet</code> implementations should use the <code>SyncFactory</code> singleton to obtain a <code>SyncProvider</code> instance providing a <code>RowSetWriter</code> object (writer). The writer will attempt to propagate changes made in this <code>CachedRowSet</code> object back to the data source. </p>
<p> When the method <code>acceptChanges</code> executes successfully, in addition to writing changes to the data source, it makes the values in the current row be the values in the original row. </p>
<p> Depending on the synchronization level of the <code>SyncProvider</code> implementation being used, the writer will compare the original values with those in the data source to check for conflicts. When there is a conflict, the <code>RIOptimisticProvider</code> implementation, for example, throws a <code>SyncProviderException</code> and does not write anything to the data source. </p>
<p> An application may choose to catch the <code>SyncProviderException</code> object and retrieve the <code>SyncResolver</code> object it contains. The <code>SyncResolver</code> object lists the conflicts row by row and sets a lock on the data source to avoid further conflicts while the current conflicts are being resolved. Further, for each conflict, it provides methods for examining the conflict and setting the value that should be persisted in the data source. After all conflicts have been resolved, an application must call the <code>acceptChanges</code> method again to write resolved values to the data source. If all of the values in the data source are already the values to be persisted, the method <code>acceptChanges</code> does nothing. </p>
<p> Some provider implementations may use locks to ensure that there are no conflicts. In such cases, it is guaranteed that the writer will succeed in writing changes to the data source when the method <code>acceptChanges</code> is called. This method may be called immediately after the methods <code>updateRow</code>, <code>insertRow</code>, or <code>deleteRow</code> have been called, but it is more efficient to call it only once after all changes have been made so that only one connection needs to be established. </p>
<p> Note: The <code>acceptChanges()</code> method will determine if the <code>COMMIT_ON_ACCEPT_CHANGES</code> is set to true or not. If it is set to true, all updates in the synchronization are committed to the data source. Otherwise, the application <b>must</b> explicitly call the <code>commit()</code> or <code>rollback()</code> methods as appropriate.</p>
</div> <dl> <dt>Throws:</dt> <dd>
<code><a href="spi/syncproviderexception">SyncProviderException</a></code> - if the underlying synchronization provider's writer fails to write the updates back to the data source</dd> <dt>See Also:</dt> <dd>
<a href="#acceptChanges(java.sql.Connection)"><code>acceptChanges(java.sql.Connection)</code></a>, <a href="../../../../java.sql/javax/sql/rowsetwriter"><code>RowSetWriter</code></a>, <a href="spi/syncfactory"><code>SyncFactory</code></a>, <a href="spi/syncprovider"><code>SyncProvider</code></a>, <a href="spi/syncproviderexception"><code>SyncProviderException</code></a>, <a href="spi/syncresolver"><code>SyncResolver</code></a>
</dd> </dl>    <h3 id="acceptChanges(java.sql.Connection)">acceptChanges</h3> <pre data-language="java">voidÂ acceptChanges(ConnectionÂ con)
            throws SyncProviderException</pre> <div>
<p>Propagates all row update, insert and delete changes to the data source backing this <code>CachedRowSet</code> object using the specified <code>Connection</code> object to establish a connection to the data source. </p>
<p> The other version of the <code>acceptChanges</code> method is not passed a connection because it uses the <code>Connection</code> object already defined within the <code>RowSet</code> object, which is the connection used for populating it initially. </p>
<p> This form of the method <code>acceptChanges</code> is similar to the form that takes no arguments; however, unlike the other form, this form can be used only when the underlying data source is a JDBC data source. The updated <code>Connection</code> properties must be used by the <code>SyncProvider</code> to reset the <code>RowSetWriter</code> configuration to ensure that the contents of the <code>CachedRowSet</code> object are synchronized correctly. </p>
<p> When the method <code>acceptChanges</code> executes successfully, in addition to writing changes to the data source, it makes the values in the current row be the values in the original row. </p>
<p> Depending on the synchronization level of the <code>SyncProvider</code> implementation being used, the writer will compare the original values with those in the data source to check for conflicts. When there is a conflict, the <code>RIOptimisticProvider</code> implementation, for example, throws a <code>SyncProviderException</code> and does not write anything to the data source. </p>
<p> An application may choose to catch the <code>SyncProviderException</code> object and retrieve the <code>SyncResolver</code> object it contains. The <code>SyncResolver</code> object lists the conflicts row by row and sets a lock on the data source to avoid further conflicts while the current conflicts are being resolved. Further, for each conflict, it provides methods for examining the conflict and setting the value that should be persisted in the data source. After all conflicts have been resolved, an application must call the <code>acceptChanges</code> method again to write resolved values to the data source. If all of the values in the data source are already the values to be persisted, the method <code>acceptChanges</code> does nothing. </p>
<p> Some provider implementations may use locks to ensure that there are no conflicts. In such cases, it is guaranteed that the writer will succeed in writing changes to the data source when the method <code>acceptChanges</code> is called. This method may be called immediately after the methods <code>updateRow</code>, <code>insertRow</code>, or <code>deleteRow</code> have been called, but it is more efficient to call it only once after all changes have been made so that only one connection needs to be established. </p>
<p> Note: The <code>acceptChanges()</code> method will determine if the <code>COMMIT_ON_ACCEPT_CHANGES</code> is set to true or not. If it is set to true, all updates in the synchronization are committed to the data source. Otherwise, the application <b>must</b> explicitly call the <code>commit</code> or <code>rollback</code> methods as appropriate.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>con</code> - a standard JDBC <code>Connection</code> object</dd> <dt>Throws:</dt> <dd>
<code><a href="spi/syncproviderexception">SyncProviderException</a></code> - if the underlying synchronization provider's writer fails to write the updates back to the data source</dd> <dt>See Also:</dt> <dd>
<a href="#acceptChanges()"><code>acceptChanges()</code></a>, <a href="../../../../java.sql/javax/sql/rowsetwriter"><code>RowSetWriter</code></a>, <a href="spi/syncfactory"><code>SyncFactory</code></a>, <a href="spi/syncprovider"><code>SyncProvider</code></a>, <a href="spi/syncproviderexception"><code>SyncProviderException</code></a>, <a href="spi/syncresolver"><code>SyncResolver</code></a>
</dd> </dl>    <h3 id="restoreOriginal()">restoreOriginal</h3> <pre data-language="java">voidÂ restoreOriginal()
              throws SQLException</pre> <div>
<p>Restores this <code>CachedRowSet</code> object to its original value, that is, its value before the last set of changes. If there have been no changes to the rowset or only one set of changes, the original value is the value with which this <code>CachedRowSet</code> object was populated; otherwise, the original value is the value it had immediately before its current value. </p>
<p> When this method is called, a <code>CachedRowSet</code> implementation must ensure that all updates, inserts, and deletes to the current rowset instance are replaced by the previous values. In addition, the cursor should be reset to the first row and a <code>rowSetChanged</code> event should be fired to notify all registered listeners.</p>
</div> <dl> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.sql/java/sql/sqlexception">SQLException</a></code> - if an error occurs rolling back the current value of this <code>CachedRowSet</code> object to its previous value</dd> <dt>See Also:</dt> <dd><a href="../../../../java.sql/javax/sql/rowsetlistener#rowSetChanged(javax.sql.RowSetEvent)"><code>RowSetListener.rowSetChanged(javax.sql.RowSetEvent)</code></a></dd> </dl>    <h3 id="release()">release</h3> <pre data-language="java">voidÂ release()
      throws SQLException</pre> <div>
<p>Releases the current contents of this <code>CachedRowSet</code> object and sends a <code>rowSetChanged</code> event to all registered listeners. Any outstanding updates are discarded and the rowset contains no rows after this method is called. There are no interactions with the underlying data source, and any rowset content, metadata, and content updates should be non-recoverable. </p>
<p> This <code>CachedRowSet</code> object should lock until its contents and associated updates are fully cleared, thus preventing 'dirty' reads by other components that hold a reference to this <code>RowSet</code> object. In addition, the contents cannot be released until all components reading this <code>CachedRowSet</code> object have completed their reads. This <code>CachedRowSet</code> object should be returned to normal behavior after firing the <code>rowSetChanged</code> event. </p>
<p> The metadata, including JDBC properties and Synchronization SPI properties, are maintained for future use. It is important that properties such as the <code>command</code> property be relevant to the originating data source from which this <code>CachedRowSet</code> object was originally established. </p>
<p> This method empties a rowset, as opposed to the <code>close</code> method, which marks the entire rowset as recoverable to allow the garbage collector the rowset's Java VM resources.</p>
</div> <dl> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.sql/java/sql/sqlexception">SQLException</a></code> - if an error occurs flushing the contents of this <code>CachedRowSet</code> object</dd> <dt>See Also:</dt> <dd>
<a href="../../../../java.sql/javax/sql/rowsetlistener#rowSetChanged(javax.sql.RowSetEvent)"><code>RowSetListener.rowSetChanged(javax.sql.RowSetEvent)</code></a>, <a href="../../../../java.sql/java/sql/resultset#close()"><code>ResultSet.close()</code></a>
</dd> </dl>    <h3 id="undoDelete()">undoDelete</h3> <pre data-language="java">voidÂ undoDelete()
         throws SQLException</pre> <div>
<p>Cancels the deletion of the current row and notifies listeners that a row has changed. After this method is called, the current row is no longer marked for deletion. This method can be called at any time during the lifetime of the rowset. </p>
<p> In addition, multiple cancellations of row deletions can be made by adjusting the position of the cursor using any of the cursor position control methods such as: </p>
<ul> <li>
<code>CachedRowSet.absolute</code> </li>
<li>
<code>CachedRowSet.first</code> </li>
<li>
<code>CachedRowSet.last</code> </li>
</ul>
</div> <dl> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.sql/java/sql/sqlexception">SQLException</a></code> - if (1) the current row has not been deleted or (2) the cursor is on the insert row, before the first row, or after the last row</dd> <dt>See Also:</dt> <dd>
<a href="#undoInsert()"><code>undoInsert()</code></a>, <a href="../../../../java.sql/java/sql/resultset#cancelRowUpdates()"><code>ResultSet.cancelRowUpdates()</code></a>
</dd> </dl>    <h3 id="undoInsert()">undoInsert</h3> <pre data-language="java">voidÂ undoInsert()
         throws SQLException</pre> <div>
<p>Immediately removes the current row from this <code>CachedRowSet</code> object if the row has been inserted, and also notifies listeners that a row has changed. This method can be called at any time during the lifetime of a rowset and assuming the current row is within the exception limitations (see below), it cancels the row insertion of the current row. </p>
<p> In addition, multiple cancellations of row insertions can be made by adjusting the position of the cursor using any of the cursor position control methods such as: </p>
<ul> <li>
<code>CachedRowSet.absolute</code> </li>
<li>
<code>CachedRowSet.first</code> </li>
<li>
<code>CachedRowSet.last</code> </li>
</ul>
</div> <dl> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.sql/java/sql/sqlexception">SQLException</a></code> - if (1) the current row has not been inserted or (2) the cursor is before the first row, after the last row, or on the insert row</dd> <dt>See Also:</dt> <dd>
<a href="#undoDelete()"><code>undoDelete()</code></a>, <a href="../../../../java.sql/java/sql/resultset#cancelRowUpdates()"><code>ResultSet.cancelRowUpdates()</code></a>
</dd> </dl>    <h3 id="undoUpdate()">undoUpdate</h3> <pre data-language="java">voidÂ undoUpdate()
         throws SQLException</pre> <div>
<p>Immediately reverses the last update operation if the row has been modified. This method can be called to reverse updates on all columns until all updates in a row have been rolled back to their state just prior to the last synchronization (<code>acceptChanges</code>) or population. This method may also be called while performing updates to the insert row. </p>
<p> <code>undoUpdate</code> may be called at any time during the lifetime of a rowset; however, after a synchronization has occurred, this method has no effect until further modification to the rowset data has occurred.</p>
</div> <dl> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.sql/java/sql/sqlexception">SQLException</a></code> - if the cursor is before the first row or after the last row in this <code>CachedRowSet</code> object</dd> <dt>See Also:</dt> <dd>
<a href="#undoDelete()"><code>undoDelete()</code></a>, <a href="#undoInsert()"><code>undoInsert()</code></a>, <a href="../../../../java.sql/java/sql/resultset#cancelRowUpdates()"><code>ResultSet.cancelRowUpdates()</code></a>
</dd> </dl>    <h3 id="columnUpdated(int)">columnUpdated</h3> <pre data-language="java">booleanÂ columnUpdated(intÂ idx)
               throws SQLException</pre> <p>Indicates whether the designated column in the current row of this <code>CachedRowSet</code> object has been updated.</p> <dl> <dt>Parameters:</dt> <dd>
<code>idx</code> - an <code>int</code> identifying the column to be checked for updates</dd> <dt>Returns:</dt> <dd>
<code>true</code> if the designated column has been visibly updated; <code>false</code> otherwise</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.sql/java/sql/sqlexception">SQLException</a></code> - if the cursor is on the insert row, before the first row, or after the last row</dd> <dt>See Also:</dt> <dd><a href="../../../../java.sql/java/sql/databasemetadata#updatesAreDetected(int)"><code>DatabaseMetaData.updatesAreDetected(int)</code></a></dd> </dl>    <h3 id="columnUpdated(java.lang.String)">columnUpdated</h3> <pre data-language="java">booleanÂ columnUpdated(StringÂ columnName)
               throws SQLException</pre> <p>Indicates whether the designated column in the current row of this <code>CachedRowSet</code> object has been updated.</p> <dl> <dt>Parameters:</dt> <dd>
<code>columnName</code> - a <code>String</code> object giving the name of the column to be checked for updates</dd> <dt>Returns:</dt> <dd>
<code>true</code> if the column has been visibly updated; <code>false</code> otherwise</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.sql/java/sql/sqlexception">SQLException</a></code> - if the cursor is on the insert row, before the first row, or after the last row</dd> <dt>See Also:</dt> <dd><a href="../../../../java.sql/java/sql/databasemetadata#updatesAreDetected(int)"><code>DatabaseMetaData.updatesAreDetected(int)</code></a></dd> </dl>    <h3 id="toCollection()">toCollection</h3> <pre data-language="java">Collection&lt;?&gt;Â toCollection()
                    throws SQLException</pre> <div>
<p>Converts this <code>CachedRowSet</code> object to a <code>Collection</code> object that contains all of this <code>CachedRowSet</code> object's data. Implementations have some latitude in how they can represent this <code>Collection</code> object because of the abstract nature of the <code>Collection</code> framework. Each row must be fully represented in either a general purpose <code>Collection</code> implementation or a specialized <code>Collection</code> implementation, such as a <code>TreeMap</code> object or a <code>Vector</code> object. An SQL <code>NULL</code> column value must be represented as a <code>null</code> in the Java programming language. </p>
<p> The standard reference implementation for the <code>CachedRowSet</code> interface uses a <code>TreeMap</code> object for the rowset, with the values in each row being contained in <code>Vector</code> objects. It is expected that most implementations will do the same. </p>
<p> The <code>TreeMap</code> type of collection guarantees that the map will be in ascending key order, sorted according to the natural order for the key's class. Each key references a <code>Vector</code> object that corresponds to one row of a <code>RowSet</code> object. Therefore, the size of each <code>Vector</code> object must be exactly equal to the number of columns in the <code>RowSet</code> object. The key used by the <code>TreeMap</code> collection is determined by the implementation, which may choose to leverage a set key that is available within the internal <code>RowSet</code> tabular structure by virtue of a key already set either on the <code>RowSet</code> object itself or on the underlying SQL data.</p>
</div> <dl> <dt>Returns:</dt> <dd>a <code>Collection</code> object that contains the values in each row in this <code>CachedRowSet</code> object</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.sql/java/sql/sqlexception">SQLException</a></code> - if an error occurs generating the collection</dd> <dt>See Also:</dt> <dd>
<a href="#toCollection(int)"><code>toCollection(int)</code></a>, <a href="#toCollection(java.lang.String)"><code>toCollection(String)</code></a>
</dd> </dl>    <h3 id="toCollection(int)">toCollection</h3> <pre data-language="java">Collection&lt;?&gt;Â toCollection(intÂ column)
                    throws SQLException</pre> <div>
<p>Converts the designated column in this <code>CachedRowSet</code> object to a <code>Collection</code> object. Implementations have some latitude in how they can represent this <code>Collection</code> object because of the abstract nature of the <code>Collection</code> framework. Each column value should be fully represented in either a general purpose <code>Collection</code> implementation or a specialized <code>Collection</code> implementation, such as a <code>Vector</code> object. An SQL <code>NULL</code> column value must be represented as a <code>null</code> in the Java programming language. </p>
<p> The standard reference implementation uses a <code>Vector</code> object to contain the column values, and it is expected that most implementations will do the same. If a <code>Vector</code> object is used, it size must be exactly equal to the number of rows in this <code>CachedRowSet</code> object.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>column</code> - an <code>int</code> indicating the column whose values are to be represented in a <code>Collection</code> object</dd> <dt>Returns:</dt> <dd>a <code>Collection</code> object that contains the values stored in the specified column of this <code>CachedRowSet</code> object</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.sql/java/sql/sqlexception">SQLException</a></code> - if an error occurs generating the collection or an invalid column id is provided</dd> <dt>See Also:</dt> <dd>
<a href="#toCollection()"><code>toCollection()</code></a>, <a href="#toCollection(java.lang.String)"><code>toCollection(String)</code></a>
</dd> </dl>    <h3 id="toCollection(java.lang.String)">toCollection</h3> <pre data-language="java">Collection&lt;?&gt;Â toCollection(StringÂ column)
                    throws SQLException</pre> <div>
<p>Converts the designated column in this <code>CachedRowSet</code> object to a <code>Collection</code> object. Implementations have some latitude in how they can represent this <code>Collection</code> object because of the abstract nature of the <code>Collection</code> framework. Each column value should be fully represented in either a general purpose <code>Collection</code> implementation or a specialized <code>Collection</code> implementation, such as a <code>Vector</code> object. An SQL <code>NULL</code> column value must be represented as a <code>null</code> in the Java programming language. </p>
<p> The standard reference implementation uses a <code>Vector</code> object to contain the column values, and it is expected that most implementations will do the same. If a <code>Vector</code> object is used, it size must be exactly equal to the number of rows in this <code>CachedRowSet</code> object.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>column</code> - a <code>String</code> object giving the name of the column whose values are to be represented in a collection</dd> <dt>Returns:</dt> <dd>a <code>Collection</code> object that contains the values stored in the specified column of this <code>CachedRowSet</code> object</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.sql/java/sql/sqlexception">SQLException</a></code> - if an error occurs generating the collection or an invalid column id is provided</dd> <dt>See Also:</dt> <dd>
<a href="#toCollection()"><code>toCollection()</code></a>, <a href="#toCollection(int)"><code>toCollection(int)</code></a>
</dd> </dl>    <h3 id="getSyncProvider()">getSyncProvider</h3> <pre data-language="java">SyncProviderÂ getSyncProvider()
                      throws SQLException</pre> <div>
<p>Retrieves the <code>SyncProvider</code> implementation for this <code>CachedRowSet</code> object. Internally, this method is used by a rowset to trigger read or write actions between the rowset and the data source. For example, a rowset may need to get a handle on the rowset reader (<code>RowSetReader</code> object) from the <code>SyncProvider</code> to allow the rowset to be populated. <pre data-language="java">RowSetReader rowsetReader = null;
     SyncProvider provider =
         SyncFactory.getInstance("javax.sql.rowset.provider.RIOptimisticProvider");
         if (provider instanceof RIOptimisticProvider) {
             rowsetReader = provider.getRowSetReader();
         }</pre> Assuming <i>rowsetReader</i> is a private, accessible field within the rowset implementation, when an application calls the <code>execute</code> method, it in turn calls on the reader's <code>readData</code> method to populate the <code>RowSet</code> object. <pre data-language="java">rowsetReader.readData((RowSetInternal)this);</pre> </p>
<p> In addition, an application can use the <code>SyncProvider</code> object returned by this method to call methods that return information about the <code>SyncProvider</code> object, including information about the vendor, version, provider identification, synchronization grade, and locks it currently has set.</p>
</div> <dl> <dt>Returns:</dt> <dd>the <code>SyncProvider</code> object that was set when the rowset was instantiated, or if none was set, the default provider</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.sql/java/sql/sqlexception">SQLException</a></code> - if an error occurs while returning the <code>SyncProvider</code> object</dd> <dt>See Also:</dt> <dd><a href="#setSyncProvider(java.lang.String)"><code>setSyncProvider(java.lang.String)</code></a></dd> </dl>    <h3 id="setSyncProvider(java.lang.String)">setSyncProvider</h3> <pre data-language="java">voidÂ setSyncProvider(StringÂ provider)
              throws SQLException</pre> <div>
<p>Sets the <code>SyncProvider</code> object for this <code>CachedRowSet</code> object to the one specified. This method allows the <code>SyncProvider</code> object to be reset. </p>
<p> A <code>CachedRowSet</code> implementation should always be instantiated with an available <code>SyncProvider</code> mechanism, but there are cases where resetting the <code>SyncProvider</code> object is desirable or necessary. For example, an application might want to use the default <code>SyncProvider</code> object for a time and then choose to use a provider that has more recently become available and better fits its needs. </p>
<p> Resetting the <code>SyncProvider</code> object causes the <code>RowSet</code> object to request a new <code>SyncProvider</code> implementation from the <code>SyncFactory</code>. This has the effect of resetting all previous connections and relationships with the originating data source and can potentially drastically change the synchronization behavior of a disconnected rowset.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>provider</code> - a <code>String</code> object giving the fully qualified class name of a <code>SyncProvider</code> implementation</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.sql/java/sql/sqlexception">SQLException</a></code> - if an error occurs while attempting to reset the <code>SyncProvider</code> implementation</dd> <dt>See Also:</dt> <dd><a href="#getSyncProvider()"><code>getSyncProvider()</code></a></dd> </dl>    <h3 id="size()">size</h3> <pre data-language="java">intÂ size()</pre> <p>Returns the number of rows in this <code>CachedRowSet</code> object.</p> <dl> <dt>Returns:</dt> <dd>number of rows in the rowset</dd> </dl>    <h3 id="setMetaData(javax.sql.RowSetMetaData)">setMetaData</h3> <pre data-language="java">voidÂ setMetaData(RowSetMetaDataÂ md)
          throws SQLException</pre> <p>Sets the metadata for this <code>CachedRowSet</code> object with the given <code>RowSetMetaData</code> object. When a <code>RowSetReader</code> object is reading the contents of a rowset, it creates a <code>RowSetMetaData</code> object and initializes it using the methods in the <code>RowSetMetaData</code> implementation. The reference implementation uses the <code>RowSetMetaDataImpl</code> class. When the reader has completed reading the rowset contents, this method is called internally to pass the <code>RowSetMetaData</code> object to the rowset.</p> <dl> <dt>Parameters:</dt> <dd>
<code>md</code> - a <code>RowSetMetaData</code> object containing metadata about the columns in this <code>CachedRowSet</code> object</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.sql/java/sql/sqlexception">SQLException</a></code> - if invalid metadata is supplied to the rowset</dd> </dl>    <h3 id="getOriginal()">getOriginal</h3> <pre data-language="java">ResultSetÂ getOriginal()
               throws SQLException</pre> <div>
<p>Returns a <code>ResultSet</code> object containing the original value of this <code>CachedRowSet</code> object. </p>
<p> The cursor for the <code>ResultSet</code> object should be positioned before the first row. In addition, the returned <code>ResultSet</code> object should have the following properties: </p>
<ul> <li>ResultSet.TYPE_SCROLL_INSENSITIVE </li>
<li>ResultSet.CONCUR_UPDATABLE </li>
</ul> <p> The original value for a <code>RowSet</code> object is the value it had before the last synchronization with the underlying data source. If there have been no synchronizations, the original value will be the value with which the <code>RowSet</code> object was populated. This method is called internally when an application calls the method <code>acceptChanges</code> and the <code>SyncProvider</code> object has been implemented to check for conflicts. If this is the case, the writer compares the original value with the value currently in the data source to check for conflicts.</p>
</div> <dl> <dt>Returns:</dt> <dd>a <code>ResultSet</code> object that contains the original value for this <code>CachedRowSet</code> object</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.sql/java/sql/sqlexception">SQLException</a></code> - if an error occurs producing the <code>ResultSet</code> object</dd> </dl>    <h3 id="getOriginalRow()">getOriginalRow</h3> <pre data-language="java">ResultSetÂ getOriginalRow()
                  throws SQLException</pre> <div>
<p>Returns a <code>ResultSet</code> object containing the original value for the current row only of this <code>CachedRowSet</code> object. </p>
<p> The cursor for the <code>ResultSet</code> object should be positioned before the first row. In addition, the returned <code>ResultSet</code> object should have the following properties: </p>
<ul> <li>ResultSet.TYPE_SCROLL_INSENSITIVE </li>
<li>ResultSet.CONCUR_UPDATABLE </li>
</ul>
</div> <dl> <dt>Returns:</dt> <dd>the original result set of the row</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.sql/java/sql/sqlexception">SQLException</a></code> - if there is no current row</dd> <dt>See Also:</dt> <dd><a href="#setOriginalRow()"><code>setOriginalRow()</code></a></dd> </dl>    <h3 id="setOriginalRow()">setOriginalRow</h3> <pre data-language="java">voidÂ setOriginalRow()
             throws SQLException</pre> <div>
<p>Sets the current row in this <code>CachedRowSet</code> object as the original row. </p>
<p> This method is called internally after the any modified values in the current row have been synchronized with the data source. The current row must be tagged as no longer inserted, deleted or updated. </p>
<p> A call to <code>setOriginalRow</code> is irreversible.</p>
</div> <dl> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.sql/java/sql/sqlexception">SQLException</a></code> - if there is no current row or an error is encountered resetting the contents of the original row</dd> <dt>See Also:</dt> <dd><a href="#getOriginalRow()"><code>getOriginalRow()</code></a></dd> </dl>    <h3 id="getTableName()">getTableName</h3> <pre data-language="java">StringÂ getTableName()
             throws SQLException</pre> <p>Returns an identifier for the object (table) that was used to create this <code>CachedRowSet</code> object. This name may be set on multiple occasions, and the specification imposes no limits on how many times this may occur or whether standard implementations should keep track of previous table names.</p> <dl> <dt>Returns:</dt> <dd>a <code>String</code> object giving the name of the table that is the source of data for this <code>CachedRowSet</code> object or <code>null</code> if no name has been set for the table</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.sql/java/sql/sqlexception">SQLException</a></code> - if an error is encountered returning the table name</dd> <dt>See Also:</dt> <dd><a href="../../../../java.sql/java/sql/resultsetmetadata#getTableName(int)"><code>ResultSetMetaData.getTableName(int)</code></a></dd> </dl>    <h3 id="setTableName(java.lang.String)">setTableName</h3> <pre data-language="java">voidÂ setTableName(StringÂ tabName)
           throws SQLException</pre> <div>
<p>Sets the identifier for the table from which this <code>CachedRowSet</code> object was derived to the given table name. The writer uses this name to determine which table to use when comparing the values in the data source with the <code>CachedRowSet</code> object's values during a synchronization attempt. The table identifier also indicates where modified values from this <code>CachedRowSet</code> object should be written. </p>
<p> The implementation of this <code>CachedRowSet</code> object may obtain the the name internally from the <code>RowSetMetaDataImpl</code> object.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>tabName</code> - a <code>String</code> object identifying the table from which this <code>CachedRowSet</code> object was derived; cannot be <code>null</code> but may be an empty string</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.sql/java/sql/sqlexception">SQLException</a></code> - if an error is encountered naming the table or <i>tabName</i> is <code>null</code>
</dd> <dt>See Also:</dt> <dd>
<a href="../../../../java.sql/javax/sql/rowsetmetadata#setTableName(int,java.lang.String)"><code>RowSetMetaData.setTableName(int, java.lang.String)</code></a>, <a href="../../../../java.sql/javax/sql/rowsetwriter"><code>RowSetWriter</code></a>, <a href="spi/syncprovider"><code>SyncProvider</code></a>
</dd> </dl>    <h3 id="getKeyColumns()">getKeyColumns</h3> <pre data-language="java">int[]Â getKeyColumns()
             throws SQLException</pre> <p>Returns an array containing one or more column numbers indicating the columns that form a key that uniquely identifies a row in this <code>CachedRowSet</code> object.</p> <dl> <dt>Returns:</dt> <dd>an array containing the column number or numbers that indicate which columns constitute a primary key for a row in this <code>CachedRowSet</code> object. This array should be empty if no columns are representative of a primary key.</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.sql/java/sql/sqlexception">SQLException</a></code> - if this <code>CachedRowSet</code> object is empty</dd> <dt>See Also:</dt> <dd>
<a href="#setKeyColumns(int%5B%5D)"><code>setKeyColumns(int[])</code></a>, <a href="joinable#getMatchColumnIndexes()"><code>Joinable.getMatchColumnIndexes()</code></a>, <a href="joinable#getMatchColumnNames()"><code>Joinable.getMatchColumnNames()</code></a>
</dd> </dl>    <h3 id="setKeyColumns(int[])">setKeyColumns</h3> <pre data-language="java">voidÂ setKeyColumns(int[]Â keys)
            throws SQLException</pre> <div>
<p>Sets this <code>CachedRowSet</code> object's <code>keyCols</code> field with the given array of column numbers, which forms a key for uniquely identifying a row in this <code>CachedRowSet</code> object. </p>
<p> If a <code>CachedRowSet</code> object becomes part of a <code>JoinRowSet</code> object, the keys defined by this method and the resulting constraints are maintained if the columns designated as key columns also become match columns.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>keys</code> - an array of <code>int</code> indicating the columns that form a primary key for this <code>CachedRowSet</code> object; every element in the array must be greater than <code>0</code> and less than or equal to the number of columns in this rowset</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.sql/java/sql/sqlexception">SQLException</a></code> - if any of the numbers in the given array are not valid for this rowset</dd> <dt>See Also:</dt> <dd>
<a href="#getKeyColumns()"><code>getKeyColumns()</code></a>, <a href="joinable#setMatchColumn(java.lang.String)"><code>Joinable.setMatchColumn(String)</code></a>, <a href="joinable#setMatchColumn(int)"><code>Joinable.setMatchColumn(int)</code></a>
</dd> </dl>    <h3 id="createShared()">createShared</h3> <pre data-language="java">RowSetÂ createShared()
             throws SQLException</pre> <div>
<p>Returns a new <code>RowSet</code> object backed by the same data as that of this <code>CachedRowSet</code> object. In effect, both <code>CachedRowSet</code> objects have a cursor over the same data. As a result, any changes made by a duplicate are visible to the original and to any other duplicates, just as a change made by the original is visible to all of its duplicates. If a duplicate calls a method that changes the underlying data, the method it calls notifies all registered listeners just as it would when it is called by the original <code>CachedRowSet</code> object. </p>
<p> In addition, any <code>RowSet</code> object created by this method will have the same properties as this <code>CachedRowSet</code> object. For example, if this <code>CachedRowSet</code> object is read-only, all of its duplicates will also be read-only. If it is changed to be updatable, the duplicates also become updatable. </p>
<p> NOTE: If multiple threads access <code>RowSet</code> objects created from the <code>createShared()</code> method, the following behavior is specified to preserve shared data integrity: reads and writes of all shared <code>RowSet</code> objects should be made serially between each object and the single underlying tabular structure.</p>
</div> <dl> <dt>Returns:</dt> <dd>a new shared <code>RowSet</code> object that has the same properties as this <code>CachedRowSet</code> object and that has a cursor over the same data</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.sql/java/sql/sqlexception">SQLException</a></code> - if an error occurs or cloning is not supported in the underlying platform</dd> <dt>See Also:</dt> <dd>
<a href="../../../../java.sql/javax/sql/rowsetevent"><code>RowSetEvent</code></a>, <a href="../../../../java.sql/javax/sql/rowsetlistener"><code>RowSetListener</code></a>
</dd> </dl>    <h3 id="createCopy()">createCopy</h3> <pre data-language="java">CachedRowSetÂ createCopy()
                 throws SQLException</pre> <p>Creates a <code>RowSet</code> object that is a deep copy of the data in this <code>CachedRowSet</code> object. In contrast to the <code>RowSet</code> object generated from a <code>createShared</code> call, updates made to the copy of the original <code>RowSet</code> object must not be visible to the original <code>RowSet</code> object. Also, any event listeners that are registered with the original <code>RowSet</code> must not have scope over the new <code>RowSet</code> copies. In addition, any constraint restrictions established must be maintained.</p> <dl> <dt>Returns:</dt> <dd>a new <code>RowSet</code> object that is a deep copy of this <code>CachedRowSet</code> object and is completely independent of this <code>CachedRowSet</code> object</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.sql/java/sql/sqlexception">SQLException</a></code> - if an error occurs in generating the copy of the of this <code>CachedRowSet</code> object</dd> <dt>See Also:</dt> <dd>
<a href="#createShared()"><code>createShared()</code></a>, <a href="#createCopySchema()"><code>createCopySchema()</code></a>, <a href="#createCopyNoConstraints()"><code>createCopyNoConstraints()</code></a>, <a href="../../../../java.sql/javax/sql/rowsetevent"><code>RowSetEvent</code></a>, <a href="../../../../java.sql/javax/sql/rowsetlistener"><code>RowSetListener</code></a>
</dd> </dl>    <h3 id="createCopySchema()">createCopySchema</h3> <pre data-language="java">CachedRowSetÂ createCopySchema()
                       throws SQLException</pre> <div>
<p>Creates a <code>CachedRowSet</code> object that is an empty copy of this <code>CachedRowSet</code> object. The copy must not contain any contents but only represent the table structure of the original <code>CachedRowSet</code> object. In addition, primary or foreign key constraints set in the originating <code>CachedRowSet</code> object must be equally enforced in the new empty <code>CachedRowSet</code> object. In contrast to the <code>RowSet</code> object generated from a <code>createShared</code> method call, updates made to a copy of this <code>CachedRowSet</code> object with the <code>createCopySchema</code> method must not be visible to it. </p>
<p> Applications can form a <code>WebRowSet</code> object from the <code>CachedRowSet</code> object returned by this method in order to export the <code>RowSet</code> schema definition to XML for future use.</p>
</div> <dl> <dt>Returns:</dt> <dd>An empty copy of this <code>CachedRowSet</code> object</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.sql/java/sql/sqlexception">SQLException</a></code> - if an error occurs in cloning the structure of this <code>CachedRowSet</code> object</dd> <dt>See Also:</dt> <dd>
<a href="#createShared()"><code>createShared()</code></a>, <a href="#createCopySchema()"><code>createCopySchema()</code></a>, <a href="#createCopyNoConstraints()"><code>createCopyNoConstraints()</code></a>, <a href="../../../../java.sql/javax/sql/rowsetevent"><code>RowSetEvent</code></a>, <a href="../../../../java.sql/javax/sql/rowsetlistener"><code>RowSetListener</code></a>
</dd> </dl>    <h3 id="createCopyNoConstraints()">createCopyNoConstraints</h3> <pre data-language="java">CachedRowSetÂ createCopyNoConstraints()
                              throws SQLException</pre> <p>Creates a <code>CachedRowSet</code> object that is a deep copy of this <code>CachedRowSet</code> object's data but is independent of it. In contrast to the <code>RowSet</code> object generated from a <code>createShared</code> method call, updates made to a copy of this <code>CachedRowSet</code> object must not be visible to it. Also, any event listeners that are registered with this <code>CachedRowSet</code> object must not have scope over the new <code>RowSet</code> object. In addition, any constraint restrictions established for this <code>CachedRowSet</code> object must <b>not</b> be maintained in the copy.</p> <dl> <dt>Returns:</dt> <dd>a new <code>CachedRowSet</code> object that is a deep copy of this <code>CachedRowSet</code> object and is completely independent of this <code>CachedRowSet</code> object</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.sql/java/sql/sqlexception">SQLException</a></code> - if an error occurs in generating the copy of the of this <code>CachedRowSet</code> object</dd> <dt>See Also:</dt> <dd>
<a href="#createCopy()"><code>createCopy()</code></a>, <a href="#createShared()"><code>createShared()</code></a>, <a href="#createCopySchema()"><code>createCopySchema()</code></a>, <a href="../../../../java.sql/javax/sql/rowsetevent"><code>RowSetEvent</code></a>, <a href="../../../../java.sql/javax/sql/rowsetlistener"><code>RowSetListener</code></a>
</dd> </dl>    <h3 id="getRowSetWarnings()">getRowSetWarnings</h3> <pre data-language="java">RowSetWarningÂ getRowSetWarnings()
                         throws SQLException</pre> <p>Retrieves the first warning reported by calls on this <code>RowSet</code> object. Subsequent warnings on this <code>RowSet</code> object will be chained to the <code>RowSetWarning</code> object that this method returns. The warning chain is automatically cleared each time a new row is read. This method may not be called on a RowSet object that has been closed; doing so will cause a <code>SQLException</code> to be thrown.</p> <dl> <dt>Returns:</dt> <dd>RowSetWarning the first <code>RowSetWarning</code> object reported or null if there are none</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.sql/java/sql/sqlexception">SQLException</a></code> - if this method is called on a closed RowSet</dd> <dt>See Also:</dt> <dd><a href="rowsetwarning"><code>RowSetWarning</code></a></dd> </dl>    <h3 id="getShowDeleted()">getShowDeleted</h3> <pre data-language="java">booleanÂ getShowDeleted()
                throws SQLException</pre> <div>
<p>Retrieves a <code>boolean</code> indicating whether rows marked for deletion appear in the set of current rows. If <code>true</code> is returned, deleted rows are visible with the current rows. If <code>false</code> is returned, rows are not visible with the set of current rows. The default value is <code>false</code>. </p>
<p> Standard rowset implementations may choose to restrict this behavior due to security considerations or to better fit certain deployment scenarios. This is left as implementation defined and does not represent standard behavior. </p>
<p> Note: Allowing deleted rows to remain visible complicates the behavior of some standard JDBC <code>RowSet</code> Implementations methods. However, most rowset users can simply ignore this extra detail because only very specialized applications will likely want to take advantage of this feature.</p>
</div> <dl> <dt>Returns:</dt> <dd>
<code>true</code> if deleted rows are visible; <code>false</code> otherwise</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.sql/java/sql/sqlexception">SQLException</a></code> - if a rowset implementation is unable to to determine whether rows marked for deletion are visible</dd> <dt>See Also:</dt> <dd><a href="#setShowDeleted(boolean)"><code>setShowDeleted(boolean)</code></a></dd> </dl>    <h3 id="setShowDeleted(boolean)">setShowDeleted</h3> <pre data-language="java">voidÂ setShowDeleted(booleanÂ b)
             throws SQLException</pre> <div>
<p>Sets the property <code>showDeleted</code> to the given <code>boolean</code> value, which determines whether rows marked for deletion appear in the set of current rows. If the value is set to <code>true</code>, deleted rows are immediately visible with the set of current rows. If the value is set to <code>false</code>, the deleted rows are set as invisible with the current set of rows. </p>
<p> Standard rowset implementations may choose to restrict this behavior due to security considerations or to better fit certain deployment scenarios. This is left as implementations defined and does not represent standard behavior.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>b</code> - <code>true</code> if deleted rows should be shown; <code>false</code> otherwise</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.sql/java/sql/sqlexception">SQLException</a></code> - if a rowset implementation is unable to to reset whether deleted rows should be visible</dd> <dt>See Also:</dt> <dd><a href="#getShowDeleted()"><code>getShowDeleted()</code></a></dd> </dl>    <h3 id="commit()">commit</h3> <pre data-language="java">voidÂ commit()
     throws SQLException</pre> <div>
<p>Each <code>CachedRowSet</code> object's <code>SyncProvider</code> contains a <code>Connection</code> object from the <code>ResultSet</code> or JDBC properties passed to it's constructors. This method wraps the <code>Connection</code> commit method to allow flexible auto commit or non auto commit transactional control support. </p>
<p> Makes all changes that are performed by the <code>acceptChanges()</code> method since the previous commit/rollback permanent. This method should be used only when auto-commit mode has been disabled.</p>
</div> <dl> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.sql/java/sql/sqlexception">SQLException</a></code> - if a database access error occurs or this Connection object within this <code>CachedRowSet</code> is in auto-commit mode</dd> <dt>See Also:</dt> <dd><a href="../../../../java.sql/java/sql/connection#setAutoCommit(boolean)"><code>Connection.setAutoCommit(boolean)</code></a></dd> </dl>    <h3 id="rollback()">rollback</h3> <pre data-language="java">voidÂ rollback()
       throws SQLException</pre> <div>
<p>Each <code>CachedRowSet</code> object's <code>SyncProvider</code> contains a <code>Connection</code> object from the original <code>ResultSet</code> or JDBC properties passed to it. </p>
<p> Undoes all changes made in the current transaction. This method should be used only when auto-commit mode has been disabled.</p>
</div> <dl> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.sql/java/sql/sqlexception">SQLException</a></code> - if a database access error occurs or this Connection object within this <code>CachedRowSet</code> is in auto-commit mode.</dd> </dl>    <h3 id="rollback(java.sql.Savepoint)">rollback</h3> <pre data-language="java">voidÂ rollback(SavepointÂ s)
       throws SQLException</pre> <div>
<p>Each <code>CachedRowSet</code> object's <code>SyncProvider</code> contains a <code>Connection</code> object from the original <code>ResultSet</code> or JDBC properties passed to it. </p>
<p> Undoes all changes made in the current transaction back to the last <code>Savepoint</code> transaction marker. This method should be used only when auto-commit mode has been disabled.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>s</code> - A <code>Savepoint</code> transaction marker</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.sql/java/sql/sqlexception">SQLException</a></code> - if a database access error occurs or this Connection object within this <code>CachedRowSet</code> is in auto-commit mode.</dd> </dl>    <h3 id="rowSetPopulated(javax.sql.RowSetEvent,int)">rowSetPopulated</h3> <pre data-language="java">voidÂ rowSetPopulated(RowSetEventÂ event,
                     intÂ numRows)
              throws SQLException</pre> <div>
<p>Notifies registered listeners that a RowSet object in the given RowSetEvent object has populated a number of additional rows. The <code>numRows</code> parameter ensures that this event will only be fired every <code>numRow</code>. </p>
<p> The source of the event can be retrieved with the method event.getSource.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>event</code> - a <code>RowSetEvent</code> object that contains the <code>RowSet</code> object that is the source of the events</dd> <dd>
<code>numRows</code> - when populating, the number of rows interval on which the <code>CachedRowSet</code> populated should fire; the default value is zero; cannot be less than <code>fetchSize</code> or zero</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.sql/java/sql/sqlexception">SQLException</a></code> - <code>numRows &lt; 0 or numRows &lt; getFetchSize() </code>
</dd> </dl>    <h3 id="populate(java.sql.ResultSet,int)">populate</h3> <pre data-language="java">voidÂ populate(ResultSetÂ rs,
              intÂ startRow)
       throws SQLException</pre> <div>
<p>Populates this <code>CachedRowSet</code> object with data from the given <code>ResultSet</code> object. While related to the <code>populate(ResultSet)</code> method, an additional parameter is provided to allow starting position within the <code>ResultSet</code> from where to populate the CachedRowSet instance. </p>
<p> This method can be used as an alternative to the <code>execute</code> method when an application has a connection to an open <code>ResultSet</code> object. Using the method <code>populate</code> can be more efficient than using the version of the <code>execute</code> method that takes no parameters because it does not open a new connection and re-execute this <code>CachedRowSet</code> object's command. Using the <code>populate</code> method is more a matter of convenience when compared to using the version of <code>execute</code> that takes a <code>ResultSet</code> object.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>startRow</code> - the position in the <code>ResultSet</code> from where to start populating the records in this <code>CachedRowSet</code>
</dd> <dd>
<code>rs</code> - the <code>ResultSet</code> object containing the data to be read into this <code>CachedRowSet</code> object</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.sql/java/sql/sqlexception">SQLException</a></code> - if a null <code>ResultSet</code> object is supplied or this <code>CachedRowSet</code> object cannot retrieve the associated <code>ResultSetMetaData</code> object</dd> <dt>See Also:</dt> <dd>
<a href="#execute(java.sql.Connection)"><code>execute(java.sql.Connection)</code></a>, <a href="#populate(java.sql.ResultSet)"><code>populate(ResultSet)</code></a>, <a href="../../../../java.sql/java/sql/resultset"><code>ResultSet</code></a>, <a href="../../../../java.sql/java/sql/resultsetmetadata"><code>ResultSetMetaData</code></a>
</dd> </dl>    <h3 id="setPageSize(int)">setPageSize</h3> <pre data-language="java">voidÂ setPageSize(intÂ size)
          throws SQLException</pre> <p>Sets the <code>CachedRowSet</code> object's page-size. A <code>CachedRowSet</code> may be configured to populate itself in page-size sized batches of rows. When either <code>populate()</code> or <code>execute()</code> are called, the <code>CachedRowSet</code> fetches an additional page according to the original SQL query used to populate the RowSet.</p> <dl> <dt>Parameters:</dt> <dd>
<code>size</code> - the page-size of the <code>CachedRowSet</code>
</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.sql/java/sql/sqlexception">SQLException</a></code> - if an error occurs setting the <code>CachedRowSet</code> page size or if the page size is less than 0.</dd> </dl>    <h3 id="getPageSize()">getPageSize</h3> <pre data-language="java">intÂ getPageSize()</pre> <p>Returns the page-size for the <code>CachedRowSet</code> object</p> <dl> <dt>Returns:</dt> <dd>an <code>int</code> page size</dd> </dl>    <h3 id="nextPage()">nextPage</h3> <pre data-language="java">booleanÂ nextPage()
          throws SQLException</pre> <p>Increments the current page of the <code>CachedRowSet</code>. This causes the <code>CachedRowSet</code> implementation to fetch the next page-size rows and populate the RowSet, if remaining rows remain within scope of the original SQL query used to populated the RowSet.</p> <dl> <dt>Returns:</dt> <dd>true if more pages exist; false if this is the last page</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.sql/java/sql/sqlexception">SQLException</a></code> - if an error occurs fetching the next page, or if this method is called prematurely before populate or execute.</dd> </dl>    <h3 id="previousPage()">previousPage</h3> <pre data-language="java">booleanÂ previousPage()
              throws SQLException</pre> <p>Decrements the current page of the <code>CachedRowSet</code>. This causes the <code>CachedRowSet</code> implementation to fetch the previous page-size rows and populate the RowSet. The amount of rows returned in the previous page must always remain within scope of the original SQL query used to populate the RowSet.</p> <dl> <dt>Returns:</dt> <dd>true if the previous page is successfully retrieved; false if this is the first page.</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.sql/java/sql/sqlexception">SQLException</a></code> - if an error occurs fetching the previous page, or if this method is called prematurely before populate or execute.</dd> </dl>   </section>  </div>  </main>  <div class="_attribution">
  <p class="_attribution-p">
    &copy; 1993, 2020, Oracle and/or its affiliates. All rights reserved.<br>Documentation extracted from Debian's OpenJDK Development Kit package.<br>Licensed under the GNU General Public License, version 2, with the Classpath Exception.<br>Various third party code in OpenJDK is licensed under different licenses (see Debian package).<br>Java and OpenJDK are trademarks or registered trademarks of Oracle and/or its affiliates.<br>
    <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.sql.rowset/javax/sql/rowset/CachedRowSet.html" class="_attribution-link">https://docs.oracle.com/en/java/javase/11/docs/api/java.sql.rowset/javax/sql/rowset/CachedRowSet.html</a>
  </p>
</div>
