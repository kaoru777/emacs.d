  <main role="main">    <h1>Interface VirtualMachineManager</h1>      <pre data-language="java">public interface VirtualMachineManager</pre> <div>
<p>A manager of connections to target virtual machines. The VirtualMachineManager allows one application to debug multiple target VMs. (Note that the converse is not supported; a target VM can be debugged by only one debugger application.) This interface contains methods to manage connections to remote target VMs and to obtain the <a href="virtualmachine"><code>VirtualMachine</code></a> mirror for available target VMs. </p>
<p> Connections can be made using one of several different <a href="connect/connector"><code>Connector</code></a> objects. Each connector encapsulates a different way of connecting the debugger with a target VM. </p>
<p> The VirtualMachineManager supports many different scenarios for connecting a debugger to a virtual machine. Four examples are presented in the table below. The examples use the command line syntax in Sun's implementation. Some <a href="connect/connector"><code>Connector</code></a> implementations may require slightly different handling than presented below. </p>
<table>  <thead> <tr> <th scope="col">Scenario</th> <th scope="col">Description</th> </tr>
</thead>  <tr> <th scope="row">Debugger launches target VM (simplest, most-common scenario)</th> <td>Debugger calls the <a href="connect/launchingconnector#launch(java.util.Map)"><code>LaunchingConnector.launch(java.util.Map)</code></a> method of the default connector, obtained with <a href="#defaultConnector()"><code>defaultConnector()</code></a>. The target VM is launched, and a connection between that VM and the debugger is established. A <a href="virtualmachine"><code>VirtualMachine</code></a> mirror is returned. <p>Or, for more control </p>
<ul> <li> Debugger selects a connector from the list returned by <a href="#launchingConnectors()"><code>launchingConnectors()</code></a> with desired characteristics (for example, transport type, etc.). </li>
<li> Debugger calls the <a href="connect/launchingconnector#launch(java.util.Map)"><code>LaunchingConnector.launch(java.util.Map)</code></a> method of the selected connector. The target VM is launched, and a connection between that VM and the debugger is established. A <a href="virtualmachine"><code>VirtualMachine</code></a> mirror is returned. </li>
</ul> </td> </tr> <tr> <th scope="row">Debugger attaches to previously-running VM</th> <td> <ul> <li> Target VM is launched using the options <code>-agentlib:jdwp=transport=xxx,server=y</code> </li> <li> Target VM generates and outputs the tranport-specific address at which it will listen for a connection.</li> <li> Debugger is launched. Debugger selects a connector in the list returned by <a href="#attachingConnectors()"><code>attachingConnectors()</code></a> matching the transport with the name "xxx". </li>
<li> Debugger presents the default connector parameters (obtained through <a href="connect/connector#defaultArguments()"><code>Connector.defaultArguments()</code></a>) to the end user, allowing the user to fill in the transport-specific address generated by the target VM. </li>
<li> Debugger calls the <a href="connect/attachingconnector#attach(java.util.Map)"><code>AttachingConnector.attach(java.util.Map)</code></a> method of the selected to attach to the target VM. A <a href="virtualmachine"><code>VirtualMachine</code></a> mirror is returned. </li>
</ul> </td> </tr> <tr> <th scope="row">Target VM attaches to previously-running debugger</th> <td> <ul> <li> At startup, debugger selects one or more connectors from the list returned by <a href="#listeningConnectors()"><code>listeningConnectors()</code></a> for one or more transports.</li> <li> Debugger calls the <a href="connect/listeningconnector#startListening(java.util.Map)"><code>ListeningConnector.startListening(java.util.Map)</code></a> method for each selected connector. For each call, a transport-specific address string is generated and returned. The debugger makes the transport names and corresponding address strings available to the end user. </li>
<li> Debugger calls <a href="connect/listeningconnector#accept(java.util.Map)"><code>ListeningConnector.accept(java.util.Map)</code></a> for each selected connector to wait for a target VM to connect.</li> <li> Later, target VM is launched by end user with the options <code>-agentlib:jdwp=transport=xxx,address=yyy</code> where "xxx" the transport for one of the connectors selected by the the debugger and "yyy" is the address generated by <a href="connect/listeningconnector#accept(java.util.Map)"><code>ListeningConnector.accept(java.util.Map)</code></a> for that transport.</li> <li> Debugger's call to <a href="connect/listeningconnector#accept(java.util.Map)"><code>ListeningConnector.accept(java.util.Map)</code></a> returns a <a href="virtualmachine"><code>VirtualMachine</code></a> mirror.</li> </ul> </td> </tr> <tr> <th scope="row">Target VM launches debugger (sometimes called "Just-In-Time" debugging)</th> <td> <ul> <li> Target VM is launched with the options <code>-agentlib:jdwp=launch=cmdline,onuncaught=y,transport=xxx,server=y</code> </li> <li> Later, an uncaught exception is thrown in the target VM. The target VM generates the tranport-specific address at which it will listen for a connection. </li>
<li>Target VM launches the debugger with the following items concatenated together (separated by spaces) to form the command line: <ul> <li> The launch= value </li>
<li> The transport= value </li>
<li> The generated transport-specific address at which VM is listening for debugger connection. </li>
</ul> </li>
<li> Upon launch, debugger selects a connector in the list returned by <a href="#attachingConnectors()"><code>attachingConnectors()</code></a> matching the transport with the name "xxx". </li>
<li> Debugger changes the default connector parameters (obtained through <a href="connect/connector#defaultArguments()"><code>Connector.defaultArguments()</code></a>) to specify the transport specific address at which the VM is listenig. Optionally, other connector arguments can be presented to the user. </li>
<li> Debugger calls the <a href="connect/attachingconnector#attach(java.util.Map)"><code>AttachingConnector.attach(java.util.Map)</code></a> method of the selected to attach to the target VM. A <a href="virtualmachine"><code>VirtualMachine</code></a> mirror is returned. </li>
</ul> </td> </tr> </table> <p> Connectors are created at start-up time. That is, they are created the first time that <a href="bootstrap#virtualMachineManager()"><code>Bootstrap.virtualMachineManager()</code></a> is invoked. The list of all Connectors created at start-up time can be obtained from the VirtualMachineManager by invoking the <a href="#allConnectors()"><code>allConnectors</code></a> method. </p>
<p> Connectors are created at start-up time if they are installed on the platform. In addition, Connectors are created automatically by the VirtualMachineManager to encapsulate any <a href="connect/spi/transportservice"><code>TransportService</code></a> implementations that are installed on the platform. These two mechanisms for creating Connectors are described here. </p>
<p> A Connector is installed on the platform if it is installed in a jar file that is visible to the defining class loader of the <a href="connect/connector"><code>Connector</code></a> type, and that jar file contains a provider configuration file named <code>Connector</code> in the resource directory <code>META-INF/services</code>, and the provider configuration file lists the full-qualified class name of the Connector implementation. A Connector is a class that implements the <a href="connect/connector"><code>Connector</code></a> interface. More appropriately the class implements one of the specific Connector types, namely <a href="connect/attachingconnector"><code>AttachingConnector</code></a>, <a href="connect/listeningconnector"><code>ListeningConnector</code></a>, or <a href="connect/launchingconnector"><code>LaunchingConnector</code></a>. The format of the provider configuration file is one fully-qualified class name per line. Space and tab characters surrounding each class, as well as blank lines are ignored. The comment character is <code>'#'</code> (<code>0x23</code>), and on each line all characters following the first comment character are ignored. The file must be encoded in UTF-8. </p>
<p> At start-up time the VirtualMachineManager attempts to load and instantiate (using the no-arg constructor) each class listed in the provider configuration file. Exceptions thrown when loading or creating the Connector are caught and ignored. In other words, the start-up process continues despite of errors. </p>
<p> In addition to Connectors installed on the platform the VirtualMachineManager will also create Connectors to encapsulate any <a href="connect/spi/transportservice"><code>TransportService</code></a> implementations that are installed on the platform. A TransportService is installed on the platform if it installed in a jar file that is visible to the defining class loader for the <a href="connect/spi/transportservice"><code>TransportService</code></a> type, and that jar file contains a provider configuration file named <code>TransportService</code> in the resource directory <code>META-INF/services</code>, and the provider configuration file lists the full-qualified class name of the TransportService implementation. A TransportService is a concrete sub-class of <a href="connect/spi/transportservice"><code>TransportService</code></a>. The format of the provider configuration file is the same as the provider configuration file for Connectors except that each class listed must be the fully-qualified class name of a class that implements the TransportService interface. </p>
<p> For each TransportService installed on the platform, the VirtualMachineManager creates a corresponding <a href="connect/attachingconnector"><code>AttachingConnector</code></a> and <a href="connect/listeningconnector"><code>ListeningConnector</code></a>. These Connectors are created to encapsulate a <a href="connect/transport"><code>Transport</code></a> that in turn encapsulates the TransportService. The AttachingConnector will be named based on the name of the transport service concatenated with the string <code>Attach</code>. For example, if the transport service <a href="connect/spi/transportservice#name()"><code>name()</code></a> method returns <code>telepathic</code> then the AttachingConnector will be named <code>telepathicAttach</code>. Similiarly the ListeningConnector will be named with the string <code>Listen</code> tagged onto the name of the transport service. The <a href="connect/connector#description()"><code>description()</code></a> method of both the AttachingConnector, and the ListeningConnector, will delegate to the <a href="connect/spi/transportservice#description()"><code>description()</code></a> method of the underlying transport service. Both the AttachingConnector and the ListeningConnector will have two Connector <a href="connect/connector.argument"><code>Arguments</code></a>. A <a href="connect/connector.stringargument"><code>StringArgument</code></a> named <code>address</code> is the connector argument to specify the address to attach too, or to listen on. A <a href="connect/connector.integerargument"><code>IntegerArgument</code></a> named <code>timeout</code> is the connector argument to specify the timeout when attaching, or accepting. The timeout connector may be ignored depending on if the transport service supports an attach timeout or accept timeout. </p>
<p> Initialization of the virtual machine manager will fail, that is <a href="bootstrap#virtualMachineManager()"><code>Bootstrap.virtualMachineManager()</code></a> will throw an error if the virtual machine manager is unable to create any connectors.</p>
</div> <dl> <dt>Since:</dt> <dd>1.3</dd> </dl>      <section role="region">  <h2 id="method.summary">Methods</h2> <table>  <tr> <th scope="col">Modifier and Type</th> <th scope="col">Method</th> <th scope="col">Description</th> </tr> <tr id="i0"> <td><code><a href="../../../../java.base/java/util/list">List</a>&lt;<a href="connect/connector">Connector</a>&gt;</code></td> <th scope="row"><code><a href="#allConnectors()">allConnectors</a>()</code></th> <td> <p>Returns the list of all known <a href="connect/connector"><code>Connector</code></a> objects.</p> </td> </tr> <tr id="i1"> <td><code><a href="../../../../java.base/java/util/list">List</a>&lt;<a href="connect/attachingconnector">AttachingConnector</a>&gt;</code></td> <th scope="row"><code><a href="#attachingConnectors()">attachingConnectors</a>()</code></th> <td> <p>Returns the list of known <a href="connect/attachingconnector"><code>AttachingConnector</code></a> objects.</p> </td> </tr> <tr id="i2"> <td><code><a href="../../../../java.base/java/util/list">List</a>&lt;<a href="virtualmachine">VirtualMachine</a>&gt;</code></td> <th scope="row"><code><a href="#connectedVirtualMachines()">connectedVirtualMachines</a>()</code></th> <td> <p>Lists all target VMs which are connected to the debugger.</p> </td> </tr> <tr id="i3"> <td><code><a href="virtualmachine">VirtualMachine</a></code></td> <th scope="row"><code><a href="#createVirtualMachine(com.sun.jdi.connect.spi.Connection)">createVirtualMachine</a>​(<a href="connect/spi/connection">Connection</a> connection)</code></th> <td> <p>Creates a new virtual machine.</p> </td> </tr> <tr id="i4"> <td><code><a href="virtualmachine">VirtualMachine</a></code></td> <th scope="row"><code><a href="#createVirtualMachine(com.sun.jdi.connect.spi.Connection,java.lang.Process)">createVirtualMachine</a>​(<a href="connect/spi/connection">Connection</a> connection,
                    <a href="../../../../java.base/java/lang/process">Process</a> process)</code></th> <td> <p>Create a virtual machine mirror for a target VM.</p> </td> </tr> <tr id="i5"> <td><code><a href="connect/launchingconnector">LaunchingConnector</a></code></td> <th scope="row"><code><a href="#defaultConnector()">defaultConnector</a>()</code></th> <td> <p>Identifies the default connector.</p> </td> </tr> <tr id="i6"> <td><code><a href="../../../../java.base/java/util/list">List</a>&lt;<a href="connect/launchingconnector">LaunchingConnector</a>&gt;</code></td> <th scope="row"><code><a href="#launchingConnectors()">launchingConnectors</a>()</code></th> <td> <p>Returns the list of known <a href="connect/launchingconnector"><code>LaunchingConnector</code></a> objects.</p> </td> </tr> <tr id="i7"> <td><code><a href="../../../../java.base/java/util/list">List</a>&lt;<a href="connect/listeningconnector">ListeningConnector</a>&gt;</code></td> <th scope="row"><code><a href="#listeningConnectors()">listeningConnectors</a>()</code></th> <td> <p>Returns the list of known <a href="connect/listeningconnector"><code>ListeningConnector</code></a> objects.</p> </td> </tr> <tr id="i8"> <td><code>int</code></td> <th scope="row"><code><a href="#majorInterfaceVersion()">majorInterfaceVersion</a>()</code></th> <td> <p>Returns the major version number of the JDI interface.</p> </td> </tr> <tr id="i9"> <td><code>int</code></td> <th scope="row"><code><a href="#minorInterfaceVersion()">minorInterfaceVersion</a>()</code></th> <td> <p>Returns the minor version number of the JDI interface.</p> </td> </tr> </table>  </section>   <div>   <section role="region">  <h2 id="method.detail">Methods</h2>   <h3 id="defaultConnector()">defaultConnector</h3> <pre data-language="java">LaunchingConnector defaultConnector()</pre> <p>Identifies the default connector. This connector should be used as the launching connector when selection of a connector with specific characteristics is unnecessary.</p> <dl> <dt>Returns:</dt> <dd>the default <a href="connect/launchingconnector"><code>LaunchingConnector</code></a>
</dd> </dl>    <h3 id="launchingConnectors()">launchingConnectors</h3> <pre data-language="java">List&lt;LaunchingConnector&gt; launchingConnectors()</pre> <p>Returns the list of known <a href="connect/launchingconnector"><code>LaunchingConnector</code></a> objects. Any of the returned objects can be used to launch a new target VM and immediately create a <a href="virtualmachine"><code>VirtualMachine</code></a> mirror for it. Note that a target VM launched by a launching connector is not guaranteed to be stable until after the <a href="event/vmstartevent"><code>VMStartEvent</code></a> has been received.</p> <dl> <dt>Returns:</dt> <dd>a list of <a href="connect/launchingconnector"><code>LaunchingConnector</code></a> objects.</dd> </dl>    <h3 id="attachingConnectors()">attachingConnectors</h3> <pre data-language="java">List&lt;AttachingConnector&gt; attachingConnectors()</pre> <p>Returns the list of known <a href="connect/attachingconnector"><code>AttachingConnector</code></a> objects. Any of the returned objects can be used to attach to an existing target VM and create a <a href="virtualmachine"><code>VirtualMachine</code></a> mirror for it.</p> <dl> <dt>Returns:</dt> <dd>a list of <a href="connect/attachingconnector"><code>AttachingConnector</code></a> objects.</dd> </dl>    <h3 id="listeningConnectors()">listeningConnectors</h3> <pre data-language="java">List&lt;ListeningConnector&gt; listeningConnectors()</pre> <p>Returns the list of known <a href="connect/listeningconnector"><code>ListeningConnector</code></a> objects. Any of the returned objects can be used to listen for a connection initiated by a target VM and create a <a href="virtualmachine"><code>VirtualMachine</code></a> mirror for it.</p> <dl> <dt>Returns:</dt> <dd>a list of <a href="connect/listeningconnector"><code>ListeningConnector</code></a> objects.</dd> </dl>    <h3 id="allConnectors()">allConnectors</h3> <pre data-language="java">List&lt;Connector&gt; allConnectors()</pre> <p>Returns the list of all known <a href="connect/connector"><code>Connector</code></a> objects.</p> <dl> <dt>Returns:</dt> <dd>a list of <a href="connect/connector"><code>Connector</code></a> objects.</dd> </dl>    <h3 id="connectedVirtualMachines()">connectedVirtualMachines</h3> <pre data-language="java">List&lt;VirtualMachine&gt; connectedVirtualMachines()</pre> <p>Lists all target VMs which are connected to the debugger. The list includes <a href="virtualmachine"><code>VirtualMachine</code></a> instances for any target VMs which initiated a connection and any target VMs to which this manager has initiated a connection. A target VM will remain in this list until the VM is disconnected. <a href="event/vmdisconnectevent"><code>VMDisconnectEvent</code></a> is placed in the event queue after the VM is removed from the list.</p> <dl> <dt>Returns:</dt> <dd>a list of <a href="virtualmachine"><code>VirtualMachine</code></a> objects, each mirroring a target VM.</dd> </dl>    <h3 id="majorInterfaceVersion()">majorInterfaceVersion</h3> <pre data-language="java">int majorInterfaceVersion()</pre> <p>Returns the major version number of the JDI interface. See <a href="virtualmachine#version()"><code>VirtualMachine.version()</code></a> target VM version and information and <a href="virtualmachine#description()"><code>VirtualMachine.description()</code></a> more version information.</p> <dl> <dt>Returns:</dt> <dd>the integer major version number.</dd> </dl>    <h3 id="minorInterfaceVersion()">minorInterfaceVersion</h3> <pre data-language="java">int minorInterfaceVersion()</pre> <p>Returns the minor version number of the JDI interface. See <a href="virtualmachine#version()"><code>VirtualMachine.version()</code></a> target VM version and information and <a href="virtualmachine#description()"><code>VirtualMachine.description()</code></a> more version information.</p> <dl> <dt>Returns:</dt> <dd>the integer minor version number</dd> </dl>    <h3 id="createVirtualMachine(com.sun.jdi.connect.spi.Connection,java.lang.Process)">createVirtualMachine</h3> <pre data-language="java">VirtualMachine createVirtualMachine(Connection connection,
                                    Process process)
                             throws IOException</pre> <div>
<p>Create a virtual machine mirror for a target VM. </p>
<p> Creates a virtual machine mirror for a target VM for which a <a href="connect/spi/connection"><code>Connection</code></a> already exists. A Connection is created when a <a href="connect/connector"><code>Connector</code></a> establishes a connection and successfully handshakes with a target VM. A Connector can then use this method to create a virtual machine mirror to represent the composite state of the target VM. </p>
<p> The <code>process</code> argument specifies the <a href="../../../../java.base/java/lang/process"><code>Process</code></a> object for the taget VM. It may be specified as <code>null</code>. If the target VM is launched by a <a href="connect/launchingconnector"><code>LaunchingConnector</code></a> the <code>process</code> argument should be specified, otherwise calling <a href="virtualmachine#process()"><code>VirtualMachine.process()</code></a> on the created virtual machine will return <code>null</code>. </p>
<p> This method exists so that Connectors may create a virtual machine mirror when a connection is established to a target VM. Only developers creating new Connector implementations should need to make direct use of this method.</p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>connection</code> - The open connection to the target VM.</dd> <dd>
<code>process</code> - If launched, the <a href="../../../../java.base/java/lang/process"><code>Process</code></a> object for the target VM. <code>null</code> if not launched.</dd> <dt>Returns:</dt> <dd>new virtual machine representing the target VM.</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.base/java/io/ioexception">IOException</a></code> - if an I/O error occurs</dd> <dd>
<code><a href="../../../../java.base/java/lang/illegalstateexception">IllegalStateException</a></code> - if the connection is not open</dd> <dt>Since:</dt> <dd>1.5</dd> <dt>See Also:</dt> <dd>
<a href="connect/spi/connection#isOpen()"><code>Connection.isOpen()</code></a>, <a href="virtualmachine#process()"><code>VirtualMachine.process()</code></a>
</dd> </dl>    <h3 id="createVirtualMachine(com.sun.jdi.connect.spi.Connection)">createVirtualMachine</h3> <pre data-language="java">VirtualMachine createVirtualMachine(Connection connection)
                             throws IOException</pre> <div>
<p>Creates a new virtual machine. </p>
<p> This convenience method works as if by invoking <a href="#createVirtualMachine(com.sun.jdi.connect.spi.Connection,java.lang.Process)"><code>createVirtualMachine(Connection, Process)</code></a> method and specifying <code>null</code> as the <code>process</code> argument. </p>
<p> This method exists so that Connectors may create a virtual machine mirror when a connection is established to a target VM. Only developers creating new Connector implementations should need to make direct use of this method.</p>
</div> <dl> <dt>Returns:</dt> <dd>the new virtual machine</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.base/java/io/ioexception">IOException</a></code> - if an I/O error occurs</dd> <dd>
<code><a href="../../../../java.base/java/lang/illegalstateexception">IllegalStateException</a></code> - if the connection is not open</dd> <dt>Since:</dt> <dd>1.5</dd> </dl>   </section>  </div>  </main>  <div class="_attribution">
  <p class="_attribution-p">
    &copy; 1993, 2020, Oracle and/or its affiliates. All rights reserved.<br>Documentation extracted from Debian's OpenJDK Development Kit package.<br>Licensed under the GNU General Public License, version 2, with the Classpath Exception.<br>Various third party code in OpenJDK is licensed under different licenses (see Debian package).<br>Java and OpenJDK are trademarks or registered trademarks of Oracle and/or its affiliates.<br>
    <a href="https://docs.oracle.com/en/java/javase/11/docs/api/jdk.jdi/com/sun/jdi/VirtualMachineManager.html" class="_attribution-link">https://docs.oracle.com/en/java/javase/11/docs/api/jdk.jdi/com/sun/jdi/VirtualMachineManager.html</a>
  </p>
</div>
