  <main role="main">    <h1>Class Reference&lt;T&gt;</h1>   <ul class="inheritance"> <li><a href="../object">java.lang.Object</a></li> <li> <ul class="inheritance"> <li>java.lang.ref.Reference&lt;T&gt;</li> </ul> </li> </ul>   <dl> <dt>Direct Known Subclasses:</dt> <dd>
<code><a href="phantomreference">PhantomReference</a></code>, <code><a href="softreference">SoftReference</a></code>, <code><a href="weakreference">WeakReference</a></code>
</dd> </dl>  <pre data-language="java">public abstract class Reference&lt;T&gt;
extends Object</pre> <p>Abstract base class for reference objects. This class defines the operations common to all reference objects. Because reference objects are implemented in close cooperation with the garbage collector, this class may not be subclassed directly.</p> <dl> <dt>Since:</dt> <dd>1.2</dd> </dl>      <section role="region">  <h2 id="method.summary">Methods</h2> <table>  <tr> <th scope="col">Modifier and Type</th> <th scope="col">Method</th> <th scope="col">Description</th> </tr> <tr id="i0"> <td><code>void</code></td> <th scope="row"><code><a href="#clear()">clear</a>()</code></th> <td> <p>Clears this reference object.</p> </td> </tr> <tr id="i1"> <td><code>protected <a href="../object">Object</a></code></td> <th scope="row"><code><a href="#clone()">clone</a>()</code></th> <td> <p>Throws <a href="../clonenotsupportedexception"><code>CloneNotSupportedException</code></a>.</p> </td> </tr> <tr id="i2"> <td><code>boolean</code></td> <th scope="row"><code><a href="#enqueue()">enqueue</a>()</code></th> <td> <p>Clears this reference object and adds it to the queue with which it is registered, if any.</p> </td> </tr> <tr id="i3"> <td><code><a href="reference">T</a></code></td> <th scope="row"><code><a href="#get()">get</a>()</code></th> <td> <p>Returns this reference object's referent.</p> </td> </tr> <tr id="i4"> <td><code>boolean</code></td> <th scope="row"><code><a href="#isEnqueued()">isEnqueued</a>()</code></th> <td> <p>Tells whether or not this reference object has been enqueued, either by the program or by the garbage collector.</p> </td> </tr> <tr id="i5"> <td><code>static void</code></td> <th scope="row"><code><a href="#reachabilityFence(java.lang.Object)">reachabilityFence</a>​(<a href="../object">Object</a> ref)</code></th> <td> <p>Ensures that the object referenced by the given reference remains <a href="package-summary#reachability"><em>strongly reachable</em></a>, regardless of any prior actions of the program that might otherwise cause the object to become unreachable; thus, the referenced object is not reclaimable by garbage collection at least until after the invocation of this method.</p> </td> </tr> </table>  <h2 id="methods.inherited.from.class.java.lang.Object">Methods declared in class java.lang.<a href="../object">Object</a>
</h2> <code><a href="../object#equals(java.lang.Object)">equals</a>, <a href="../object#finalize()">finalize</a>, <a href="../object#getClass()">getClass</a>, <a href="../object#hashCode()">hashCode</a>, <a href="../object#notify()">notify</a>, <a href="../object#notifyAll()">notifyAll</a>, <a href="../object#toString()">toString</a>, <a href="../object#wait()">wait</a>, <a href="../object#wait(long)">wait</a>, <a href="../object#wait(long,int)">wait</a></code>  </section>   <div>   <section role="region">  <h2 id="method.detail">Methods</h2>   <h3 id="get()">get</h3> <pre data-language="java">public T get()</pre> <p>Returns this reference object's referent. If this reference object has been cleared, either by the program or by the garbage collector, then this method returns <code>null</code>.</p> <dl> <dt>Returns:</dt> <dd>The object to which this reference refers, or <code>null</code> if this reference object has been cleared</dd> </dl>    <h3 id="clear()">clear</h3> <pre data-language="java">public void clear()</pre> <div>
<p>Clears this reference object. Invoking this method will not cause this object to be enqueued. </p>
<p> This method is invoked only by Java code; when the garbage collector clears references it does so directly, without invoking this method.</p>
</div>    <h3 id="isEnqueued()">isEnqueued</h3> <pre data-language="java">public boolean isEnqueued()</pre> <p>Tells whether or not this reference object has been enqueued, either by the program or by the garbage collector. If this reference object was not registered with a queue when it was created, then this method will always return <code>false</code>.</p> <dl> <dt>Returns:</dt> <dd>
<code>true</code> if and only if this reference object has been enqueued</dd> </dl>    <h3 id="enqueue()">enqueue</h3> <pre data-language="java">public boolean enqueue()</pre> <div>
<p>Clears this reference object and adds it to the queue with which it is registered, if any. </p>
<p> This method is invoked only by Java code; when the garbage collector enqueues references it does so directly, without invoking this method.</p>
</div> <dl> <dt>Returns:</dt> <dd>
<code>true</code> if this reference object was successfully enqueued; <code>false</code> if it was already enqueued or if it was not registered with a queue when it was created</dd> </dl>    <h3 id="clone()">clone</h3> <pre data-language="java">protected Object clone()
                throws CloneNotSupportedException</pre> <p>Throws <a href="../clonenotsupportedexception"><code>CloneNotSupportedException</code></a>. A <code>Reference</code> cannot be meaningfully cloned. Construct a new <code>Reference</code> instead.</p> <dl> <dt>Overrides:</dt> <dd>
<code><a href="../object#clone()">clone</a></code> in class <code><a href="../object">Object</a></code>
</dd> <dt>Returns:</dt> <dd>a clone of this instance.</dd> <dt>Throws:</dt> <dd>
<code><a href="../clonenotsupportedexception">CloneNotSupportedException</a></code> - always</dd> <dt>Since:</dt> <dd>11</dd> <dt>See Also:</dt> <dd><a href="../cloneable"><code>Cloneable</code></a></dd> </dl>    <h3 id="reachabilityFence(java.lang.Object)">reachabilityFence</h3> <pre data-language="java">public static void reachabilityFence(Object ref)</pre> <div>
<p>Ensures that the object referenced by the given reference remains <a href="package-summary#reachability"><em>strongly reachable</em></a>, regardless of any prior actions of the program that might otherwise cause the object to become unreachable; thus, the referenced object is not reclaimable by garbage collection at least until after the invocation of this method. Invocation of this method does not itself initiate garbage collection or finalization. </p>
<p> This method establishes an ordering for <a href="package-summary#reachability"><em>strong reachability</em></a> with respect to garbage collection. It controls relations that are otherwise only implicit in a program -- the reachability conditions triggering garbage collection. This method is designed for use in uncommon situations of premature finalization where using <code>synchronized</code> blocks or methods, or using other synchronization facilities are not possible or do not provide the desired control. This method is applicable only when reclamation may have visible effects, which is possible for objects with finalizers (See <a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-12.html#jls-12.6"> Section 12.6 17 of <cite>The Java™ Language Specification</cite></a>) that are implemented in ways that rely on ordering control for correctness.</p>
</div> <dl> <dt>API Note:</dt> <dd>Finalization may occur whenever the virtual machine detects that no reference to an object will ever be stored in the heap: The garbage collector may reclaim an object even if the fields of that object are still in use, so long as the object has otherwise become unreachable. This may have surprising and undesirable effects in cases such as the following example in which the bookkeeping associated with a class is managed through array indices. Here, method <code>action</code> uses a <code>reachabilityFence</code> to ensure that the <code>Resource</code> object is not reclaimed before bookkeeping on an associated <code>ExternalResource</code> has been performed; in particular here, to ensure that the array slot holding the <code>ExternalResource</code> is not nulled out in method <a href="../object#finalize()"><code>Object.finalize()</code></a>, which may otherwise run concurrently. <pre data-language="java">class Resource {
   private static ExternalResource[] externalResourceArray = ...

   int myIndex;
   Resource(...) {
     myIndex = ...
     externalResourceArray[myIndex] = ...;
     ...
   }
   protected void finalize() {
     externalResourceArray[myIndex] = null;
     ...
   }
   public void action() {
     try {
       // ...
       int i = myIndex;
       Resource.update(externalResourceArray[i]);
     } finally {
       Reference.reachabilityFence(this);
     }
   }
   private static void update(ExternalResource ext) {
     ext.status = ...;
   }
 }</pre> Here, the invocation of <code>reachabilityFence</code> is nonintuitively placed <em>after</em> the call to <code>update</code>, to ensure that the array slot is not nulled out by <a href="../object#finalize()"><code>Object.finalize()</code></a> before the update, even if the call to <code>action</code> was the last use of this object. This might be the case if, for example a usage in a user program had the form <code>new Resource().action();</code> which retains no other reference to this <code>Resource</code>. While probably overkill here, <code>reachabilityFence</code> is placed in a <code>finally</code> block to ensure that it is invoked across all paths in the method. In a method with more complex control paths, you might need further precautions to ensure that <code>reachabilityFence</code> is encountered along all of them. <p> It is sometimes possible to better encapsulate use of <code>reachabilityFence</code>. Continuing the above example, if it were acceptable for the call to method <code>update</code> to proceed even if the finalizer had already executed (nulling out slot), then you could localize use of <code>reachabilityFence</code>: </p>
<pre data-language="java">public void action2() {
   // ...
   Resource.update(getExternalResource());
 }
 private ExternalResource getExternalResource() {
   ExternalResource ext = externalResourceArray[myIndex];
   Reference.reachabilityFence(this);
   return ext;
 }</pre> <p> Method <code>reachabilityFence</code> is not required in constructions that themselves ensure reachability. For example, because objects that are locked cannot, in general, be reclaimed, it would suffice if all accesses of the object, in all methods of class <code>Resource</code> (including <code>finalize</code>) were enclosed in <code>synchronized (this)</code> blocks. (Further, such blocks must not include infinite loops, or themselves be unreachable, which fall into the corner case exceptions to the "in general" disclaimer.) However, method <code>reachabilityFence</code> remains a better option in cases where this approach is not as efficient, desirable, or possible; for example because it would encounter deadlock.</p>
</dd> <dt>Parameters:</dt> <dd>
<code>ref</code> - the reference. If <code>null</code>, this method has no effect.</dd> <dt>Since:</dt> <dd>9</dd> </dl>   </section>  </div>  </main>  <div class="_attribution">
  <p class="_attribution-p">
    &copy; 1993, 2020, Oracle and/or its affiliates. All rights reserved.<br>Documentation extracted from Debian's OpenJDK Development Kit package.<br>Licensed under the GNU General Public License, version 2, with the Classpath Exception.<br>Various third party code in OpenJDK is licensed under different licenses (see Debian package).<br>Java and OpenJDK are trademarks or registered trademarks of Oracle and/or its affiliates.<br>
    <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/ref/Reference.html" class="_attribution-link">https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/ref/Reference.html</a>
  </p>
</div>
