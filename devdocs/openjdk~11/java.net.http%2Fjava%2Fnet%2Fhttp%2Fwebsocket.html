  <main role="main">    <h1>Interface WebSocket</h1>      <pre data-language="java">public interface WebSocket</pre> <div>
<p>A WebSocket Client. </p>
<p> <code>WebSocket</code> instances are created through <a href="websocket.builder"><code>WebSocket.Builder</code></a>. </p>
<p> WebSocket has an input and an output side. These sides are independent from each other. A side can either be open or closed. Once closed, the side remains closed. WebSocket messages are sent through a <code>WebSocket</code> and received through a <code>WebSocket.Listener</code> associated with it. Messages can be sent until the WebSocket's output is closed, and received until the WebSocket's input is closed. </p>
<p> A send method is any of the <code>sendText</code>, <code>sendBinary</code>, <code>sendPing</code>, <code>sendPong</code> and <code>sendClose</code> methods of <code>WebSocket</code>. A send method initiates a send operation and returns a <code>CompletableFuture</code> which completes once the operation has completed. If the <code>CompletableFuture</code> completes normally the operation is considered succeeded. If the <code>CompletableFuture</code> completes exceptionally, the operation is considered failed. An operation that has been initiated but not yet completed is considered pending. </p>
<p> A receive method is any of the <code>onText</code>, <code>onBinary</code>, <code>onPing</code>, <code>onPong</code> and <code>onClose</code> methods of <code>Listener</code>. WebSocket initiates a receive operation by invoking a receive method on the listener. The listener then must return a <code>CompletionStage</code> which completes once the operation has completed. </p>
<p> To control receiving of messages, a WebSocket maintains an <a id="counter">internal counter</a>. This counter's value is a number of times the WebSocket has yet to invoke a receive method. While this counter is zero the WebSocket does not invoke receive methods. The counter is incremented by <code>n</code> when <code>request(n)</code> is called. The counter is decremented by one when the WebSocket invokes a receive method. <code>onOpen</code> and <code>onError</code> are not receive methods. WebSocket invokes <code>onOpen</code> prior to any other methods on the listener. WebSocket invokes <code>onOpen</code> at most once. WebSocket may invoke <code>onError</code> at any given time. If the WebSocket invokes <code>onError</code> or <code>onClose</code>, then no further listener's methods will be invoked, no matter the value of the counter. For a newly built WebSocket the counter is zero. </p>
<p> Unless otherwise stated, <code>null</code> arguments will cause methods of <code>WebSocket</code> to throw <code>NullPointerException</code>, similarly, <code>WebSocket</code> will not pass <code>null</code> arguments to methods of <code>Listener</code>. The state of a WebSocket is not changed by the invocations that throw or return a <code>CompletableFuture</code> that completes with one of the <code>NullPointerException</code>, <code>IllegalArgumentException</code>, <code>IllegalStateException</code> exceptions. </p>
<p> <code>WebSocket</code> handles received Ping and Close messages automatically (as per the WebSocket Protocol) by replying with Pong and Close messages. If the listener receives Ping or Close messages, no mandatory actions from the listener are required.</p>
</div> <dl> <dt>API Note:</dt> <dd>The relationship between a WebSocket and the associated Listener is analogous to that of a Subscription and the associated Subscriber of type <a href="../../../../java.base/java/util/concurrent/flow"><code>Flow</code></a>.</dd> <dt>Since:</dt> <dd>11</dd> </dl>      <section role="region">  <h2 id="nested.class.summary">Nested Classes</h2> <table>  <tr> <th scope="col">Modifier and Type</th> <th scope="col">Interface</th> <th scope="col">Description</th> </tr> <tr> <td><code>static interface </code></td> <th scope="row"><code><a href="websocket.builder">WebSocket.Builder</a></code></th> <td> <p>A builder of <a href="websocket">WebSocket Clients</a>.</p> </td> </tr> <tr> <td><code>static interface </code></td> <th scope="row"><code><a href="websocket.listener">WebSocket.Listener</a></code></th> <td> <p>The receiving interface of <code>WebSocket</code>.</p> </td> </tr> </table>  </section>  <section role="region">  <h2 id="field.summary">Fields</h2> <table>  <tr> <th scope="col">Modifier and Type</th> <th scope="col">Field</th> <th scope="col">Description</th> </tr> <tr> <td><code>static int</code></td> <th scope="row"><code><a href="#NORMAL_CLOSURE">NORMAL_CLOSURE</a></code></th> <td> <p>The WebSocket Close message status code (<code>1000</code>), indicating normal closure, meaning that the purpose for which the connection was established has been fulfilled.</p> </td> </tr> </table>  </section>  <section role="region">  <h2 id="method.summary">Methods</h2> <table>  <tr> <th scope="col">Modifier and Type</th> <th scope="col">Method</th> <th scope="col">Description</th> </tr> <tr id="i0"> <td><code>void</code></td> <th scope="row"><code><a href="#abort()">abort</a>()</code></th> <td> <p>Closes this WebSocket's input and output abruptly.</p> </td> </tr> <tr id="i1"> <td><code><a href="../../../../java.base/java/lang/string">String</a></code></td> <th scope="row"><code><a href="#getSubprotocol()">getSubprotocol</a>()</code></th> <td> <p>Returns the subprotocol used by this WebSocket.</p> </td> </tr> <tr id="i2"> <td><code>boolean</code></td> <th scope="row"><code><a href="#isInputClosed()">isInputClosed</a>()</code></th> <td> <p>Tells whether this WebSocket's input is closed.</p> </td> </tr> <tr id="i3"> <td><code>boolean</code></td> <th scope="row"><code><a href="#isOutputClosed()">isOutputClosed</a>()</code></th> <td> <p>Tells whether this WebSocket's output is closed.</p> </td> </tr> <tr id="i4"> <td><code>void</code></td> <th scope="row"><code><a href="#request(long)">request</a>​(long n)</code></th> <td> <p>Increments the counter of invocations of receive methods.</p> </td> </tr> <tr id="i5"> <td><code><a href="../../../../java.base/java/util/concurrent/completablefuture">CompletableFuture</a>&lt;<a href="websocket">WebSocket</a>&gt;</code></td> <th scope="row"><code><a href="#sendBinary(java.nio.ByteBuffer,boolean)">sendBinary</a>​(<a href="../../../../java.base/java/nio/bytebuffer">ByteBuffer</a> data,
          boolean last)</code></th> <td> <p>Sends binary data with bytes from the given buffer.</p> </td> </tr> <tr id="i6"> <td><code><a href="../../../../java.base/java/util/concurrent/completablefuture">CompletableFuture</a>&lt;<a href="websocket">WebSocket</a>&gt;</code></td> <th scope="row"><code><a href="#sendClose(int,java.lang.String)">sendClose</a>​(int statusCode,
         <a href="../../../../java.base/java/lang/string">String</a> reason)</code></th> <td> <p>Initiates an orderly closure of this WebSocket's output by sending a Close message with the given status code and the reason.</p> </td> </tr> <tr id="i7"> <td><code><a href="../../../../java.base/java/util/concurrent/completablefuture">CompletableFuture</a>&lt;<a href="websocket">WebSocket</a>&gt;</code></td> <th scope="row"><code><a href="#sendPing(java.nio.ByteBuffer)">sendPing</a>​(<a href="../../../../java.base/java/nio/bytebuffer">ByteBuffer</a> message)</code></th> <td> <p>Sends a Ping message with bytes from the given buffer.</p> </td> </tr> <tr id="i8"> <td><code><a href="../../../../java.base/java/util/concurrent/completablefuture">CompletableFuture</a>&lt;<a href="websocket">WebSocket</a>&gt;</code></td> <th scope="row"><code><a href="#sendPong(java.nio.ByteBuffer)">sendPong</a>​(<a href="../../../../java.base/java/nio/bytebuffer">ByteBuffer</a> message)</code></th> <td> <p>Sends a Pong message with bytes from the given buffer.</p> </td> </tr> <tr id="i9"> <td><code><a href="../../../../java.base/java/util/concurrent/completablefuture">CompletableFuture</a>&lt;<a href="websocket">WebSocket</a>&gt;</code></td> <th scope="row"><code><a href="#sendText(java.lang.CharSequence,boolean)">sendText</a>​(<a href="../../../../java.base/java/lang/charsequence">CharSequence</a> data,
        boolean last)</code></th> <td> <p>Sends textual data with characters from the given character sequence.</p> </td> </tr> </table>  </section>   <div>   <section role="region">  <h2 id="field.detail">Fields</h2>   <h3 id="NORMAL_CLOSURE">NORMAL_CLOSURE</h3> <pre data-language="java">static final int NORMAL_CLOSURE</pre> <p>The WebSocket Close message status code (<code>1000</code>), indicating normal closure, meaning that the purpose for which the connection was established has been fulfilled.</p> <dl> <dt>See Also:</dt> <dd>
<a href="#sendClose(int,java.lang.String)"><code>sendClose(int, String)</code></a>, <a href="websocket.listener#onClose(java.net.http.WebSocket,int,java.lang.String)"><code>WebSocket.Listener.onClose(WebSocket, int, String)</code></a>, <a href="https://docs.oracle.com/en/java/javase/11/docs/api/constant-values.html#java.net.http.WebSocket.NORMAL_CLOSURE">Constant Field Values</a>
</dd> </dl>   </section>  <section role="region">  <h2 id="method.detail">Methods</h2>   <h3 id="sendText(java.lang.CharSequence,boolean)">sendText</h3> <pre data-language="java">CompletableFuture&lt;WebSocket&gt; sendText(CharSequence data,
                                      boolean last)</pre> <div>
<p>Sends textual data with characters from the given character sequence. </p>
<p> The character sequence must not be modified until the <code>CompletableFuture</code> returned from this method has completed. </p>
<p> A <code>CompletableFuture</code> returned from this method can complete exceptionally with: </p>
<ul> <li> <a href="../../../../java.base/java/lang/illegalstateexception"><code>IllegalStateException</code></a> - if there is a pending text or binary send operation or if the previous binary data does not complete the message </li>
<li> <a href="../../../../java.base/java/io/ioexception"><code>IOException</code></a> - if an I/O error occurs, or if the output is closed </li>
</ul>
</div> <dl> <dt>Implementation Note:</dt> <dd>If <code>data</code> is a malformed UTF-16 sequence, the operation will fail with <code>IOException</code>.</dd> <dt>Parameters:</dt> <dd>
<code>data</code> - the data</dd> <dd>
<code>last</code> - <code>true</code> if this invocation completes the message, <code>false</code> otherwise</dd> <dt>Returns:</dt> <dd>a <code>CompletableFuture</code> that completes, with this WebSocket, when the data has been sent</dd> </dl>    <h3 id="sendBinary(java.nio.ByteBuffer,boolean)">sendBinary</h3> <pre data-language="java">CompletableFuture&lt;WebSocket&gt; sendBinary(ByteBuffer data,
                                        boolean last)</pre> <div>
<p>Sends binary data with bytes from the given buffer. </p>
<p> The data is located in bytes from the buffer's position to its limit. Upon normal completion of a <code>CompletableFuture</code> returned from this method the buffer will have no remaining bytes. The buffer must not be accessed until after that. </p>
<p> The <code>CompletableFuture</code> returned from this method can complete exceptionally with: </p>
<ul> <li> <a href="../../../../java.base/java/lang/illegalstateexception"><code>IllegalStateException</code></a> - if there is a pending text or binary send operation or if the previous textual data does not complete the message </li>
<li> <a href="../../../../java.base/java/io/ioexception"><code>IOException</code></a> - if an I/O error occurs, or if the output is closed </li>
</ul>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>data</code> - the data</dd> <dd>
<code>last</code> - <code>true</code> if this invocation completes the message, <code>false</code> otherwise</dd> <dt>Returns:</dt> <dd>a <code>CompletableFuture</code> that completes, with this WebSocket, when the data has been sent</dd> </dl>    <h3 id="sendPing(java.nio.ByteBuffer)">sendPing</h3> <pre data-language="java">CompletableFuture&lt;WebSocket&gt; sendPing(ByteBuffer message)</pre> <div>
<p>Sends a Ping message with bytes from the given buffer. </p>
<p> The message consists of not more than <code>125</code> bytes from the buffer's position to its limit. Upon normal completion of a <code>CompletableFuture</code> returned from this method the buffer will have no remaining bytes. The buffer must not be accessed until after that. </p>
<p> The <code>CompletableFuture</code> returned from this method can complete exceptionally with: </p>
<ul> <li> <a href="../../../../java.base/java/lang/illegalstateexception"><code>IllegalStateException</code></a> - if there is a pending ping or pong send operation </li>
<li> <a href="../../../../java.base/java/lang/illegalargumentexception"><code>IllegalArgumentException</code></a> - if the message is too long </li>
<li> <a href="../../../../java.base/java/io/ioexception"><code>IOException</code></a> - if an I/O error occurs, or if the output is closed </li>
</ul>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>message</code> - the message</dd> <dt>Returns:</dt> <dd>a <code>CompletableFuture</code> that completes, with this WebSocket, when the Ping message has been sent</dd> </dl>    <h3 id="sendPong(java.nio.ByteBuffer)">sendPong</h3> <pre data-language="java">CompletableFuture&lt;WebSocket&gt; sendPong(ByteBuffer message)</pre> <div>
<p>Sends a Pong message with bytes from the given buffer. </p>
<p> The message consists of not more than <code>125</code> bytes from the buffer's position to its limit. Upon normal completion of a <code>CompletableFuture</code> returned from this method the buffer will have no remaining bytes. The buffer must not be accessed until after that. </p>
<p> Given that the WebSocket implementation will automatically send a reciprocal pong when a ping is received, it is rarely required to send a pong message explicitly. </p>
<p> The <code>CompletableFuture</code> returned from this method can complete exceptionally with: </p>
<ul> <li> <a href="../../../../java.base/java/lang/illegalstateexception"><code>IllegalStateException</code></a> - if there is a pending ping or pong send operation </li>
<li> <a href="../../../../java.base/java/lang/illegalargumentexception"><code>IllegalArgumentException</code></a> - if the message is too long </li>
<li> <a href="../../../../java.base/java/io/ioexception"><code>IOException</code></a> - if an I/O error occurs, or if the output is closed </li>
</ul>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>message</code> - the message</dd> <dt>Returns:</dt> <dd>a <code>CompletableFuture</code> that completes, with this WebSocket, when the Pong message has been sent</dd> </dl>    <h3 id="sendClose(int,java.lang.String)">sendClose</h3> <pre data-language="java">CompletableFuture&lt;WebSocket&gt; sendClose(int statusCode,
                                       String reason)</pre> <div>
<p>Initiates an orderly closure of this WebSocket's output by sending a Close message with the given status code and the reason. </p>
<p> The <code>statusCode</code> is an integer from the range <code>1000 &lt;= code &lt;= 4999</code>. Status codes <code>1002</code>, <code>1003</code>, <code>1006</code>, <code>1007</code>, <code>1009</code>, <code>1010</code>, <code>1012</code>, <code>1013</code> and <code>1015</code> are illegal. Behaviour in respect to other status codes is implementation-specific. A legal <code>reason</code> is a string that has a UTF-8 representation not longer than <code>123</code> bytes. </p>
<p> A <code>CompletableFuture</code> returned from this method can complete exceptionally with: </p>
<ul> <li> <a href="../../../../java.base/java/lang/illegalargumentexception"><code>IllegalArgumentException</code></a> - if <code>statusCode</code> is illegal, or if <code>reason</code> is illegal </li>
<li> <a href="../../../../java.base/java/io/ioexception"><code>IOException</code></a> - if an I/O error occurs, or if the output is closed </li>
</ul> <p> Unless the <code>CompletableFuture</code> returned from this method completes with <code>IllegalArgumentException</code>, or the method throws <code>NullPointerException</code>, the output will be closed. </p>
<p> If not already closed, the input remains open until a Close message <a href="websocket.listener#onClose(java.net.http.WebSocket,int,java.lang.String)">received</a>, or <code>abort</code> is invoked, or an <a href="websocket.listener#onError(java.net.http.WebSocket,java.lang.Throwable)">error</a> occurs.</p>
</div> <dl> <dt>API Note:</dt> <dd>Use the provided integer constant <a href="#NORMAL_CLOSURE"><code>NORMAL_CLOSURE</code></a> as a status code and an empty string as a reason in a typical case: <pre data-language="java">CompletableFuture&lt;WebSocket&gt; webSocket = ...
    webSocket.thenCompose(ws -&gt; ws.sendText("Hello, ", false))
             .thenCompose(ws -&gt; ws.sendText("world!", true))
             .thenCompose(ws -&gt; ws.sendClose(WebSocket.NORMAL_CLOSURE, ""))
             .join();</pre> The <code>sendClose</code> method does not close this WebSocket's input. It merely closes this WebSocket's output by sending a Close message. To enforce closing the input, invoke the <code>abort</code> method. Here is an example of an application that sends a Close message, and then starts a timer. Once no data has been received within the specified timeout, the timer goes off and the alarm aborts <code>WebSocket</code>: <pre data-language="java">MyAlarm alarm = new MyAlarm(webSocket::abort);
    WebSocket.Listener listener = new WebSocket.Listener() {

        public CompletionStage&lt;?&gt; onText(WebSocket webSocket,
                                         CharSequence data,
                                         boolean last) {
            alarm.snooze();
            ...
        }
        ...
    };
    ...
    Runnable startTimer = () -&gt; {
        MyTimer idleTimer = new MyTimer();
        idleTimer.add(alarm, 30, TimeUnit.SECONDS);
    };
    webSocket.sendClose(WebSocket.NORMAL_CLOSURE, "ok").thenRun(startTimer);</pre>
</dd> <dt>Parameters:</dt> <dd>
<code>statusCode</code> - the status code</dd> <dd>
<code>reason</code> - the reason</dd> <dt>Returns:</dt> <dd>a <code>CompletableFuture</code> that completes, with this WebSocket, when the Close message has been sent</dd> </dl>    <h3 id="request(long)">request</h3> <pre data-language="java">void request(long n)</pre> <div>
<p>Increments the counter of invocations of receive methods. </p>
<p> This WebSocket will invoke <code>onText</code>, <code>onBinary</code>, <code>onPing</code>, <code>onPong</code> or <code>onClose</code> methods on the associated listener (i.e. receive methods) up to <code>n</code> more times.</p>
</div> <dl> <dt>API Note:</dt> <dd>The parameter of this method is the number of invocations being requested from this WebSocket to the associated listener, not the number of messages. Sometimes a message may be delivered to the listener in a single invocation, but not always. For example, Ping, Pong and Close messages are delivered in a single invocation of <code>onPing</code>, <code>onPong</code> and <code>onClose</code> methods respectively. However, whether or not Text and Binary messages are delivered in a single invocation of <code>onText</code> and <code>onBinary</code> methods depends on the boolean argument (<code>last</code>) of these methods. If <code>last</code> is <code>false</code>, then there is more to a message than has been delivered to the invocation. <p> Here is an example of a listener that requests invocations, one at a time, until a complete message has been accumulated, and then processes the result: </p>
<pre data-language="java">WebSocket.Listener listener = new WebSocket.Listener() {

        StringBuilder text = new StringBuilder();

        public CompletionStage&lt;?&gt; onText(WebSocket webSocket,
                                         CharSequence message,
                                         boolean last) {
            text.append(message);
            if (last) {
                processCompleteTextMessage(text);
                text = new StringBuilder();
            }
            webSocket.request(1);
            return null;
        }
    ...
    }</pre>
</dd> <dt>Parameters:</dt> <dd>
<code>n</code> - the number of invocations</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.base/java/lang/illegalargumentexception">IllegalArgumentException</a></code> - if <code>n &lt;= 0</code>
</dd> </dl>    <h3 id="getSubprotocol()">getSubprotocol</h3> <pre data-language="java">String getSubprotocol()</pre> <p>Returns the subprotocol used by this WebSocket.</p> <dl> <dt>Returns:</dt> <dd>the subprotocol, or an empty string if there's no subprotocol</dd> </dl>    <h3 id="isOutputClosed()">isOutputClosed</h3> <pre data-language="java">boolean isOutputClosed()</pre> <div>
<p>Tells whether this WebSocket's output is closed. </p>
<p> If this method returns <code>true</code>, subsequent invocations will also return <code>true</code>.</p>
</div> <dl> <dt>Returns:</dt> <dd>
<code>true</code> if closed, <code>false</code> otherwise</dd> </dl>    <h3 id="isInputClosed()">isInputClosed</h3> <pre data-language="java">boolean isInputClosed()</pre> <div>
<p>Tells whether this WebSocket's input is closed. </p>
<p> If this method returns <code>true</code>, subsequent invocations will also return <code>true</code>.</p>
</div> <dl> <dt>Returns:</dt> <dd>
<code>true</code> if closed, <code>false</code> otherwise</dd> </dl>    <h3 id="abort()">abort</h3> <pre data-language="java">void abort()</pre> <div>
<p>Closes this WebSocket's input and output abruptly. </p>
<p> When this method returns both the input and the output will have been closed. Any pending send operations will fail with <code>IOException</code>. Subsequent invocations of <code>abort</code> will have no effect.</p>
</div>   </section>  </div>  </main>  <div class="_attribution">
  <p class="_attribution-p">
    &copy; 1993, 2020, Oracle and/or its affiliates. All rights reserved.<br>Documentation extracted from Debian's OpenJDK Development Kit package.<br>Licensed under the GNU General Public License, version 2, with the Classpath Exception.<br>Various third party code in OpenJDK is licensed under different licenses (see Debian package).<br>Java and OpenJDK are trademarks or registered trademarks of Oracle and/or its affiliates.<br>
    <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.net.http/java/net/http/WebSocket.html" class="_attribution-link">https://docs.oracle.com/en/java/javase/11/docs/api/java.net.http/java/net/http/WebSocket.html</a>
  </p>
</div>
