  <main role="main">    <h1>Interface ModuleFinder</h1>      <pre data-language="java">public interface ModuleFinder</pre> <div>
<p>A finder of modules. A <code>ModuleFinder</code> is used to find modules during <a href="package-summary#resolution">resolution</a> or <a href="configuration#service-binding">service binding</a>. </p>
<p> A <code>ModuleFinder</code> can only find one module with a given name. A <code>ModuleFinder</code> that finds modules in a sequence of directories, for example, will locate the first occurrence of a module of a given name and will ignore other modules of that name that appear in directories later in the sequence. </p> <p> Example usage: </p> <pre data-language="java">Path dir1, dir2, dir3;

     ModuleFinder finder = ModuleFinder.of(dir1, dir2, dir3);

     Optional&lt;ModuleReference&gt; omref = finder.find("jdk.foo");
     omref.ifPresent(mref -&gt; ... );</pre> <p> The <a href="#find(java.lang.String)"><code>find</code></a> and <a href="#findAll()"><code>findAll</code></a> methods defined here can fail for several reasons. These include I/O errors, errors detected parsing a module descriptor (<code>module-info.class</code>), or in the case of <code>ModuleFinder</code> returned by <a href="#of(java.nio.file.Path...)"><code>ModuleFinder.of</code></a>, that two or more modules with the same name are found in a directory. When an error is detected then these methods throw <a href="findexception"><code>FindException</code></a> with an appropriate <a href="../throwable#getCause()"><code>cause</code></a>. The behavior of a <code>ModuleFinder</code> after a <code>FindException</code> is thrown is undefined. For example, invoking <code>find</code> after an exception is thrown may or may not scan the same modules that lead to the exception. It is recommended that a module finder be discarded after an exception is thrown. </p> <p> A <code>ModuleFinder</code> is not required to be thread safe. </p>
</div> <dl> <dt>Since:</dt> <dd>9</dd> </dl>      <section role="region">  <h2 id="method.summary">Methods</h2> <table>  <tr> <th scope="col">Modifier and Type</th> <th scope="col">Method</th> <th scope="col">Description</th> </tr> <tr id="i0"> <td><code>static <a href="modulefinder">ModuleFinder</a></code></td> <th scope="row"><code><a href="#compose(java.lang.module.ModuleFinder...)">compose</a>​(<a href="modulefinder">ModuleFinder</a>... finders)</code></th> <td> <p>Returns a module finder that is composed from a sequence of zero or more module finders.</p> </td> </tr> <tr id="i1"> <td><code><a href="../../util/optional">Optional</a>&lt;<a href="modulereference">ModuleReference</a>&gt;</code></td> <th scope="row"><code><a href="#find(java.lang.String)">find</a>​(<a href="../string">String</a> name)</code></th> <td> <p>Finds a reference to a module of a given name.</p> </td> </tr> <tr id="i2"> <td><code><a href="../../util/set">Set</a>&lt;<a href="modulereference">ModuleReference</a>&gt;</code></td> <th scope="row"><code><a href="#findAll()">findAll</a>()</code></th> <td> <p>Returns the set of all module references that this finder can locate.</p> </td> </tr> <tr id="i3"> <td><code>static <a href="modulefinder">ModuleFinder</a></code></td> <th scope="row"><code><a href="#of(java.nio.file.Path...)">of</a>​(<a href="../../nio/file/path">Path</a>... entries)</code></th> <td> <p>Returns a module finder that locates modules on the file system by searching a sequence of directories and/or packaged modules.</p> </td> </tr> <tr id="i4"> <td><code>static <a href="modulefinder">ModuleFinder</a></code></td> <th scope="row"><code><a href="#ofSystem()">ofSystem</a>()</code></th> <td> <p>Returns a module finder that locates the <em>system modules</em>.</p> </td> </tr> </table>  </section>   <div>   <section role="region">  <h2 id="method.detail">Methods</h2>   <h3 id="find(java.lang.String)">find</h3> <pre data-language="java">Optional&lt;ModuleReference&gt; find(String name)</pre> <div>
<p>Finds a reference to a module of a given name. </p>
<p> A <code>ModuleFinder</code> provides a consistent view of the modules that it locates. If <code>find</code> is invoked several times to locate the same module (by name) then it will return the same result each time. If a module is located then it is guaranteed to be a member of the set of modules returned by the <a href="#findAll()"><code>findAll</code></a> method. </p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>name</code> - The name of the module to find</dd> <dt>Returns:</dt> <dd>A reference to a module with the given name or an empty <code>Optional</code> if not found</dd> <dt>Throws:</dt> <dd>
<code><a href="findexception">FindException</a></code> - If an error occurs finding the module</dd> <dd>
<code><a href="../securityexception">SecurityException</a></code> - If denied by the security manager</dd> </dl>    <h3 id="findAll()">findAll</h3> <pre data-language="java">Set&lt;ModuleReference&gt; findAll()</pre> <div>
<p>Returns the set of all module references that this finder can locate. </p>
<p> A <code>ModuleFinder</code> provides a consistent view of the modules that it locates. If <a href="#findAll()"><code>findAll</code></a> is invoked several times then it will return the same (equals) result each time. For each <code>
 ModuleReference</code> element in the returned set then it is guaranteed that <a href="#find(java.lang.String)"><code>find</code></a> will locate the <code>ModuleReference</code> if invoked to find that module. </p>
</div> <dl> <dt>API Note:</dt> <dd>This is important to have for methods such as <a href="configuration#resolveAndBind(java.lang.module.ModuleFinder,java.lang.module.ModuleFinder,java.util.Collection)"><code>resolveAndBind</code></a> that need to scan the module path to find modules that provide a specific service.</dd> <dt>Returns:</dt> <dd>The set of all module references that this finder locates</dd> <dt>Throws:</dt> <dd>
<code><a href="findexception">FindException</a></code> - If an error occurs finding all modules</dd> <dd>
<code><a href="../securityexception">SecurityException</a></code> - If denied by the security manager</dd> </dl>    <h3 id="ofSystem()">ofSystem</h3> <pre data-language="java">static ModuleFinder ofSystem()</pre> <div>
<p>Returns a module finder that locates the <em>system modules</em>. The system modules are the modules in the Java run-time image. The module finder will always find <code>java.base</code>. </p>
<p> If there is a security manager set then its <a href="../securitymanager#checkPermission(java.security.Permission)"><code>checkPermission</code></a> method is invoked to check that the caller has been granted <a href="../runtimepermission"><code>RuntimePermission("accessSystemModules")</code></a> to access the system modules. </p>
</div> <dl> <dt>Returns:</dt> <dd>A <code>ModuleFinder</code> that locates the system modules</dd> <dt>Throws:</dt> <dd>
<code><a href="../securityexception">SecurityException</a></code> - If denied by the security manager</dd> </dl>    <h3 id="of(java.nio.file.Path...)">of</h3> <pre data-language="java">static ModuleFinder of(Path... entries)</pre> <div>
<p>Returns a module finder that locates modules on the file system by searching a sequence of directories and/or packaged modules. Each element in the given array is one of: <ol> <li><p> A path to a directory of modules.</p></li> <li><p> A path to the <em>top-level</em> directory of an <em>exploded module</em>. </p></li> <li><p> A path to a <em>packaged module</em>. </p></li> </ol> The module finder locates modules by searching each directory, exploded module, or packaged module in array index order. It finds the first occurrence of a module with a given name and ignores other modules of that name that appear later in the sequence. </p>
<p> If an element is a path to a directory of modules then each entry in the directory is a packaged module or the top-level directory of an exploded module. It is an error if a directory contains more than one module with the same name. If an element is a path to a directory, and that directory contains a file named <code>module-info.class</code>, then the directory is treated as an exploded module rather than a directory of modules. </p> <p id="automatic-modules"> The module finder returned by this method supports modules packaged as JAR files. A JAR file with a <code>
 module-info.class</code> in its top-level directory, or in a versioned entry in a <a href="../../util/jar/jarfile#isMultiRelease()">multi-release</a> JAR file, is a modular JAR file and thus defines an <em>explicit</em> module. A JAR file that does not have a <code>module-info.class</code> in its top-level directory defines an <em>automatic module</em>, as follows: </p> <ul> <li><p> If the JAR file has the attribute "<code>Automatic-Module-Name</code>" in its main manifest then its value is the <a href="moduledescriptor#name()">module name</a>. The module name is otherwise derived from the name of the JAR file. </p></li> <li>
<p> The <a href="moduledescriptor#version()"><code>version</code></a>, and the module name when the attribute "<code>Automatic-Module-Name</code>" is not present, are derived from the file name of the JAR file as follows: </p> <ul> <li><p> The "<code>.jar</code>" suffix is removed. </p></li> <li><p> If the name matches the regular expression <code>
         "-(\\d+(\\.|$))"</code> then the module name will be derived from the subsequence preceding the hyphen of the first occurrence. The subsequence after the hyphen is parsed as a <a href="moduledescriptor.version"><code>Version</code></a> and ignored if it cannot be parsed as a <code>Version</code>. </p></li> <li><p> All non-alphanumeric characters (<code>[^A-Za-z0-9]</code>) in the module name are replaced with a dot (<code>"."</code>), all repeating dots are replaced with one dot, and all leading and trailing dots are removed. </p></li> <li><p> As an example, a JAR file named "<code>foo-bar.jar</code>" will derive a module name "<code>foo.bar</code>" and no version. A JAR file named "<code>foo-bar-1.2.3-SNAPSHOT.jar</code>" will derive a module name "<code>foo.bar</code>" and "<code>1.2.3-SNAPSHOT</code>" as the version. </p></li> </ul>
</li> <li><p> The set of packages in the module is derived from the non-directory entries in the JAR file that have names ending in "<code>.class</code>". A candidate package name is derived from the name using the characters up to, but not including, the last forward slash. All remaining forward slashes are replaced with dot (<code>"."</code>). If the resulting string is a legal package name then it is assumed to be a package name. For example, if the JAR file contains the entry "<code>p/q/Foo.class</code>" then the package name derived is "<code>p.q</code>".</p></li> <li><p> The contents of entries starting with <code>
     META-INF/services/</code> are assumed to be service configuration files (see <a href="../../util/serviceloader"><code>ServiceLoader</code></a>). If the name of a file (that follows <code>META-INF/services/</code>) is a legal class name then it is assumed to be the fully-qualified class name of a service type. The entries in the file are assumed to be the fully-qualified class names of provider classes. </p></li> <li><p> If the JAR file has a <code>Main-Class</code> attribute in its main manifest, its value is a legal class name, and its package is in the set of packages derived for the module, then the value is the module <a href="moduledescriptor#mainClass()">main class</a>. </p></li> </ul> <p> If a <code>ModuleDescriptor</code> cannot be created (by means of the <a href="moduledescriptor.builder"><code>ModuleDescriptor.Builder</code></a> API) for an automatic module then <code>FindException</code> is thrown. This can arise when the value of the "<code>Automatic-Module-Name</code>" attribute is not a legal module name, a legal module name cannot be derived from the file name of the JAR file, where the JAR file contains a <code>.class</code> in the top-level directory of the JAR file, where an entry in a service configuration file is not a legal class name or its package name is not in the set of packages derived for the module. </p> <p> In addition to JAR files, an implementation may also support modules that are packaged in other implementation specific module formats. If an element in the array specified to this method is a path to a directory of modules then entries in the directory that not recognized as modules are ignored. If an element in the array is a path to a packaged module that is not recognized then a <code>FindException</code> is thrown when the file is encountered. Paths to files that do not exist are always ignored. </p> <p> As with automatic modules, the contents of a packaged or exploded module may need to be <em>scanned</em> in order to determine the packages in the module. Whether <a href="../../nio/file/files#isHidden(java.nio.file.Path)">hidden files</a> are ignored or not is implementation specific and therefore not specified. If a <code>.class</code> file (other than <code>
 module-info.class</code>) is found in the top-level directory then it is assumed to be a class in the unnamed package and so <code>FindException</code> is thrown. </p> <p> Finders created by this method are lazy and do not eagerly check that the given file paths are directories or packaged modules. Consequently, the <code>find</code> or <code>findAll</code> methods will only fail if invoking these methods results in searching a directory or packaged module and an error is encountered. </p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>entries</code> - A possibly-empty array of paths to directories of modules or paths to packaged or exploded modules</dd> <dt>Returns:</dt> <dd>A <code>ModuleFinder</code> that locates modules on the file system</dd> </dl>    <h3 id="compose(java.lang.module.ModuleFinder...)">compose</h3> <pre data-language="java">static ModuleFinder compose(ModuleFinder... finders)</pre> <div>
<p>Returns a module finder that is composed from a sequence of zero or more module finders. The <a href="#find(java.lang.String)"><code>find</code></a> method of the resulting module finder will locate a module by invoking the <code>find</code> method of each module finder, in array index order, until either the module is found or all module finders have been searched. The <a href="#findAll()"><code>findAll</code></a> method of the resulting module finder will return a set of modules that includes all modules located by the first module finder. The set of modules will include all modules located by the second or subsequent module finder that are not located by previous module finders in the sequence. </p>
<p> When locating modules then any exceptions or errors thrown by the <code>find</code> or <code>findAll</code> methods of the underlying module finders will be propagated to the caller of the resulting module finder's <code>find</code> or <code>findAll</code> methods. </p>
</div> <dl> <dt>Parameters:</dt> <dd>
<code>finders</code> - The array of module finders</dd> <dt>Returns:</dt> <dd>A <code>ModuleFinder</code> that composes a sequence of module finders</dd> </dl>   </section>  </div>  </main>  <div class="_attribution">
  <p class="_attribution-p">
    &copy; 1993, 2020, Oracle and/or its affiliates. All rights reserved.<br>Documentation extracted from Debian's OpenJDK Development Kit package.<br>Licensed under the GNU General Public License, version 2, with the Classpath Exception.<br>Various third party code in OpenJDK is licensed under different licenses (see Debian package).<br>Java and OpenJDK are trademarks or registered trademarks of Oracle and/or its affiliates.<br>
    <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/module/ModuleFinder.html" class="_attribution-link">https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/module/ModuleFinder.html</a>
  </p>
</div>
