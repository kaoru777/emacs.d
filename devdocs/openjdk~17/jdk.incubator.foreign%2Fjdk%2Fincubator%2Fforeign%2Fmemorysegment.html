<h1 title="Interface MemorySegment" class="title">Interface MemorySegment</h1> <section class="class-description" id="class-description"> <dl class="notes"> <dt>All Superinterfaces:</dt> <dd><code><a href="addressable" title="interface in jdk.incubator.foreign">Addressable</a></code></dd> </dl>  <pre class="lang-java" data-language="java">public sealed interface MemorySegment extends Addressable</pre> <div class="block">A memory segment models a contiguous region of memory. A memory segment is associated with both spatial and temporal bounds (e.g. a <a href="resourcescope" title="interface in jdk.incubator.foreign"><code>ResourceScope</code></a>). Spatial bounds ensure that memory access operations on a memory segment cannot affect a memory location which falls <em>outside</em> the boundaries of the memory segment being accessed. Temporal bounds ensure that memory access operations on a segment cannot occur after the resource scope associated with a memory segment has been closed (see <a href="resourcescope#close()"><code>ResourceScope.close()</code></a>). <p> All implementations of this interface must be <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/doc-files/ValueBased.html">value-based</a>; programmers should treat instances that are <a href="../../../../java.base/java/lang/object#equals(java.lang.Object)">equal</a> as interchangeable and should not use instances for synchronization, or unpredictable behavior may occur. For example, in a future release, synchronization may fail. The <code>equals</code> method should be used for comparisons. </p>
<p> Non-platform classes should not implement <a href="memorysegment" title="interface in jdk.incubator.foreign">MemorySegment</a> directly. </p>
<p> Unless otherwise specified, passing a <code>null</code> argument, or an array argument containing one or more <code>null</code> elements to a method in this class causes a <a href="../../../../java.base/java/lang/nullpointerexception" title="class in java.lang"><code>NullPointerException</code></a> to be thrown. </p> <h2>Constructing memory segments</h2> There are multiple ways to obtain a memory segment. First, memory segments backed by off-heap memory can be allocated using one of the many factory methods provided (see <a href="#allocateNative(jdk.incubator.foreign.MemoryLayout,jdk.incubator.foreign.ResourceScope)"><code>allocateNative(MemoryLayout, ResourceScope)</code></a>, <a href="#allocateNative(long,jdk.incubator.foreign.ResourceScope)"><code>allocateNative(long, ResourceScope)</code></a> and <a href="#allocateNative(long,long,jdk.incubator.foreign.ResourceScope)"><code>allocateNative(long, long, ResourceScope)</code></a>). Memory segments obtained in this way are called <em>native memory segments</em>. <p> It is also possible to obtain a memory segment backed by an existing heap-allocated Java array, using one of the provided factory methods (e.g. <a href="#ofArray(int%5B%5D)"><code>ofArray(int[])</code></a>). Memory segments obtained in this way are called <em>array memory segments</em>. </p>
<p> It is possible to obtain a memory segment backed by an existing Java byte buffer (see <a href="../../../../java.base/java/nio/bytebuffer" title="class in java.nio"><code>ByteBuffer</code></a>), using the factory method <a href="#ofByteBuffer(java.nio.ByteBuffer)"><code>ofByteBuffer(ByteBuffer)</code></a>. Memory segments obtained in this way are called <em>buffer memory segments</em>. Note that buffer memory segments might be backed by native memory (as in the case of native memory segments) or heap memory (as in the case of array memory segments), depending on the characteristics of the byte buffer instance the segment is associated with. For instance, a buffer memory segment obtained from a byte buffer created with the <a href="../../../../java.base/java/nio/bytebuffer#allocateDirect(int)"><code>ByteBuffer.allocateDirect(int)</code></a> method will be backed by native memory. </p>
<h2>Mapping memory segments from files</h2> It is also possible to obtain a native memory segment backed by a memory-mapped file using the factory method <a href="#mapFile(java.nio.file.Path,long,long,java.nio.channels.FileChannel.MapMode,jdk.incubator.foreign.ResourceScope)"><code>mapFile(Path, long, long, FileChannel.MapMode, ResourceScope)</code></a>. Such native memory segments are called <em>mapped memory segments</em>; mapped memory segments are associated with an underlying file descriptor. <p> Contents of mapped memory segments can be <a href="#force()">persisted</a> and <a href="#load()">loaded</a> to and from the underlying file; these capabilities are suitable replacements for some of the functionality in the <a href="../../../../java.base/java/nio/mappedbytebuffer" title="class in java.nio"><code>MappedByteBuffer</code></a> class. Note that, while it is possible to map a segment into a byte buffer (see <a href="#asByteBuffer()"><code>asByteBuffer()</code></a>), and then call e.g. <a href="../../../../java.base/java/nio/mappedbytebuffer#force()"><code>MappedByteBuffer.force()</code></a> that way, this can only be done when the source segment is small enough, due to the size limitation inherent to the ByteBuffer API. </p>
<p> Clients requiring sophisticated, low-level control over mapped memory segments, should consider writing custom mapped memory segment factories; using <a href="clinker" title="interface in jdk.incubator.foreign"><code>CLinker</code></a>, e.g. on Linux, it is possible to call <code>mmap</code> with the desired parameters; the returned address can be easily wrapped into a memory segment, using <a href="memoryaddress#ofLong(long)"><code>MemoryAddress.ofLong(long)</code></a> and <a href="memoryaddress#asSegment(long,java.lang.Runnable,jdk.incubator.foreign.ResourceScope)"><code>MemoryAddress.asSegment(long, Runnable, ResourceScope)</code></a>. </p>
<h2>Lifecycle and confinement</h2> Memory segments are associated with a resource scope (see <a href="resourcescope" title="interface in jdk.incubator.foreign"><code>ResourceScope</code></a>), which can be accessed using the <a href="#scope()"><code>scope()</code></a> method. As for all resources associated with a resource scope, a segment cannot be accessed after its corresponding scope has been closed. For instance, the following code will result in an exception: <blockquote><pre class="lang-java" data-language="java"><code>
MemorySegment segment = null;
try (ResourceScope scope = ResourceScope.newConfinedScope()) {
    segment = MemorySegment.allocateNative(8, 1, scope);
}
MemoryAccess.getLong(segment); // already closed!
 </code></pre></blockquote> Additionally, access to a memory segment is subject to the thread-confinement checks enforced by the owning scope; that is, if the segment is associated with a shared scope, it can be accessed by multiple threads; if it is associated with a confined scope, it can only be accessed by the thread which owns the scope. <p> Heap and buffer segments are always associated with a <em>global</em>, shared scope. This scope cannot be closed, and can be considered as <em>always alive</em>. </p>
<h2>Memory segment views</h2> Memory segments support <em>views</em>. For instance, it is possible to create an <em>immutable</em> view of a memory segment, as follows: <blockquote><pre class="lang-java" data-language="java"><code>
MemorySegment segment = ...
MemorySegment roSegment = segment.asReadOnly();
 </code></pre></blockquote> It is also possible to create views whose spatial bounds are stricter than the ones of the original segment (see <a href="#asSlice(long,long)"><code>asSlice(long, long)</code></a>). <p> Temporal bounds of the original segment are inherited by the views; that is, when the scope associated with a segment is closed, all the views associated with that segment will also be rendered inaccessible. </p>
<p> To allow for interoperability with existing code, a byte buffer view can be obtained from a memory segment (see <a href="#asByteBuffer()"><code>asByteBuffer()</code></a>). This can be useful, for instance, for those clients that want to keep using the <a href="../../../../java.base/java/nio/bytebuffer" title="class in java.nio"><code>ByteBuffer</code></a> API, but need to operate on large memory segments. Byte buffers obtained in such a way support the same spatial and temporal access restrictions associated with the memory segment from which they originated. </p>
<h2>Stream support</h2> A client might obtain a <a href="../../../../java.base/java/util/stream/stream" title="interface in java.util.stream"><code>Stream</code></a> from a segment, which can then be used to slice the segment (according to a given element layout) and even allow multiple threads to work in parallel on disjoint segment slices (to do this, the segment has to be associated with a shared scope). The following code can be used to sum all int values in a memory segment in parallel: <blockquote><pre class="lang-java" data-language="java"><code>
try (ResourceScope scope = ResourceScope.newSharedScope()) {
    SequenceLayout SEQUENCE_LAYOUT = MemoryLayout.sequenceLayout(1024, MemoryLayouts.JAVA_INT);
    MemorySegment segment = MemorySegment.allocateNative(SEQUENCE_LAYOUT, scope);
    VarHandle VH_int = SEQUENCE_LAYOUT.elementLayout().varHandle(int.class);
    int sum = segment.elements(MemoryLayouts.JAVA_INT).parallel()
                           .mapToInt(s -&gt; (int)VH_int.get(s.address()))
                           .sum();
}
 </code></pre></blockquote>
</div> <dl class="notes"> <dt>Implementation Requirements:</dt> <dd>Implementations of this interface are immutable, thread-safe and <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/doc-files/ValueBased.html">value-based</a>.</dd> </dl> </section> <section class="summary"> <section class="method-summary" id="method-summary"> <h2>Method Summary</h2> <div id="method-summary-table">  <div id="method-summary-table.tabpanel" role="tabpanel"> <table class="summary-table three-column-summary" aria-labelledby="method-summary-table-tab0">                                                                                                                               <tr>
<th>Modifier and Type</th>
<th>Method</th>
<th>Description</th>
</tr>
<tr>
<td><code><a href="memoryaddress" title="interface in jdk.incubator.foreign">MemoryAddress</a></code></td>
<td><code><a href="#address()" class="member-name-link">address</a>()</code></td>
<td> <div class="block">The base memory address associated with this memory segment.</div> </td>
</tr>
<tr>
<td><code>static <a href="memorysegment" title="interface in jdk.incubator.foreign">MemorySegment</a></code></td>
<td><code><a href="#allocateNative(long,long,jdk.incubator.foreign.ResourceScope)" class="member-name-link">allocateNative</a><wbr>(long bytesSize,
 long alignmentBytes,
 <a href="resourcescope" title="interface in jdk.incubator.foreign">ResourceScope</a> scope)</wbr></code></td>
<td> <div class="block">Creates a new confined native memory segment that models a newly allocated block of off-heap memory with given size (in bytes), alignment constraint (in bytes) and resource scope.</div> </td>
</tr>
<tr>
<td><code>static <a href="memorysegment" title="interface in jdk.incubator.foreign">MemorySegment</a></code></td>
<td><code><a href="#allocateNative(long,jdk.incubator.foreign.ResourceScope)" class="member-name-link">allocateNative</a><wbr>(long bytesSize,
 <a href="resourcescope" title="interface in jdk.incubator.foreign">ResourceScope</a> scope)</wbr></code></td>
<td> <div class="block">Creates a new confined native memory segment that models a newly allocated block of off-heap memory with given size (in bytes) and resource scope.</div> </td>
</tr>
<tr>
<td><code>static <a href="memorysegment" title="interface in jdk.incubator.foreign">MemorySegment</a></code></td>
<td><code><a href="#allocateNative(jdk.incubator.foreign.MemoryLayout,jdk.incubator.foreign.ResourceScope)" class="member-name-link">allocateNative</a><wbr>(<a href="memorylayout" title="interface in jdk.incubator.foreign">MemoryLayout</a> layout,
 <a href="resourcescope" title="interface in jdk.incubator.foreign">ResourceScope</a> scope)</wbr></code></td>
<td> <div class="block">Creates a new confined native memory segment that models a newly allocated block of off-heap memory with given layout and resource scope.</div> </td>
</tr>
<tr>
<td><code><a href="../../../../java.base/java/nio/bytebuffer" title="class in java.nio">ByteBuffer</a></code></td>
<td><code><a href="#asByteBuffer()" class="member-name-link">asByteBuffer</a>()</code></td>
<td> <div class="block">Wraps this segment in a <a href="../../../../java.base/java/nio/bytebuffer" title="class in java.nio"><code>ByteBuffer</code></a>.</div> </td>
</tr>
<tr>
<td><code><a href="memorysegment" title="interface in jdk.incubator.foreign">MemorySegment</a></code></td>
<td><code><a href="#asReadOnly()" class="member-name-link">asReadOnly</a>()</code></td>
<td> <div class="block">Obtains a read-only view of this segment.</div> </td>
</tr>
<tr>
<td><code>default <a href="memorysegment" title="interface in jdk.incubator.foreign">MemorySegment</a></code></td>
<td><code><a href="#asSlice(long)" class="member-name-link">asSlice</a><wbr>(long offset)</wbr></code></td>
<td> <div class="block">Obtains a new memory segment view whose base address is the same as the base address of this segment plus a given offset, and whose new size is computed by subtracting the specified offset from this segment size.</div> </td>
</tr>
<tr>
<td><code><a href="memorysegment" title="interface in jdk.incubator.foreign">MemorySegment</a></code></td>
<td><code><a href="#asSlice(long,long)" class="member-name-link">asSlice</a><wbr>(long offset,
 long newSize)</wbr></code></td>
<td> <div class="block">Obtains a new memory segment view whose base address is the same as the base address of this segment plus a given offset, and whose new size is specified by the given argument.</div> </td>
</tr>
<tr>
<td><code>default <a href="memorysegment" title="interface in jdk.incubator.foreign">MemorySegment</a></code></td>
<td><code><a href="#asSlice(jdk.incubator.foreign.MemoryAddress)" class="member-name-link">asSlice</a><wbr>(<a href="memoryaddress" title="interface in jdk.incubator.foreign">MemoryAddress</a> newBase)</wbr></code></td>
<td> <div class="block">Obtains a new memory segment view whose base address is the given address, and whose new size is computed by subtracting the address offset relative to this segment (see <a href="memoryaddress#segmentOffset(jdk.incubator.foreign.MemorySegment)"><code>MemoryAddress.segmentOffset(MemorySegment)</code></a>) from this segment size.</div> </td>
</tr>
<tr>
<td><code>default <a href="memorysegment" title="interface in jdk.incubator.foreign">MemorySegment</a></code></td>
<td><code><a href="#asSlice(jdk.incubator.foreign.MemoryAddress,long)" class="member-name-link">asSlice</a><wbr>(<a href="memoryaddress" title="interface in jdk.incubator.foreign">MemoryAddress</a> newBase,
 long newSize)</wbr></code></td>
<td> <div class="block">Obtains a new memory segment view whose base address is the given address, and whose new size is specified by the given argument.</div> </td>
</tr>
<tr>
<td><code>long</code></td>
<td><code><a href="#byteSize()" class="member-name-link">byteSize</a>()</code></td>
<td> <div class="block">The size (in bytes) of this memory segment.</div> </td>
</tr>
<tr>
<td><code>void</code></td>
<td><code><a href="#copyFrom(jdk.incubator.foreign.MemorySegment)" class="member-name-link">copyFrom</a><wbr>(<a href="memorysegment" title="interface in jdk.incubator.foreign">MemorySegment</a> src)</wbr></code></td>
<td> <div class="block">Performs a bulk copy from given source segment to this segment.</div> </td>
</tr>
<tr>
<td><code><a href="../../../../java.base/java/util/stream/stream" title="interface in java.util.stream">Stream</a>&lt;<a href="memorysegment" title="interface in jdk.incubator.foreign">MemorySegment</a>&gt;</code></td>
<td><code><a href="#elements(jdk.incubator.foreign.MemoryLayout)" class="member-name-link">elements</a><wbr>(<a href="memorylayout" title="interface in jdk.incubator.foreign">MemoryLayout</a> elementLayout)</wbr></code></td>
<td> <div class="block">Returns a sequential <code>Stream</code> over disjoint slices (whose size matches that of the specified layout) in this segment.</div> </td>
</tr>
<tr>
<td><code><a href="memorysegment" title="interface in jdk.incubator.foreign">MemorySegment</a></code></td>
<td><code><a href="#fill(byte)" class="member-name-link">fill</a><wbr>(byte value)</wbr></code></td>
<td> <div class="block">Fills a value into this memory segment.</div> </td>
</tr>
<tr>
<td><code>void</code></td>
<td><code><a href="#force()" class="member-name-link">force</a>()</code></td>
<td> <div class="block">Forces any changes made to the contents of this mapped segment to be written to the storage device described by the mapped segment's file descriptor.</div> </td>
</tr>
<tr>
<td><code>static <a href="memorysegment" title="interface in jdk.incubator.foreign">MemorySegment</a></code></td>
<td><code><a href="#globalNativeSegment()" class="member-name-link">globalNativeSegment</a>()</code></td>
<td> <div class="block">Returns a native memory segment whose base address is <a href="memoryaddress#NULL"><code>MemoryAddress.NULL</code></a> and whose size is <a href="../../../../java.base/java/lang/long#MAX_VALUE"><code>Long.MAX_VALUE</code></a>.</div> </td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code><a href="#isLoaded()" class="member-name-link">isLoaded</a>()</code></td>
<td> <div class="block">Tells whether or not the contents of this mapped segment is resident in physical memory.</div> </td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code><a href="#isMapped()" class="member-name-link">isMapped</a>()</code></td>
<td> <div class="block">Is this a mapped segment?</div> </td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code><a href="#isNative()" class="member-name-link">isNative</a>()</code></td>
<td> <div class="block">Is this a native segment?</div> </td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code><a href="#isReadOnly()" class="member-name-link">isReadOnly</a>()</code></td>
<td> <div class="block">Is this segment read-only?</div> </td>
</tr>
<tr>
<td><code>void</code></td>
<td><code><a href="#load()" class="member-name-link">load</a>()</code></td>
<td> <div class="block">Loads the contents of this mapped segment into physical memory.</div> </td>
</tr>
<tr>
<td><code>static <a href="memorysegment" title="interface in jdk.incubator.foreign">MemorySegment</a></code></td>
<td><code><a href="#mapFile(java.nio.file.Path,long,long,java.nio.channels.FileChannel.MapMode,jdk.incubator.foreign.ResourceScope)" class="member-name-link">mapFile</a><wbr>(<a href="../../../../java.base/java/nio/file/path" title="interface in java.nio.file">Path</a> path,
 long bytesOffset,
 long bytesSize,
 <a href="../../../../java.base/java/nio/channels/filechannel.mapmode" title="class in java.nio.channels">FileChannel.MapMode</a> mapMode,
 <a href="resourcescope" title="interface in jdk.incubator.foreign">ResourceScope</a> scope)</wbr></code></td>
<td> <div class="block">Creates a new mapped memory segment that models a memory-mapped region of a file from a given path.</div> </td>
</tr>
<tr>
<td><code>long</code></td>
<td><code><a href="#mismatch(jdk.incubator.foreign.MemorySegment)" class="member-name-link">mismatch</a><wbr>(<a href="memorysegment" title="interface in jdk.incubator.foreign">MemorySegment</a> other)</wbr></code></td>
<td> <div class="block">Finds and returns the offset, in bytes, of the first mismatch between this segment and a given other segment.</div> </td>
</tr>
<tr>
<td><code>static <a href="memorysegment" title="interface in jdk.incubator.foreign">MemorySegment</a></code></td>
<td><code><a href="#ofArray(byte%5B%5D)" class="member-name-link">ofArray</a><wbr>(byte[] arr)</wbr></code></td>
<td> <div class="block">Creates a new confined array memory segment that models the memory associated with a given heap-allocated byte array.</div> </td>
</tr>
<tr>
<td><code>static <a href="memorysegment" title="interface in jdk.incubator.foreign">MemorySegment</a></code></td>
<td><code><a href="#ofArray(char%5B%5D)" class="member-name-link">ofArray</a><wbr>(char[] arr)</wbr></code></td>
<td> <div class="block">Creates a new confined array memory segment that models the memory associated with a given heap-allocated char array.</div> </td>
</tr>
<tr>
<td><code>static <a href="memorysegment" title="interface in jdk.incubator.foreign">MemorySegment</a></code></td>
<td><code><a href="#ofArray(double%5B%5D)" class="member-name-link">ofArray</a><wbr>(double[] arr)</wbr></code></td>
<td> <div class="block">Creates a new confined array memory segment that models the memory associated with a given heap-allocated double array.</div> </td>
</tr>
<tr>
<td><code>static <a href="memorysegment" title="interface in jdk.incubator.foreign">MemorySegment</a></code></td>
<td><code><a href="#ofArray(float%5B%5D)" class="member-name-link">ofArray</a><wbr>(float[] arr)</wbr></code></td>
<td> <div class="block">Creates a new confined array memory segment that models the memory associated with a given heap-allocated float array.</div> </td>
</tr>
<tr>
<td><code>static <a href="memorysegment" title="interface in jdk.incubator.foreign">MemorySegment</a></code></td>
<td><code><a href="#ofArray(int%5B%5D)" class="member-name-link">ofArray</a><wbr>(int[] arr)</wbr></code></td>
<td> <div class="block">Creates a new confined array memory segment that models the memory associated with a given heap-allocated int array.</div> </td>
</tr>
<tr>
<td><code>static <a href="memorysegment" title="interface in jdk.incubator.foreign">MemorySegment</a></code></td>
<td><code><a href="#ofArray(long%5B%5D)" class="member-name-link">ofArray</a><wbr>(long[] arr)</wbr></code></td>
<td> <div class="block">Creates a new confined array memory segment that models the memory associated with a given heap-allocated long array.</div> </td>
</tr>
<tr>
<td><code>static <a href="memorysegment" title="interface in jdk.incubator.foreign">MemorySegment</a></code></td>
<td><code><a href="#ofArray(short%5B%5D)" class="member-name-link">ofArray</a><wbr>(short[] arr)</wbr></code></td>
<td> <div class="block">Creates a new confined array memory segment that models the memory associated with a given heap-allocated short array.</div> </td>
</tr>
<tr>
<td><code>static <a href="memorysegment" title="interface in jdk.incubator.foreign">MemorySegment</a></code></td>
<td><code><a href="#ofByteBuffer(java.nio.ByteBuffer)" class="member-name-link">ofByteBuffer</a><wbr>(<a href="../../../../java.base/java/nio/bytebuffer" title="class in java.nio">ByteBuffer</a> bb)</wbr></code></td>
<td> <div class="block">Creates a new confined buffer memory segment that models the memory associated with the given byte buffer.</div> </td>
</tr>
<tr>
<td><code><a href="resourcescope" title="interface in jdk.incubator.foreign">ResourceScope</a></code></td>
<td><code><a href="#scope()" class="member-name-link">scope</a>()</code></td>
<td> <div class="block">Returns the resource scope associated with this memory segment.</div> </td>
</tr>
<tr>
<td><code><a href="../../../../java.base/java/util/spliterator" title="interface in java.util">Spliterator</a>&lt;<a href="memorysegment" title="interface in jdk.incubator.foreign">MemorySegment</a>&gt;</code></td>
<td><code><a href="#spliterator(jdk.incubator.foreign.MemoryLayout)" class="member-name-link">spliterator</a><wbr>(<a href="memorylayout" title="interface in jdk.incubator.foreign">MemoryLayout</a> elementLayout)</wbr></code></td>
<td> <div class="block">Returns a spliterator for this memory segment.</div> </td>
</tr>
<tr>
<td><code>byte[]</code></td>
<td><code><a href="#toByteArray()" class="member-name-link">toByteArray</a>()</code></td>
<td> <div class="block">Copy the contents of this memory segment into a fresh byte array.</div> </td>
</tr>
<tr>
<td><code>char[]</code></td>
<td><code><a href="#toCharArray()" class="member-name-link">toCharArray</a>()</code></td>
<td> <div class="block">Copy the contents of this memory segment into a fresh char array.</div> </td>
</tr>
<tr>
<td><code>double[]</code></td>
<td><code><a href="#toDoubleArray()" class="member-name-link">toDoubleArray</a>()</code></td>
<td> <div class="block">Copy the contents of this memory segment into a fresh double array.</div> </td>
</tr>
<tr>
<td><code>float[]</code></td>
<td><code><a href="#toFloatArray()" class="member-name-link">toFloatArray</a>()</code></td>
<td> <div class="block">Copy the contents of this memory segment into a fresh float array.</div> </td>
</tr>
<tr>
<td><code>int[]</code></td>
<td><code><a href="#toIntArray()" class="member-name-link">toIntArray</a>()</code></td>
<td> <div class="block">Copy the contents of this memory segment into a fresh int array.</div> </td>
</tr>
<tr>
<td><code>long[]</code></td>
<td><code><a href="#toLongArray()" class="member-name-link">toLongArray</a>()</code></td>
<td> <div class="block">Copy the contents of this memory segment into a fresh long array.</div> </td>
</tr>
<tr>
<td><code>short[]</code></td>
<td><code><a href="#toShortArray()" class="member-name-link">toShortArray</a>()</code></td>
<td> <div class="block">Copy the contents of this memory segment into a fresh short array.</div> </td>
</tr>
<tr>
<td><code>void</code></td>
<td><code><a href="#unload()" class="member-name-link">unload</a>()</code></td>
<td> <div class="block">Unloads the contents of this mapped segment from physical memory.</div> </td>
</tr>
</table> </div> </div> </section> </section> <section class="details"> <section class="method-details" id="method-detail"> <h2>Method Details</h2>  </section><section class="detail" id="address()"> <h3>address</h3> <pre class="lang-java" data-language="java">MemoryAddress address()</pre> <div class="block">The base memory address associated with this memory segment. The returned memory address is associated with same resource scope as that associated with this segment.</div> <dl class="notes"> <dt>Specified by:</dt> <dd>
<code><a href="addressable#address()">address</a></code> in interface <code><a href="addressable" title="interface in jdk.incubator.foreign">Addressable</a></code>
</dd> <dt>Returns:</dt> <dd>The base memory address.</dd> </dl> </section><section class="detail" id="spliterator(jdk.incubator.foreign.MemoryLayout)"> <h3>spliterator</h3> <pre class="lang-java" data-language="java">Spliterator&lt;MemorySegment&gt; spliterator(MemoryLayout elementLayout)</pre> <div class="block">Returns a spliterator for this memory segment. The returned spliterator reports <a href="../../../../java.base/java/util/spliterator#SIZED"><code>Spliterator.SIZED</code></a>, <a href="../../../../java.base/java/util/spliterator#SUBSIZED"><code>Spliterator.SUBSIZED</code></a>, <a href="../../../../java.base/java/util/spliterator#IMMUTABLE"><code>Spliterator.IMMUTABLE</code></a>, <a href="../../../../java.base/java/util/spliterator#NONNULL"><code>Spliterator.NONNULL</code></a> and <a href="../../../../java.base/java/util/spliterator#ORDERED"><code>Spliterator.ORDERED</code></a> characteristics. <p> The returned spliterator splits this segment according to the specified element layout; that is, if the supplied layout has size N, then calling <a href="../../../../java.base/java/util/spliterator#trySplit()"><code>Spliterator.trySplit()</code></a> will result in a spliterator serving approximately <code>S/N/2</code> elements (depending on whether N is even or not), where <code>S</code> is the size of this segment. As such, splitting is possible as long as <code>S/N &gt;= 2</code>. The spliterator returns segments that feature the same scope as this given segment. </p>
<p> The returned spliterator effectively allows to slice this segment into disjoint sub-segments, which can then be processed in parallel by multiple threads.</p>
</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>elementLayout</code> - the layout to be used for splitting.</dd> <dt>Returns:</dt> <dd>the element spliterator for this segment</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.base/java/lang/illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if the <code>elementLayout</code> size is zero, or the segment size modulo the <code>elementLayout</code> size is greater than zero.</dd> </dl> </section><section class="detail" id="elements(jdk.incubator.foreign.MemoryLayout)"> <h3>elements</h3> <pre class="lang-java" data-language="java">Stream&lt;MemorySegment&gt; elements(MemoryLayout elementLayout)</pre> <div class="block">Returns a sequential <code>Stream</code> over disjoint slices (whose size matches that of the specified layout) in this segment. Calling this method is equivalent to the following code: <blockquote><pre class="lang-java" data-language="java"><code>
    StreamSupport.stream(segment.spliterator(elementLayout), false);
 </code></pre></blockquote>
</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>elementLayout</code> - the layout to be used for splitting.</dd> <dt>Returns:</dt> <dd>a sequential <code>Stream</code> over disjoint slices in this segment.</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.base/java/lang/illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if the <code>elementLayout</code> size is zero, or the segment size modulo the <code>elementLayout</code> size is greater than zero.</dd> </dl> </section><section class="detail" id="scope()"> <h3>scope</h3> <pre class="lang-java" data-language="java">ResourceScope scope()</pre> <div class="block">Returns the resource scope associated with this memory segment.</div> <dl class="notes"> <dt>Returns:</dt> <dd>the resource scope associated with this memory segment.</dd> </dl> </section><section class="detail" id="byteSize()"> <h3>byteSize</h3> <pre class="lang-java" data-language="java">long byteSize()</pre> <div class="block">The size (in bytes) of this memory segment.</div> <dl class="notes"> <dt>Returns:</dt> <dd>The size (in bytes) of this memory segment.</dd> </dl> </section><section class="detail" id="asSlice(long,long)"> <h3>asSlice</h3> <pre class="lang-java" data-language="java">MemorySegment asSlice(long offset, long newSize)</pre> <div class="block">Obtains a new memory segment view whose base address is the same as the base address of this segment plus a given offset, and whose new size is specified by the given argument.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>offset</code> - The new segment base offset (relative to the current segment base address), specified in bytes.</dd> <dd>
<code>newSize</code> - The new segment size, specified in bytes.</dd> <dt>Returns:</dt> <dd>a new memory segment view with updated base/limit addresses.</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.base/java/lang/indexoutofboundsexception" title="class in java.lang">IndexOutOfBoundsException</a></code> - if <code>offset &lt; 0</code>, <code>offset &gt; byteSize()</code>, <code>newSize &lt; 0</code>, or <code>newSize &gt; byteSize() - offset</code>
</dd> <dt>See Also:</dt> <dd> <ul class="see-list-long"> <li><a href="#asSlice(long)"><code>asSlice(long)</code></a></li> <li><a href="#asSlice(jdk.incubator.foreign.MemoryAddress)"><code>asSlice(MemoryAddress)</code></a></li> <li><a href="#asSlice(jdk.incubator.foreign.MemoryAddress,long)"><code>asSlice(MemoryAddress, long)</code></a></li> </ul> </dd> </dl> </section><section class="detail" id="asSlice(jdk.incubator.foreign.MemoryAddress,long)"> <h3>asSlice</h3> <pre class="lang-java" data-language="java">default MemorySegment asSlice(MemoryAddress newBase, long newSize)</pre> <div class="block">Obtains a new memory segment view whose base address is the given address, and whose new size is specified by the given argument. <p> Equivalent to the following code: </p>
<pre class="lang-java" data-language="java"><code>
    asSlice(newBase.segmentOffset(this), newSize);
 </code></pre>
</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>newBase</code> - The new segment base address.</dd> <dd>
<code>newSize</code> - The new segment size, specified in bytes.</dd> <dt>Returns:</dt> <dd>a new memory segment view with updated base/limit addresses.</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.base/java/lang/indexoutofboundsexception" title="class in java.lang">IndexOutOfBoundsException</a></code> - if <code>offset &lt; 0</code>, <code>offset &gt; byteSize()</code>, <code>newSize &lt; 0</code>, or <code>newSize &gt; byteSize() - offset</code>
</dd> <dt>See Also:</dt> <dd> <ul class="see-list-long"> <li><a href="#asSlice(long)"><code>asSlice(long)</code></a></li> <li><a href="#asSlice(jdk.incubator.foreign.MemoryAddress)"><code>asSlice(MemoryAddress)</code></a></li> <li><a href="#asSlice(long,long)"><code>asSlice(long, long)</code></a></li> </ul> </dd> </dl> </section><section class="detail" id="asSlice(long)"> <h3>asSlice</h3> <pre class="lang-java" data-language="java">default MemorySegment asSlice(long offset)</pre> <div class="block">Obtains a new memory segment view whose base address is the same as the base address of this segment plus a given offset, and whose new size is computed by subtracting the specified offset from this segment size. <p> Equivalent to the following code: </p>
<pre class="lang-java" data-language="java"><code>
    asSlice(offset, byteSize() - offset);
 </code></pre>
</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>offset</code> - The new segment base offset (relative to the current segment base address), specified in bytes.</dd> <dt>Returns:</dt> <dd>a new memory segment view with updated base/limit addresses.</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.base/java/lang/indexoutofboundsexception" title="class in java.lang">IndexOutOfBoundsException</a></code> - if <code>offset &lt; 0</code>, or <code>offset &gt; byteSize()</code>.</dd> <dt>See Also:</dt> <dd> <ul class="see-list-long"> <li><a href="#asSlice(jdk.incubator.foreign.MemoryAddress)"><code>asSlice(MemoryAddress)</code></a></li> <li><a href="#asSlice(jdk.incubator.foreign.MemoryAddress,long)"><code>asSlice(MemoryAddress, long)</code></a></li> <li><a href="#asSlice(long,long)"><code>asSlice(long, long)</code></a></li> </ul> </dd> </dl> </section><section class="detail" id="asSlice(jdk.incubator.foreign.MemoryAddress)"> <h3>asSlice</h3> <pre class="lang-java" data-language="java">default MemorySegment asSlice(MemoryAddress newBase)</pre> <div class="block">Obtains a new memory segment view whose base address is the given address, and whose new size is computed by subtracting the address offset relative to this segment (see <a href="memoryaddress#segmentOffset(jdk.incubator.foreign.MemorySegment)"><code>MemoryAddress.segmentOffset(MemorySegment)</code></a>) from this segment size. <p> Equivalent to the following code: </p>
<pre class="lang-java" data-language="java"><code>
    asSlice(newBase.segmentOffset(this));
 </code></pre>
</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>newBase</code> - The new segment base offset (relative to the current segment base address), specified in bytes.</dd> <dt>Returns:</dt> <dd>a new memory segment view with updated base/limit addresses.</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.base/java/lang/indexoutofboundsexception" title="class in java.lang">IndexOutOfBoundsException</a></code> - if <code>address.segmentOffset(this) &lt; 0</code>, or <code>address.segmentOffset(this) &gt; byteSize()</code>.</dd> <dt>See Also:</dt> <dd> <ul class="see-list-long"> <li><a href="#asSlice(long)"><code>asSlice(long)</code></a></li> <li><a href="#asSlice(jdk.incubator.foreign.MemoryAddress,long)"><code>asSlice(MemoryAddress, long)</code></a></li> <li><a href="#asSlice(long,long)"><code>asSlice(long, long)</code></a></li> </ul> </dd> </dl> </section><section class="detail" id="isReadOnly()"> <h3>isReadOnly</h3> <pre class="lang-java" data-language="java">boolean isReadOnly()</pre> <div class="block">Is this segment read-only?</div> <dl class="notes"> <dt>Returns:</dt> <dd>
<code>true</code>, if this segment is read-only.</dd> <dt>See Also:</dt> <dd> <ul class="see-list"> <li><a href="#asReadOnly()"><code>asReadOnly()</code></a></li> </ul> </dd> </dl> </section><section class="detail" id="asReadOnly()"> <h3>asReadOnly</h3> <pre class="lang-java" data-language="java">MemorySegment asReadOnly()</pre> <div class="block">Obtains a read-only view of this segment. The resulting segment will be identical to this one, but attempts to overwrite the contents of the returned segment will cause runtime exceptions.</div> <dl class="notes"> <dt>Returns:</dt> <dd>a read-only view of this segment</dd> <dt>See Also:</dt> <dd> <ul class="see-list"> <li><a href="#isReadOnly()"><code>isReadOnly()</code></a></li> </ul> </dd> </dl> </section><section class="detail" id="isNative()"> <h3>isNative</h3> <pre class="lang-java" data-language="java">boolean isNative()</pre> <div class="block">Is this a native segment? Returns true if this segment is a native memory segment, created using the <a href="#allocateNative(long,jdk.incubator.foreign.ResourceScope)"><code>allocateNative(long, ResourceScope)</code></a> (and related) factory, or a buffer segment derived from a direct <a href="../../../../java.base/java/nio/bytebuffer" title="class in java.nio"><code>ByteBuffer</code></a> using the <a href="#ofByteBuffer(java.nio.ByteBuffer)"><code>ofByteBuffer(ByteBuffer)</code></a> factory, or if this is a <a href="#isMapped()">mapped</a> segment.</div> <dl class="notes"> <dt>Returns:</dt> <dd>
<code>true</code> if this segment is native segment.</dd> </dl> </section><section class="detail" id="isMapped()"> <h3>isMapped</h3> <pre class="lang-java" data-language="java">boolean isMapped()</pre> <div class="block">Is this a mapped segment? Returns true if this segment is a mapped memory segment, created using the <a href="#mapFile(java.nio.file.Path,long,long,java.nio.channels.FileChannel.MapMode,jdk.incubator.foreign.ResourceScope)"><code>mapFile(Path, long, long, FileChannel.MapMode, ResourceScope)</code></a> factory, or a buffer segment derived from a <a href="../../../../java.base/java/nio/mappedbytebuffer" title="class in java.nio"><code>MappedByteBuffer</code></a> using the <a href="#ofByteBuffer(java.nio.ByteBuffer)"><code>ofByteBuffer(ByteBuffer)</code></a> factory.</div> <dl class="notes"> <dt>Returns:</dt> <dd>
<code>true</code> if this segment is a mapped segment.</dd> </dl> </section><section class="detail" id="fill(byte)"> <h3>fill</h3> <pre class="lang-java" data-language="java">MemorySegment fill(byte value)</pre> <div class="block">Fills a value into this memory segment. <p> More specifically, the given value is filled into each address of this segment. Equivalent to (but likely more efficient than) the following code: </p>
<pre class="lang-java" data-language="java"><code>
byteHandle = MemoryLayout.ofSequence(MemoryLayouts.JAVA_BYTE)
         .varHandle(byte.class, MemoryLayout.PathElement.sequenceElement());
for (long l = 0; l &lt; segment.byteSize(); l++) {
     byteHandle.set(segment.address(), l, value);
}
 </code></pre> without any regard or guarantees on the ordering of particular memory elements being set. <p> Fill can be useful to initialize or reset the memory of a segment.</p>
</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>value</code> - the value to fill into this segment</dd> <dt>Returns:</dt> <dd>this memory segment</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.base/java/lang/illegalstateexception" title="class in java.lang">IllegalStateException</a></code> - if the scope associated with this segment has been closed, or if access occurs from a thread other than the thread owning that scope,</dd> <dd>
<code><a href="../../../../java.base/java/lang/unsupportedoperationexception" title="class in java.lang">UnsupportedOperationException</a></code> - if this segment is read-only (see <a href="#isReadOnly()"><code>isReadOnly()</code></a>).</dd> </dl> </section><section class="detail" id="copyFrom(jdk.incubator.foreign.MemorySegment)"> <h3>copyFrom</h3> <pre class="lang-java" data-language="java">void copyFrom(MemorySegment src)</pre> <div class="block">Performs a bulk copy from given source segment to this segment. More specifically, the bytes at offset <code>0</code> through <code>src.byteSize() - 1</code> in the source segment are copied into this segment at offset <code>0</code> through <code>src.byteSize() - 1</code>. If the source segment overlaps with this segment, then the copying is performed as if the bytes at offset <code>0</code> through <code>src.byteSize() - 1</code> in the source segment were first copied into a temporary segment with size <code>bytes</code>, and then the contents of the temporary segment were copied into this segment at offset <code>0</code> through <code>src.byteSize() - 1</code>. <p> The result of a bulk copy is unspecified if, in the uncommon case, the source segment and this segment do not overlap, but refer to overlapping regions of the same backing storage using different addresses. For example, this may occur if the same file is <a href="#mapFile(java.nio.file.Path,long,long,java.nio.channels.FileChannel.MapMode,jdk.incubator.foreign.ResourceScope)">mapped</a> to two segments.</p>
</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>src</code> - the source segment.</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.base/java/lang/indexoutofboundsexception" title="class in java.lang">IndexOutOfBoundsException</a></code> - if <code>src.byteSize() &gt; this.byteSize()</code>.</dd> <dd>
<code><a href="../../../../java.base/java/lang/illegalstateexception" title="class in java.lang">IllegalStateException</a></code> - if either the scope associated with the source segment or the scope associated with this segment have been already closed, or if access occurs from a thread other than the thread owning either scopes.</dd> <dd>
<code><a href="../../../../java.base/java/lang/unsupportedoperationexception" title="class in java.lang">UnsupportedOperationException</a></code> - if this segment is read-only (see <a href="#isReadOnly()"><code>isReadOnly()</code></a>).</dd> </dl> </section><section class="detail" id="mismatch(jdk.incubator.foreign.MemorySegment)"> <h3>mismatch</h3> <pre class="lang-java" data-language="java">long mismatch(MemorySegment other)</pre> <div class="block">Finds and returns the offset, in bytes, of the first mismatch between this segment and a given other segment. The offset is relative to the <a href="#address()">base address</a> of each segment and will be in the range of 0 (inclusive) up to the <a href="#byteSize()">size</a> (in bytes) of the smaller memory segment (exclusive). <p> If the two segments share a common prefix then the returned offset is the length of the common prefix and it follows that there is a mismatch between the two segments at that offset within the respective segments. If one segment is a proper prefix of the other then the returned offset is the smaller of the segment sizes, and it follows that the offset is only valid for the larger segment. Otherwise, there is no mismatch and <code>
 -1</code> is returned.</p>
</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>other</code> - the segment to be tested for a mismatch with this segment</dd> <dt>Returns:</dt> <dd>the relative offset, in bytes, of the first mismatch between this and the given other segment, otherwise -1 if no mismatch</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.base/java/lang/illegalstateexception" title="class in java.lang">IllegalStateException</a></code> - if either the scope associated with this segment or the scope associated with the <code>other</code> segment have been already closed, or if access occurs from a thread other than the thread owning either scopes.</dd> </dl> </section><section class="detail" id="isLoaded()"> <h3>isLoaded</h3> <pre class="lang-java" data-language="java">boolean isLoaded()</pre> <div class="block">Tells whether or not the contents of this mapped segment is resident in physical memory. <p> A return value of <code>true</code> implies that it is highly likely that all of the data in this segment is resident in physical memory and may therefore be accessed without incurring any virtual-memory page faults or I/O operations. A return value of <code>false</code> does not necessarily imply that this segment's content is not resident in physical memory. </p>
<p> The returned value is a hint, rather than a guarantee, because the underlying operating system may have paged out some of this segment's data by the time that an invocation of this method returns. </p>
</div> <dl class="notes"> <dt>Returns:</dt> <dd>
<code>true</code> if it is likely that the contents of this segment is resident in physical memory</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.base/java/lang/illegalstateexception" title="class in java.lang">IllegalStateException</a></code> - if the scope associated with this segment has been closed, or if access occurs from a thread other than the thread owning that scope.</dd> <dd>
<code><a href="../../../../java.base/java/lang/unsupportedoperationexception" title="class in java.lang">UnsupportedOperationException</a></code> - if this segment is not a mapped memory segment, e.g. if <code>isMapped() == false</code>.</dd> </dl> </section><section class="detail" id="load()"> <h3>load</h3> <pre class="lang-java" data-language="java">void load()</pre> <div class="block">Loads the contents of this mapped segment into physical memory. <p> This method makes a best effort to ensure that, when it returns, this contents of this segment is resident in physical memory. Invoking this method may cause some number of page faults and I/O operations to occur. </p>
</div> <dl class="notes"> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.base/java/lang/illegalstateexception" title="class in java.lang">IllegalStateException</a></code> - if the scope associated with this segment has been closed, or if access occurs from a thread other than the thread owning that scope.</dd> <dd>
<code><a href="../../../../java.base/java/lang/unsupportedoperationexception" title="class in java.lang">UnsupportedOperationException</a></code> - if this segment is not a mapped memory segment, e.g. if <code>isMapped() == false</code>.</dd> </dl> </section><section class="detail" id="unload()"> <h3>unload</h3> <pre class="lang-java" data-language="java">void unload()</pre> <div class="block">Unloads the contents of this mapped segment from physical memory. <p> This method makes a best effort to ensure that the contents of this segment are are no longer resident in physical memory. Accessing this segment's contents after invoking this method may cause some number of page faults and I/O operations to occur (as this segment's contents might need to be paged back in). </p>
</div> <dl class="notes"> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.base/java/lang/illegalstateexception" title="class in java.lang">IllegalStateException</a></code> - if the scope associated with this segment has been closed, or if access occurs from a thread other than the thread owning that scope.</dd> <dd>
<code><a href="../../../../java.base/java/lang/unsupportedoperationexception" title="class in java.lang">UnsupportedOperationException</a></code> - if this segment is not a mapped memory segment, e.g. if <code>isMapped() == false</code>.</dd> </dl> </section><section class="detail" id="force()"> <h3>force</h3> <pre class="lang-java" data-language="java">void force()</pre> <div class="block">Forces any changes made to the contents of this mapped segment to be written to the storage device described by the mapped segment's file descriptor. <p> If the file descriptor associated with this mapped segment resides on a local storage device then when this method returns it is guaranteed that all changes made to this segment since it was created, or since this method was last invoked, will have been written to that device. </p>
<p> If the file descriptor associated with this mapped segment does not reside on a local device then no such guarantee is made. </p>
<p> If this segment was not mapped in read/write mode (<a href="../../../../java.base/java/nio/channels/filechannel.mapmode#READ_WRITE"><code>FileChannel.MapMode.READ_WRITE</code></a>) then invoking this method may have no effect. In particular, the method has no effect for segments mapped in read-only or private mapping modes. This method may or may not have an effect for implementation-specific mapping modes. </p>
</div> <dl class="notes"> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.base/java/lang/illegalstateexception" title="class in java.lang">IllegalStateException</a></code> - if the scope associated with this segment has been closed, or if access occurs from a thread other than the thread owning that scope.</dd> <dd>
<code><a href="../../../../java.base/java/lang/unsupportedoperationexception" title="class in java.lang">UnsupportedOperationException</a></code> - if this segment is not a mapped memory segment, e.g. if <code>isMapped() == false</code>.</dd> <dd>
<code><a href="../../../../java.base/java/io/uncheckedioexception" title="class in java.io">UncheckedIOException</a></code> - if there is an I/O error writing the contents of this segment to the associated storage device</dd> </dl> </section><section class="detail" id="asByteBuffer()"> <h3>asByteBuffer</h3> <pre class="lang-java" data-language="java">ByteBuffer asByteBuffer()</pre> <div class="block">Wraps this segment in a <a href="../../../../java.base/java/nio/bytebuffer" title="class in java.nio"><code>ByteBuffer</code></a>. Some of the properties of the returned buffer are linked to the properties of this segment. For instance, if this segment is <em>immutable</em> (e.g. the segment is a read-only segment, see <a href="#isReadOnly()"><code>isReadOnly()</code></a>), then the resulting buffer is <em>read-only</em> (see <a href="../../../../java.base/java/nio/buffer#isReadOnly()"><code>Buffer.isReadOnly()</code></a>. Additionally, if this is a native memory segment, the resulting buffer is <em>direct</em> (see <a href="../../../../java.base/java/nio/bytebuffer#isDirect()"><code>ByteBuffer.isDirect()</code></a>). <p> The returned buffer's position (see <a href="../../../../java.base/java/nio/buffer#position()"><code>Buffer.position()</code></a> is initially set to zero, while the returned buffer's capacity and limit (see <a href="../../../../java.base/java/nio/buffer#capacity()"><code>Buffer.capacity()</code></a> and <a href="../../../../java.base/java/nio/buffer#limit()"><code>Buffer.limit()</code></a>, respectively) are set to this segment' size (see <a href="#byteSize()"><code>byteSize()</code></a>). For this reason, a byte buffer cannot be returned if this segment' size is greater than <a href="../../../../java.base/java/lang/integer#MAX_VALUE"><code>Integer.MAX_VALUE</code></a>. </p>
<p> The life-cycle of the returned buffer will be tied to that of this segment. That is, accessing the returned buffer after the scope associated with this segment has been closed (see <a href="resourcescope#close()"><code>ResourceScope.close()</code></a>, will throw an <a href="../../../../java.base/java/lang/illegalstateexception" title="class in java.lang"><code>IllegalStateException</code></a>. </p>
<p> If this segment is associated with a confined scope, calling read/write I/O operations on the resulting buffer might result in an unspecified exception being thrown. Examples of such problematic operations are <a href="../../../../java.base/java/nio/channels/asynchronoussocketchannel#read(java.nio.ByteBuffer)"><code>AsynchronousSocketChannel.read(ByteBuffer)</code></a> and <a href="../../../../java.base/java/nio/channels/asynchronoussocketchannel#write(java.nio.ByteBuffer)"><code>AsynchronousSocketChannel.write(ByteBuffer)</code></a>. </p>
<p> Finally, the resulting buffer's byte order is <a href="../../../../java.base/java/nio/byteorder#BIG_ENDIAN"><code>ByteOrder.BIG_ENDIAN</code></a>; this can be changed using <a href="../../../../java.base/java/nio/bytebuffer#order(java.nio.ByteOrder)"><code>ByteBuffer.order(java.nio.ByteOrder)</code></a>.</p>
</div> <dl class="notes"> <dt>Returns:</dt> <dd>a <a href="../../../../java.base/java/nio/bytebuffer" title="class in java.nio"><code>ByteBuffer</code></a> view of this memory segment.</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.base/java/lang/unsupportedoperationexception" title="class in java.lang">UnsupportedOperationException</a></code> - if this segment cannot be mapped onto a <a href="../../../../java.base/java/nio/bytebuffer" title="class in java.nio"><code>ByteBuffer</code></a> instance, e.g. because it models an heap-based segment that is not based on a <code>byte[]</code>), or if its size is greater than <a href="../../../../java.base/java/lang/integer#MAX_VALUE"><code>Integer.MAX_VALUE</code></a>.</dd> </dl> </section><section class="detail" id="toByteArray()"> <h3>toByteArray</h3> <pre class="lang-java" data-language="java">byte[] toByteArray()</pre> <div class="block">Copy the contents of this memory segment into a fresh byte array.</div> <dl class="notes"> <dt>Returns:</dt> <dd>a fresh byte array copy of this memory segment.</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.base/java/lang/illegalstateexception" title="class in java.lang">IllegalStateException</a></code> - if the scope associated with this segment has been closed, or if access occurs from a thread other than the thread owning that scope, or if this segment's contents cannot be copied into a <code>byte</code> instance, e.g. its size is greater than <a href="../../../../java.base/java/lang/integer#MAX_VALUE"><code>Integer.MAX_VALUE</code></a>.</dd> </dl> </section><section class="detail" id="toShortArray()"> <h3>toShortArray</h3> <pre class="lang-java" data-language="java">short[] toShortArray()</pre> <div class="block">Copy the contents of this memory segment into a fresh short array.</div> <dl class="notes"> <dt>Returns:</dt> <dd>a fresh short array copy of this memory segment.</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.base/java/lang/illegalstateexception" title="class in java.lang">IllegalStateException</a></code> - if the scope associated with this segment has been closed, or if access occurs from a thread other than the thread owning that scope, or if this segment's contents cannot be copied into a <code>short</code> instance, e.g. because <code>byteSize() % 2 != 0</code>, or <code>byteSize() / 2 &gt; Integer#MAX_VALUE</code>
</dd> </dl> </section><section class="detail" id="toCharArray()"> <h3>toCharArray</h3> <pre class="lang-java" data-language="java">char[] toCharArray()</pre> <div class="block">Copy the contents of this memory segment into a fresh char array.</div> <dl class="notes"> <dt>Returns:</dt> <dd>a fresh char array copy of this memory segment.</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.base/java/lang/illegalstateexception" title="class in java.lang">IllegalStateException</a></code> - if the scope associated with this segment has been closed, or if access occurs from a thread other than the thread owning that scope, or if this segment's contents cannot be copied into a <code>char</code> instance, e.g. because <code>byteSize() % 2 != 0</code>, or <code>byteSize() / 2 &gt; Integer#MAX_VALUE</code>.</dd> </dl> </section><section class="detail" id="toIntArray()"> <h3>toIntArray</h3> <pre class="lang-java" data-language="java">int[] toIntArray()</pre> <div class="block">Copy the contents of this memory segment into a fresh int array.</div> <dl class="notes"> <dt>Returns:</dt> <dd>a fresh int array copy of this memory segment.</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.base/java/lang/illegalstateexception" title="class in java.lang">IllegalStateException</a></code> - if the scope associated with this segment has been closed, or if access occurs from a thread other than the thread owning that scope, or if this segment's contents cannot be copied into a <code>int</code> instance, e.g. because <code>byteSize() % 4 != 0</code>, or <code>byteSize() / 4 &gt; Integer#MAX_VALUE</code>.</dd> </dl> </section><section class="detail" id="toFloatArray()"> <h3>toFloatArray</h3> <pre class="lang-java" data-language="java">float[] toFloatArray()</pre> <div class="block">Copy the contents of this memory segment into a fresh float array.</div> <dl class="notes"> <dt>Returns:</dt> <dd>a fresh float array copy of this memory segment.</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.base/java/lang/illegalstateexception" title="class in java.lang">IllegalStateException</a></code> - if the scope associated with this segment has been closed, or if access occurs from a thread other than the thread owning that scope, or if this segment's contents cannot be copied into a <code>float</code> instance, e.g. because <code>byteSize() % 4 != 0</code>, or <code>byteSize() / 4 &gt; Integer#MAX_VALUE</code>.</dd> </dl> </section><section class="detail" id="toLongArray()"> <h3>toLongArray</h3> <pre class="lang-java" data-language="java">long[] toLongArray()</pre> <div class="block">Copy the contents of this memory segment into a fresh long array.</div> <dl class="notes"> <dt>Returns:</dt> <dd>a fresh long array copy of this memory segment.</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.base/java/lang/illegalstateexception" title="class in java.lang">IllegalStateException</a></code> - if the scope associated with this segment has been closed, or if access occurs from a thread other than the thread owning that scope, or if this segment's contents cannot be copied into a <code>long</code> instance, e.g. because <code>byteSize() % 8 != 0</code>, or <code>byteSize() / 8 &gt; Integer#MAX_VALUE</code>.</dd> </dl> </section><section class="detail" id="toDoubleArray()"> <h3>toDoubleArray</h3> <pre class="lang-java" data-language="java">double[] toDoubleArray()</pre> <div class="block">Copy the contents of this memory segment into a fresh double array.</div> <dl class="notes"> <dt>Returns:</dt> <dd>a fresh double array copy of this memory segment.</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.base/java/lang/illegalstateexception" title="class in java.lang">IllegalStateException</a></code> - if the scope associated with this segment has been closed, or if access occurs from a thread other than the thread owning that scope, or if this segment's contents cannot be copied into a <code>double</code> instance, e.g. because <code>byteSize() % 8 != 0</code>, or <code>byteSize() / 8 &gt; Integer#MAX_VALUE</code>.</dd> </dl> </section><section class="detail" id="ofByteBuffer(java.nio.ByteBuffer)"> <h3>ofByteBuffer</h3> <pre class="lang-java" data-language="java">static MemorySegment ofByteBuffer(ByteBuffer bb)</pre> <div class="block">Creates a new confined buffer memory segment that models the memory associated with the given byte buffer. The segment starts relative to the buffer's position (inclusive) and ends relative to the buffer's limit (exclusive). <p> If the buffer is <a href="../../../../java.base/java/nio/buffer#isReadOnly()"><code>read-only</code></a>, the resulting segment will also be <a href="../../../../java.base/java/nio/buffer#isReadOnly()"><code>read-only</code></a>. The scope associated with this segment can either be the <a href="resourcescope#globalScope()">global</a> resource scope, in case the buffer has been created independently, or to some other (possibly closeable) resource scope, in case the buffer has been obtained using <a href="#asByteBuffer()"><code>asByteBuffer()</code></a>. </p>
<p> The resulting memory segment keeps a reference to the backing buffer, keeping it <em>reachable</em>.</p>
</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>bb</code> - the byte buffer backing the buffer memory segment.</dd> <dt>Returns:</dt> <dd>a new buffer memory segment.</dd> </dl> </section><section class="detail" id="ofArray(byte[])"> <h3>ofArray</h3> <pre class="lang-java" data-language="java">static MemorySegment ofArray(byte[] arr)</pre> <div class="block">Creates a new confined array memory segment that models the memory associated with a given heap-allocated byte array. The returned segment's resource scope is set to the <a href="resourcescope#globalScope()">global</a> resource scope.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>arr</code> - the primitive array backing the array memory segment.</dd> <dt>Returns:</dt> <dd>a new array memory segment.</dd> </dl> </section><section class="detail" id="ofArray(char[])"> <h3>ofArray</h3> <pre class="lang-java" data-language="java">static MemorySegment ofArray(char[] arr)</pre> <div class="block">Creates a new confined array memory segment that models the memory associated with a given heap-allocated char array. The returned segment's resource scope is set to the <a href="resourcescope#globalScope()">global</a> resource scope.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>arr</code> - the primitive array backing the array memory segment.</dd> <dt>Returns:</dt> <dd>a new array memory segment.</dd> </dl> </section><section class="detail" id="ofArray(short[])"> <h3>ofArray</h3> <pre class="lang-java" data-language="java">static MemorySegment ofArray(short[] arr)</pre> <div class="block">Creates a new confined array memory segment that models the memory associated with a given heap-allocated short array. The returned segment's resource scope is set to the <a href="resourcescope#globalScope()">global</a> resource scope.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>arr</code> - the primitive array backing the array memory segment.</dd> <dt>Returns:</dt> <dd>a new array memory segment.</dd> </dl> </section><section class="detail" id="ofArray(int[])"> <h3>ofArray</h3> <pre class="lang-java" data-language="java">static MemorySegment ofArray(int[] arr)</pre> <div class="block">Creates a new confined array memory segment that models the memory associated with a given heap-allocated int array. The returned segment's resource scope is set to the <a href="resourcescope#globalScope()">global</a> resource scope.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>arr</code> - the primitive array backing the array memory segment.</dd> <dt>Returns:</dt> <dd>a new array memory segment.</dd> </dl> </section><section class="detail" id="ofArray(float[])"> <h3>ofArray</h3> <pre class="lang-java" data-language="java">static MemorySegment ofArray(float[] arr)</pre> <div class="block">Creates a new confined array memory segment that models the memory associated with a given heap-allocated float array. The returned segment's resource scope is set to the <a href="resourcescope#globalScope()">global</a> resource scope.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>arr</code> - the primitive array backing the array memory segment.</dd> <dt>Returns:</dt> <dd>a new array memory segment.</dd> </dl> </section><section class="detail" id="ofArray(long[])"> <h3>ofArray</h3> <pre class="lang-java" data-language="java">static MemorySegment ofArray(long[] arr)</pre> <div class="block">Creates a new confined array memory segment that models the memory associated with a given heap-allocated long array. The returned segment's resource scope is set to the <a href="resourcescope#globalScope()">global</a> resource scope.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>arr</code> - the primitive array backing the array memory segment.</dd> <dt>Returns:</dt> <dd>a new array memory segment.</dd> </dl> </section><section class="detail" id="ofArray(double[])"> <h3>ofArray</h3> <pre class="lang-java" data-language="java">static MemorySegment ofArray(double[] arr)</pre> <div class="block">Creates a new confined array memory segment that models the memory associated with a given heap-allocated double array. The returned segment's resource scope is set to the <a href="resourcescope#globalScope()">global</a> resource scope.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>arr</code> - the primitive array backing the array memory segment.</dd> <dt>Returns:</dt> <dd>a new array memory segment.</dd> </dl> </section><section class="detail" id="allocateNative(jdk.incubator.foreign.MemoryLayout,jdk.incubator.foreign.ResourceScope)"> <h3>allocateNative</h3> <pre class="lang-java" data-language="java">static MemorySegment allocateNative(MemoryLayout layout, ResourceScope scope)</pre> <div class="block">Creates a new confined native memory segment that models a newly allocated block of off-heap memory with given layout and resource scope. A client is responsible make sure that the resource scope associated with the returned segment is closed when the segment is no longer in use. Failure to do so will result in off-heap memory leaks. <p> This is equivalent to the following code: </p>
<blockquote><pre class="lang-java" data-language="java"><code>
    allocateNative(layout.bytesSize(), layout.bytesAlignment(), scope);
 </code></pre></blockquote> <p> The block of off-heap memory associated with the returned native memory segment is initialized to zero.</p>
</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>layout</code> - the layout of the off-heap memory block backing the native memory segment.</dd> <dd>
<code>scope</code> - the segment scope.</dd> <dt>Returns:</dt> <dd>a new native memory segment.</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.base/java/lang/illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if the specified layout has illegal size or alignment constraint.</dd> <dd>
<code><a href="../../../../java.base/java/lang/illegalstateexception" title="class in java.lang">IllegalStateException</a></code> - if <code>scope</code> has been already closed, or if access occurs from a thread other than the thread owning <code>scope</code>.</dd> </dl> </section><section class="detail" id="allocateNative(long,jdk.incubator.foreign.ResourceScope)"> <h3>allocateNative</h3> <pre class="lang-java" data-language="java">static MemorySegment allocateNative(long bytesSize, ResourceScope scope)</pre> <div class="block">Creates a new confined native memory segment that models a newly allocated block of off-heap memory with given size (in bytes) and resource scope. A client is responsible make sure that the resource scope associated with the returned segment is closed when the segment is no longer in use. Failure to do so will result in off-heap memory leaks. <p> This is equivalent to the following code: </p>
<blockquote><pre class="lang-java" data-language="java"><code>
    allocateNative(bytesSize, 1, scope);
 </code></pre></blockquote> <p> The block of off-heap memory associated with the returned native memory segment is initialized to zero.</p>
</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>bytesSize</code> - the size (in bytes) of the off-heap memory block backing the native memory segment.</dd> <dd>
<code>scope</code> - the segment scope.</dd> <dt>Returns:</dt> <dd>a new native memory segment.</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.base/java/lang/illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if <code>bytesSize &lt;= 0</code>.</dd> <dd>
<code><a href="../../../../java.base/java/lang/illegalstateexception" title="class in java.lang">IllegalStateException</a></code> - if <code>scope</code> has been already closed, or if access occurs from a thread other than the thread owning <code>scope</code>.</dd> </dl> </section><section class="detail" id="allocateNative(long,long,jdk.incubator.foreign.ResourceScope)"> <h3>allocateNative</h3> <pre class="lang-java" data-language="java">static MemorySegment allocateNative(long bytesSize, long alignmentBytes, ResourceScope scope)</pre> <div class="block">Creates a new confined native memory segment that models a newly allocated block of off-heap memory with given size (in bytes), alignment constraint (in bytes) and resource scope. A client is responsible make sure that the resource scope associated with the returned segment is closed when the segment is no longer in use. Failure to do so will result in off-heap memory leaks. <p> The block of off-heap memory associated with the returned native memory segment is initialized to zero.</p>
</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>bytesSize</code> - the size (in bytes) of the off-heap memory block backing the native memory segment.</dd> <dd>
<code>alignmentBytes</code> - the alignment constraint (in bytes) of the off-heap memory block backing the native memory segment.</dd> <dd>
<code>scope</code> - the segment scope.</dd> <dt>Returns:</dt> <dd>a new native memory segment.</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.base/java/lang/illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if <code>bytesSize &lt;= 0</code>, <code>alignmentBytes &lt;= 0</code>, or if <code>alignmentBytes</code> is not a power of 2.</dd> <dd>
<code><a href="../../../../java.base/java/lang/illegalstateexception" title="class in java.lang">IllegalStateException</a></code> - if <code>scope</code> has been already closed, or if access occurs from a thread other than the thread owning <code>scope</code>.</dd> </dl> </section><section class="detail" id="mapFile(java.nio.file.Path,long,long,java.nio.channels.FileChannel.MapMode,jdk.incubator.foreign.ResourceScope)"> <h3>mapFile</h3> <pre class="lang-java" data-language="java">static MemorySegment mapFile(Path path, long bytesOffset, long bytesSize, FileChannel.MapMode mapMode, ResourceScope scope) throws IOException</pre> <div class="block">Creates a new mapped memory segment that models a memory-mapped region of a file from a given path. <p> If the specified mapping mode is <a href="../../../../java.base/java/nio/channels/filechannel.mapmode#READ_ONLY">READ_ONLY</a>, the resulting segment will be read-only (see <a href="#isReadOnly()"><code>isReadOnly()</code></a>). </p>
<p> The content of a mapped memory segment can change at any time, for example if the content of the corresponding region of the mapped file is changed by this (or another) program. Whether or not such changes occur, and when they occur, is operating-system dependent and therefore unspecified. </p>
<p> All or part of a mapped memory segment may become inaccessible at any time, for example if the backing mapped file is truncated. An attempt to access an inaccessible region of a mapped memory segment will not change the segment's content and will cause an unspecified exception to be thrown either at the time of the access or at some later time. It is therefore strongly recommended that appropriate precautions be taken to avoid the manipulation of a mapped file by this (or another) program, except to read or write the file's content.</p>
</div> <dl class="notes"> <dt>Implementation Note:</dt> <dd>When obtaining a mapped segment from a newly created file, the initialization state of the contents of the block of mapped memory associated with the returned mapped memory segment is unspecified and should not be relied upon.</dd> <dt>Parameters:</dt> <dd>
<code>path</code> - the path to the file to memory map.</dd> <dd>
<code>bytesOffset</code> - the offset (expressed in bytes) within the file at which the mapped segment is to start.</dd> <dd>
<code>bytesSize</code> - the size (in bytes) of the mapped memory backing the memory segment.</dd> <dd>
<code>mapMode</code> - a file mapping mode, see <a href="../../../../java.base/java/nio/channels/filechannel#map(java.nio.channels.FileChannel.MapMode,long,long)"><code>FileChannel.map(FileChannel.MapMode, long, long)</code></a>; the chosen mapping mode might affect the behavior of the returned memory mapped segment (see <a href="#force()"><code>force()</code></a>).</dd> <dd>
<code>scope</code> - the segment scope.</dd> <dt>Returns:</dt> <dd>a new confined mapped memory segment.</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.base/java/lang/illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if <code>bytesOffset &lt; 0</code>, <code>bytesSize &lt; 0</code>, or if <code>path</code> is not associated with the default file system.</dd> <dd>
<code><a href="../../../../java.base/java/lang/illegalstateexception" title="class in java.lang">IllegalStateException</a></code> - if <code>scope</code> has been already closed, or if access occurs from a thread other than the thread owning <code>scope</code>.</dd> <dd>
<code><a href="../../../../java.base/java/lang/unsupportedoperationexception" title="class in java.lang">UnsupportedOperationException</a></code> - if an unsupported map mode is specified.</dd> <dd>
<code><a href="../../../../java.base/java/io/ioexception" title="class in java.io">IOException</a></code> - if the specified path does not point to an existing file, or if some other I/O error occurs.</dd> <dd>
<code><a href="../../../../java.base/java/lang/securityexception" title="class in java.lang">SecurityException</a></code> - If a security manager is installed and it denies an unspecified permission required by the implementation. In the case of the default provider, the <a href="../../../../java.base/java/lang/securitymanager#checkRead(java.lang.String)"><code>SecurityManager.checkRead(String)</code></a> method is invoked to check read access if the file is opened for reading. The <a href="../../../../java.base/java/lang/securitymanager#checkWrite(java.lang.String)"><code>SecurityManager.checkWrite(String)</code></a> method is invoked to check write access if the file is opened for writing.</dd> </dl> </section><section class="detail" id="globalNativeSegment()"> <h3>globalNativeSegment</h3> <pre class="lang-java" data-language="java">static MemorySegment globalNativeSegment()</pre> <div class="block">Returns a native memory segment whose base address is <a href="memoryaddress#NULL"><code>MemoryAddress.NULL</code></a> and whose size is <a href="../../../../java.base/java/lang/long#MAX_VALUE"><code>Long.MAX_VALUE</code></a>. This method can be very useful when dereferencing memory addresses obtained when interacting with native libraries. The returned segment is associated with the <em>global</em> resource scope (see <a href="resourcescope#globalScope()"><code>ResourceScope.globalScope()</code></a>). Equivalent to (but likely more efficient than) the following code: <pre class="lang-java" data-language="java"><code>
    MemoryAddress.NULL.asSegment(Long.MAX_VALUE)
 </code></pre> <p> This method is <a href="package-summary#restricted"><em>restricted</em></a>. Restricted methods are unsafe, and, if used incorrectly, their use might crash the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on restricted methods, and use safe and supported functionalities, where possible.</p>
</div> <dl class="notes"> <dt>Returns:</dt> <dd>a memory segment whose base address is <a href="memoryaddress#NULL"><code>MemoryAddress.NULL</code></a> and whose size is <a href="../../../../java.base/java/lang/long#MAX_VALUE"><code>Long.MAX_VALUE</code></a>.</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.base/java/lang/illegalcallerexception" title="class in java.lang">IllegalCallerException</a></code> - if access to this method occurs from a module <code>M</code> and the command line option <code>--enable-native-access</code> is either absent, or does not mention the module name <code>M</code>, or <code>ALL-UNNAMED</code> in case <code>M</code> is an unnamed module.</dd> </dl> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1993, 2021, Oracle and/or its affiliates. All rights reserved.<br>Documentation extracted from Debian's OpenJDK Development Kit package.<br>Licensed under the GNU General Public License, version 2, with the Classpath Exception.<br>Various third party code in OpenJDK is licensed under different licenses (see Debian package).<br>Java and OpenJDK are trademarks or registered trademarks of Oracle and/or its affiliates.<br>
    <a href="https://docs.oracle.com/en/java/javase/17/docs/api/jdk.incubator.foreign/jdk/incubator/foreign/MemorySegment.html" class="_attribution-link">https://docs.oracle.com/en/java/javase/17/docs/api/jdk.incubator.foreign/jdk/incubator/foreign/MemorySegment.html</a>
  </p>
</div>
