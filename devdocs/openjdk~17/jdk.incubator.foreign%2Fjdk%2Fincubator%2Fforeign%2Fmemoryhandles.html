<h1 title="Class MemoryHandles" class="title">Class MemoryHandles</h1> <div class="inheritance" title="Inheritance Tree">
<a href="../../../../java.base/java/lang/object" title="class in java.lang">java.lang.Object</a> <div class="inheritance">jdk.incubator.foreign.MemoryHandles</div> </div> <section class="class-description" id="class-description">  <pre class="lang-java" data-language="java">public final class MemoryHandles extends Object</pre> <div class="block">This class defines several factory methods for constructing and combining memory access var handles. To obtain a memory access var handle, clients must start from one of the <em>leaf</em> methods (see <a href="#varHandle(java.lang.Class,java.nio.ByteOrder)"><code>varHandle(Class, ByteOrder)</code></a>, <a href="#varHandle(java.lang.Class,long,java.nio.ByteOrder)"><code>varHandle(Class, long, ByteOrder)</code></a>). This determines the variable type (all primitive types but <code>void</code> and <code>boolean</code> are supported), as well as the alignment constraint and the byte order associated with a memory access var handle. The resulting memory access var handle can then be combined in various ways to emulate different addressing modes. The var handles created by this class feature a <em>mandatory</em> coordinate type (of type <a href="memorysegment" title="interface in jdk.incubator.foreign"><code>MemorySegment</code></a>), and one <code>long</code> coordinate type, which represents the offset, in bytes, relative to the segment, at which dereference should occur. <p> As an example, consider the memory layout expressed by a <a href="grouplayout" title="class in jdk.incubator.foreign"><code>GroupLayout</code></a> instance constructed as follows: </p>
<blockquote><pre class="lang-java" data-language="java"><code>
GroupLayout seq = MemoryLayout.structLayout(
        MemoryLayout.paddingLayout(32),
        MemoryLayout.valueLayout(32, ByteOrder.BIG_ENDIAN).withName("value")
);
 </code></pre></blockquote> To access the member layout named <code>value</code>, we can construct a memory access var handle as follows: <blockquote><pre class="lang-java" data-language="java"><code>
VarHandle handle = MemoryHandles.varHandle(int.class, ByteOrder.BIG_ENDIAN); //(MemorySegment, long) -&gt; int
handle = MemoryHandles.insertCoordinates(handle, 1, 4); //(MemorySegment) -&gt; int
 </code></pre></blockquote> <p> Unless otherwise specified, passing a <code>null</code> argument, or an array argument containing one or more <code>null</code> elements to a method in this class causes a <a href="../../../../java.base/java/lang/nullpointerexception" title="class in java.lang"><code>NullPointerException</code></a> to be thrown. </p> <h2>
Alignment and access modes</h2> A memory access var handle is associated with an access size <code>S</code> and an alignment constraint <code>B</code> (both expressed in bytes). We say that a memory access operation is <em>fully aligned</em> if it occurs at a memory address <code>A</code> which is compatible with both alignment constraints <code>S</code> and <code>B</code>. If access is fully aligned then following access modes are supported and are guaranteed to support atomic access: <ul> <li>read write access modes for all <code>T</code>, with the exception of access modes <code>get</code> and <code>set</code> for <code>long</code> and <code>double</code> on 32-bit platforms. </li>
<li>atomic update access modes for <code>int</code>, <code>long</code>, <code>float</code> or <code>double</code>. (Future major platform releases of the JDK may support additional types for certain currently unsupported access modes.) </li>
<li>numeric atomic update access modes for <code>int</code> and <code>long</code>. (Future major platform releases of the JDK may support additional numeric types for certain currently unsupported access modes.) </li>
<li>bitwise atomic update access modes for <code>int</code> and <code>long</code>. (Future major platform releases of the JDK may support additional numeric types for certain currently unsupported access modes.) </li>
</ul> If <code>T</code> is <code>float</code> or <code>double</code> then atomic update access modes compare values using their bitwise representation (see <a href="../../../../java.base/java/lang/float#floatToRawIntBits(float)"><code>Float.floatToRawIntBits(float)</code></a> and <a href="../../../../java.base/java/lang/double#doubleToRawLongBits(double)"><code>Double.doubleToRawLongBits(double)</code></a>, respectively). <p> Alternatively, a memory access operation is <em>partially aligned</em> if it occurs at a memory address <code>A</code> which is only compatible with the alignment constraint <code>B</code>; in such cases, access for anything other than the <code>get</code> and <code>set</code> access modes will result in an <code>IllegalStateException</code>. If access is partially aligned, atomic access is only guaranteed with respect to the largest power of two that divides the GCD of <code>A</code> and <code>S</code>. </p>
<p> Finally, in all other cases, we say that a memory access operation is <em>misaligned</em>; in such cases an <code>IllegalStateException</code> is thrown, irrespective of the access mode being used.</p>
</div> </section> <section class="summary"> <section class="method-summary" id="method-summary"> <h2>Method Summary</h2> <div id="method-summary-table">  <div id="method-summary-table.tabpanel" role="tabpanel"> <table class="summary-table three-column-summary" aria-labelledby="method-summary-table-tab0">                                  <tr>
<th>Modifier and Type</th>
<th>Method</th>
<th>Description</th>
</tr>
<tr>
<td><code>static <a href="../../../../java.base/java/lang/invoke/varhandle" title="class in java.lang.invoke">VarHandle</a></code></td>
<td><code><a href="#asAddressVarHandle(java.lang.invoke.VarHandle)" class="member-name-link">asAddressVarHandle</a><wbr>(<a href="../../../../java.base/java/lang/invoke/varhandle" title="class in java.lang.invoke">VarHandle</a> target)</wbr></code></td>
<td> <div class="block">Adapt an existing var handle into a new var handle whose carrier type is <a href="memorysegment" title="interface in jdk.incubator.foreign"><code>MemorySegment</code></a>.</div> </td>
</tr>
<tr>
<td><code>static <a href="../../../../java.base/java/lang/invoke/varhandle" title="class in java.lang.invoke">VarHandle</a></code></td>
<td><code><a href="#asUnsigned(java.lang.invoke.VarHandle,java.lang.Class)" class="member-name-link">asUnsigned</a><wbr>(<a href="../../../../java.base/java/lang/invoke/varhandle" title="class in java.lang.invoke">VarHandle</a> target,
 <a href="../../../../java.base/java/lang/class" title="class in java.lang">Class</a>&lt;?&gt; adaptedType)</wbr></code></td>
<td> <div class="block">Adapts a target var handle by narrowing incoming values and widening outgoing values, to and from the given type, respectively.</div> </td>
</tr>
<tr>
<td><code>static <a href="../../../../java.base/java/lang/invoke/varhandle" title="class in java.lang.invoke">VarHandle</a></code></td>
<td><code><a href="#collectCoordinates(java.lang.invoke.VarHandle,int,java.lang.invoke.MethodHandle)" class="member-name-link">collectCoordinates</a><wbr>(<a href="../../../../java.base/java/lang/invoke/varhandle" title="class in java.lang.invoke">VarHandle</a> target,
 int pos,
 <a href="../../../../java.base/java/lang/invoke/methodhandle" title="class in java.lang.invoke">MethodHandle</a> filter)</wbr></code></td>
<td> <div class="block">Adapts a target var handle handle by pre-processing a sub-sequence of its coordinate values with a filter (a method handle).</div> </td>
</tr>
<tr>
<td><code>static <a href="../../../../java.base/java/lang/invoke/varhandle" title="class in java.lang.invoke">VarHandle</a></code></td>
<td><code><a href="#dropCoordinates(java.lang.invoke.VarHandle,int,java.lang.Class...)" class="member-name-link">dropCoordinates</a><wbr>(<a href="../../../../java.base/java/lang/invoke/varhandle" title="class in java.lang.invoke">VarHandle</a> target,
 int pos,
 <a href="../../../../java.base/java/lang/class" title="class in java.lang">Class</a>&lt;?&gt;... valueTypes)</wbr></code></td>
<td> <div class="block">Returns a var handle which will discard some dummy coordinates before delegating to the target var handle.</div> </td>
</tr>
<tr>
<td><code>static <a href="../../../../java.base/java/lang/invoke/varhandle" title="class in java.lang.invoke">VarHandle</a></code></td>
<td><code><a href="#filterCoordinates(java.lang.invoke.VarHandle,int,java.lang.invoke.MethodHandle...)" class="member-name-link">filterCoordinates</a><wbr>(<a href="../../../../java.base/java/lang/invoke/varhandle" title="class in java.lang.invoke">VarHandle</a> target,
 int pos,
 <a href="../../../../java.base/java/lang/invoke/methodhandle" title="class in java.lang.invoke">MethodHandle</a>... filters)</wbr></code></td>
<td> <div class="block">Adapts a target var handle by pre-processing incoming coordinate values using unary filter functions.</div> </td>
</tr>
<tr>
<td><code>static <a href="../../../../java.base/java/lang/invoke/varhandle" title="class in java.lang.invoke">VarHandle</a></code></td>
<td><code><a href="#filterValue(java.lang.invoke.VarHandle,java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle)" class="member-name-link">filterValue</a><wbr>(<a href="../../../../java.base/java/lang/invoke/varhandle" title="class in java.lang.invoke">VarHandle</a> target,
 <a href="../../../../java.base/java/lang/invoke/methodhandle" title="class in java.lang.invoke">MethodHandle</a> filterToTarget,
 <a href="../../../../java.base/java/lang/invoke/methodhandle" title="class in java.lang.invoke">MethodHandle</a> filterFromTarget)</wbr></code></td>
<td> <div class="block">Adapts a target var handle by pre-processing incoming and outgoing values using a pair of filter functions.</div> </td>
</tr>
<tr>
<td><code>static <a href="../../../../java.base/java/lang/invoke/varhandle" title="class in java.lang.invoke">VarHandle</a></code></td>
<td><code><a href="#insertCoordinates(java.lang.invoke.VarHandle,int,java.lang.Object...)" class="member-name-link">insertCoordinates</a><wbr>(<a href="../../../../java.base/java/lang/invoke/varhandle" title="class in java.lang.invoke">VarHandle</a> target,
 int pos,
 <a href="../../../../java.base/java/lang/object" title="class in java.lang">Object</a>... values)</wbr></code></td>
<td> <div class="block">Provides a target var handle with one or more <em>bound coordinates</em> in advance of the var handle's invocation.</div> </td>
</tr>
<tr>
<td><code>static <a href="../../../../java.base/java/lang/invoke/varhandle" title="class in java.lang.invoke">VarHandle</a></code></td>
<td><code><a href="#permuteCoordinates(java.lang.invoke.VarHandle,java.util.List,int...)" class="member-name-link">permuteCoordinates</a><wbr>(<a href="../../../../java.base/java/lang/invoke/varhandle" title="class in java.lang.invoke">VarHandle</a> target,
 <a href="../../../../java.base/java/util/list" title="interface in java.util">List</a>&lt;<a href="../../../../java.base/java/lang/class" title="class in java.lang">Class</a>&lt;?&gt;&gt; newCoordinates,
 int... reorder)</wbr></code></td>
<td> <div class="block">Provides a var handle which adapts the coordinate values of the target var handle, by re-arranging them so that the new coordinates match the provided ones.</div> </td>
</tr>
<tr>
<td><code>static <a href="../../../../java.base/java/lang/invoke/varhandle" title="class in java.lang.invoke">VarHandle</a></code></td>
<td><code><a href="#varHandle(java.lang.Class,long,java.nio.ByteOrder)" class="member-name-link">varHandle</a><wbr>(<a href="../../../../java.base/java/lang/class" title="class in java.lang">Class</a>&lt;?&gt; carrier,
 long alignmentBytes,
 <a href="../../../../java.base/java/nio/byteorder" title="class in java.nio">ByteOrder</a> byteOrder)</wbr></code></td>
<td> <div class="block">Creates a memory access var handle with the given carrier type, alignment constraint, and byte order.</div> </td>
</tr>
<tr>
<td><code>static <a href="../../../../java.base/java/lang/invoke/varhandle" title="class in java.lang.invoke">VarHandle</a></code></td>
<td><code><a href="#varHandle(java.lang.Class,java.nio.ByteOrder)" class="member-name-link">varHandle</a><wbr>(<a href="../../../../java.base/java/lang/class" title="class in java.lang">Class</a>&lt;?&gt; carrier,
 <a href="../../../../java.base/java/nio/byteorder" title="class in java.nio">ByteOrder</a> byteOrder)</wbr></code></td>
<td> <div class="block">Creates a memory access var handle with the given carrier type and byte order.</div> </td>
</tr>
</table> </div> </div> <div class="inherited-list"> <h3 id="methods-inherited-from-class-java.lang.Object">Methods declared in class java.lang.<a href="../../../../java.base/java/lang/object" title="class in java.lang">Object</a>
</h3> <code><a href="../../../../java.base/java/lang/object#clone()">clone</a>, <a href="../../../../java.base/java/lang/object#equals(java.lang.Object)">equals</a>, <a href="../../../../java.base/java/lang/object#finalize()">finalize</a>, <a href="../../../../java.base/java/lang/object#getClass()">getClass</a>, <a href="../../../../java.base/java/lang/object#hashCode()">hashCode</a>, <a href="../../../../java.base/java/lang/object#notify()">notify</a>, <a href="../../../../java.base/java/lang/object#notifyAll()">notifyAll</a>, <a href="../../../../java.base/java/lang/object#toString()">toString</a>, <a href="../../../../java.base/java/lang/object#wait()">wait</a>, <a href="../../../../java.base/java/lang/object#wait(long)">wait</a>, <a href="../../../../java.base/java/lang/object#wait(long,int)">wait</a></code>
</div> </section> </section> <section class="details"> <section class="method-details" id="method-detail"> <h2>Method Details</h2>  </section><section class="detail" id="varHandle(java.lang.Class,java.nio.ByteOrder)"> <h3>varHandle</h3> <pre class="lang-java" data-language="java">public static VarHandle varHandle(Class&lt;?&gt; carrier, ByteOrder byteOrder)</pre> <div class="block">Creates a memory access var handle with the given carrier type and byte order. The returned var handle's type is <code>carrier</code> and the list of coordinate types is <code>(MemorySegment, long)</code>, where the <code>long</code> coordinate type corresponds to byte offset into a given memory segment. The returned var handle accesses bytes at an offset in a given memory segment, composing bytes to or from a value of the type <code>carrier</code> according to the given endianness; the alignment constraint (in bytes) for the resulting memory access var handle is the same as the size (in bytes) of the carrier type <code>carrier</code>.</div> <dl class="notes"> <dt>API Note:</dt> <dd>the resulting var handle features certain <a href="#memaccess-mode">access mode restrictions</a>, which are common to all memory access var handles.</dd> <dt>Parameters:</dt> <dd>
<code>carrier</code> - the carrier type. Valid carriers are <code>byte</code>, <code>short</code>, <code>char</code>, <code>int</code>, <code>float</code>, <code>long</code>, and <code>double</code>.</dd> <dd>
<code>byteOrder</code> - the required byte order.</dd> <dt>Returns:</dt> <dd>the new memory access var handle.</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.base/java/lang/illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - when an illegal carrier type is used</dd> </dl> </section><section class="detail" id="varHandle(java.lang.Class,long,java.nio.ByteOrder)"> <h3>varHandle</h3> <pre class="lang-java" data-language="java">public static VarHandle varHandle(Class&lt;?&gt; carrier, long alignmentBytes, ByteOrder byteOrder)</pre> <div class="block">Creates a memory access var handle with the given carrier type, alignment constraint, and byte order. The returned var handle's type is <code>carrier</code> and the list of coordinate types is <code>(MemorySegment, long)</code>, where the <code>long</code> coordinate type corresponds to byte offset into a given memory segment. The returned var handle accesses bytes at an offset in a given memory segment, composing bytes to or from a value of the type <code>carrier</code> according to the given endianness; the alignment constraint (in bytes) for the resulting memory access var handle is given by <code>alignmentBytes</code>.</div> <dl class="notes"> <dt>API Note:</dt> <dd>the resulting var handle features certain <a href="#memaccess-mode">access mode restrictions</a>, which are common to all memory access var handles.</dd> <dt>Parameters:</dt> <dd>
<code>carrier</code> - the carrier type. Valid carriers are <code>byte</code>, <code>short</code>, <code>char</code>, <code>int</code>, <code>float</code>, <code>long</code>, and <code>double</code>.</dd> <dd>
<code>alignmentBytes</code> - the alignment constraint (in bytes). Must be a power of two.</dd> <dd>
<code>byteOrder</code> - the required byte order.</dd> <dt>Returns:</dt> <dd>the new memory access var handle.</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.base/java/lang/illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if an illegal carrier type is used, or if <code>alignmentBytes</code> is not a power of two.</dd> </dl> </section><section class="detail" id="asAddressVarHandle(java.lang.invoke.VarHandle)"> <h3>asAddressVarHandle</h3> <pre class="lang-java" data-language="java">public static VarHandle asAddressVarHandle(VarHandle target)</pre> <div class="block">Adapt an existing var handle into a new var handle whose carrier type is <a href="memorysegment" title="interface in jdk.incubator.foreign"><code>MemorySegment</code></a>. That is, when calling <a href="../../../../java.base/java/lang/invoke/varhandle#get(java.lang.Object...)"><code>VarHandle.get(Object...)</code></a> on the returned var handle, the read numeric value will be turned into a memory address (as if by calling <a href="memoryaddress#ofLong(long)"><code>MemoryAddress.ofLong(long)</code></a>); similarly, when calling <a href="../../../../java.base/java/lang/invoke/varhandle#set(java.lang.Object...)"><code>VarHandle.set(Object...)</code></a>, the memory address to be set will be converted into a numeric value, and then written into memory. The amount of bytes read (resp. written) from (resp. to) memory depends on the carrier of the original memory access var handle.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>target</code> - the memory access var handle to be adapted</dd> <dt>Returns:</dt> <dd>the adapted var handle.</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.base/java/lang/illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if the carrier type of <code>varHandle</code> is either <code>boolean</code>, <code>float</code>, or <code>double</code>, or is not a primitive type.</dd> </dl> </section><section class="detail" id="asUnsigned(java.lang.invoke.VarHandle,java.lang.Class)"> <h3>asUnsigned</h3> <pre class="lang-java" data-language="java">public static VarHandle asUnsigned(VarHandle target, Class&lt;?&gt; adaptedType)</pre> <div class="block">Adapts a target var handle by narrowing incoming values and widening outgoing values, to and from the given type, respectively. <p> The returned var handle can be used to conveniently treat unsigned primitive data types as if they were a wider signed primitive type. For example, it is often convenient to model an <i>unsigned short</i> as a Java <code>int</code> to avoid dealing with negative values, which would be the case if modeled as a Java <code>short</code>. This is illustrated in the following example: </p>
<blockquote><pre class="lang-java" data-language="java"><code>
    MemorySegment segment = MemorySegment.allocateNative(2, ResourceScope.newImplicitScope());
    VarHandle SHORT_VH = MemoryLayouts.JAVA_SHORT.varHandle(short.class);
    VarHandle INT_VH = MemoryHandles.asUnsigned(SHORT_VH, int.class);
    SHORT_VH.set(segment, (short)-1);
    INT_VH.get(segment); // returns 65535
 </code></pre></blockquote> <p> When calling e.g. <a href="../../../../java.base/java/lang/invoke/varhandle#set(java.lang.Object...)"><code>VarHandle.set(Object...)</code></a> on the resulting var handle, the incoming value (of type <code>adaptedType</code>) is converted by a <i>narrowing primitive conversion</i> and then passed to the <code>
 target</code> var handle. A narrowing primitive conversion may lose information about the overall magnitude of a numeric value. Conversely, when calling e.g. <a href="../../../../java.base/java/lang/invoke/varhandle#get(java.lang.Object...)"><code>VarHandle.get(Object...)</code></a> on the resulting var handle, the returned value obtained from the <code>target</code> var handle is converted by a <i>unsigned widening conversion</i> before being returned to the caller. In an unsigned widening conversion the high-order bits greater than that of the <code>target</code> carrier type are zero, and the low-order bits (equal to the width of the <code>target</code> carrier type) are equal to the bits of the value obtained from the <code>target</code> var handle. </p>
<p> The returned var handle will feature the variable type <code>adaptedType</code>, and the same access coordinates, the same access modes (see <a href="../../../../java.base/java/lang/invoke/varhandle.accessmode" title="enum class in java.lang.invoke"><code>VarHandle.AccessMode</code></a>, and the same atomic access guarantees, as those featured by the <code>target</code> var handle.</p>
</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>target</code> - the memory access var handle to be adapted</dd> <dd>
<code>adaptedType</code> - the adapted type</dd> <dt>Returns:</dt> <dd>the adapted var handle.</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.base/java/lang/illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if the carrier type of <code>target</code> is not one of <code>byte</code>, <code>short</code>, or <code>int</code>; if <code>
 adaptedType</code> is not one of <code>int</code>, or <code>long</code>; if the bitwidth of the <code>adaptedType</code> is not greater than that of the <code>target</code> carrier type.</dd> <dt>See <i>Java Language Specification</i>:</dt> <dd> <a href="https://docs.oracle.com/javase/specs/jls/se17/html/jls-5.html#jls-5.1.3">5.1.3 Narrowing Primitive Conversion</a><br>
</dd>
</dl> </section><section class="detail" id="filterValue(java.lang.invoke.VarHandle,java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle)"> <h3>filterValue</h3> <pre class="lang-java" data-language="java">public static VarHandle filterValue(VarHandle target, MethodHandle filterToTarget, MethodHandle filterFromTarget)</pre> <div class="block">Adapts a target var handle by pre-processing incoming and outgoing values using a pair of filter functions. <p> When calling e.g. <a href="../../../../java.base/java/lang/invoke/varhandle#set(java.lang.Object...)"><code>VarHandle.set(Object...)</code></a> on the resulting var handle, the incoming value (of type <code>T</code>, where <code>T</code> is the <em>last</em> parameter type of the first filter function) is processed using the first filter and then passed to the target var handle. Conversely, when calling e.g. <a href="../../../../java.base/java/lang/invoke/varhandle#get(java.lang.Object...)"><code>VarHandle.get(Object...)</code></a> on the resulting var handle, the return value obtained from the target var handle (of type <code>T</code>, where <code>T</code> is the <em>last</em> parameter type of the second filter function) is processed using the second filter and returned to the caller. More advanced access mode types, such as <a href="../../../../java.base/java/lang/invoke/varhandle.accessmode#COMPARE_AND_EXCHANGE"><code>VarHandle.AccessMode.COMPARE_AND_EXCHANGE</code></a> might apply both filters at the same time. </p>
<p> For the boxing and unboxing filters to be well formed, their types must be of the form <code>(A... , S) -&gt; T</code> and <code>(A... , T) -&gt; S</code>, respectively, where <code>T</code> is the type of the target var handle. If this is the case, the resulting var handle will have type <code>S</code> and will feature the additional coordinates <code>A...</code> (which will be appended to the coordinates of the target var handle). </p>
<p> The resulting var handle will feature the same access modes (see <a href="../../../../java.base/java/lang/invoke/varhandle.accessmode" title="enum class in java.lang.invoke"><code>VarHandle.AccessMode</code></a> and atomic access guarantees as those featured by the target var handle.</p>
</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>target</code> - the target var handle</dd> <dd>
<code>filterToTarget</code> - a filter to convert some type <code>S</code> into the type of <code>target</code>
</dd> <dd>
<code>filterFromTarget</code> - a filter to convert the type of <code>target</code> to some type <code>S</code>
</dd> <dt>Returns:</dt> <dd>an adapter var handle which accepts a new type, performing the provided boxing/unboxing conversions.</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.base/java/lang/illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if <code>filterFromTarget</code> and <code>filterToTarget</code> are not well-formed, that is, they have types other than <code>(A... , S) -&gt; T</code> and <code>(A... , T) -&gt; S</code>, respectively, where <code>T</code> is the type of the target var handle, or if either <code>filterFromTarget</code> or <code>filterToTarget</code> throws any checked exceptions.</dd> </dl> </section><section class="detail" id="filterCoordinates(java.lang.invoke.VarHandle,int,java.lang.invoke.MethodHandle...)"> <h3>filterCoordinates</h3> <pre class="lang-java" data-language="java">public static VarHandle filterCoordinates(VarHandle target, int pos, MethodHandle... filters)</pre> <div class="block">Adapts a target var handle by pre-processing incoming coordinate values using unary filter functions. <p> When calling e.g. <a href="../../../../java.base/java/lang/invoke/varhandle#get(java.lang.Object...)"><code>VarHandle.get(Object...)</code></a> on the resulting var handle, the incoming coordinate values starting at position <code>pos</code> (of type <code>C1, C2 ... Cn</code>, where <code>C1, C2 ... Cn</code> are the return type of the unary filter functions) are transformed into new values (of type <code>S1, S2 ... Sn</code>, where <code>S1, S2 ... Sn</code> are the parameter types of the unary filter functions), and then passed (along with any coordinate that was left unaltered by the adaptation) to the target var handle. </p>
<p> For the coordinate filters to be well formed, their types must be of the form <code>S1 -&gt; T1, S2 -&gt; T1 ... Sn -&gt; Tn</code>, where <code>T1, T2 ... Tn</code> are the coordinate types starting at position <code>pos</code> of the target var handle. </p>
<p> The resulting var handle will feature the same access modes (see <a href="../../../../java.base/java/lang/invoke/varhandle.accessmode" title="enum class in java.lang.invoke"><code>VarHandle.AccessMode</code></a>) and atomic access guarantees as those featured by the target var handle.</p>
</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>target</code> - the target var handle</dd> <dd>
<code>pos</code> - the position of the first coordinate to be transformed</dd> <dd>
<code>filters</code> - the unary functions which are used to transform coordinates starting at position <code>pos</code>
</dd> <dt>Returns:</dt> <dd>an adapter var handle which accepts new coordinate types, applying the provided transformation to the new coordinate values.</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.base/java/lang/illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if the handles in <code>filters</code> are not well-formed, that is, they have types other than <code>S1 -&gt; T1, S2 -&gt; T2, ... Sn -&gt; Tn</code> where <code>T1, T2 ... Tn</code> are the coordinate types starting at position <code>pos</code> of the target var handle, if <code>pos</code> is not between 0 and the target var handle coordinate arity, inclusive, or if more filters are provided than the actual number of coordinate types available starting at <code>pos</code>, or if any of the filters throws any checked exceptions.</dd> </dl> </section><section class="detail" id="insertCoordinates(java.lang.invoke.VarHandle,int,java.lang.Object...)"> <h3>insertCoordinates</h3> <pre class="lang-java" data-language="java">public static VarHandle insertCoordinates(VarHandle target, int pos, Object... values)</pre> <div class="block">Provides a target var handle with one or more <em>bound coordinates</em> in advance of the var handle's invocation. As a consequence, the resulting var handle will feature less coordinate types than the target var handle. <p> When calling e.g. <a href="../../../../java.base/java/lang/invoke/varhandle#get(java.lang.Object...)"><code>VarHandle.get(Object...)</code></a> on the resulting var handle, incoming coordinate values are joined with bound coordinate values, and then passed to the target var handle. </p>
<p> For the bound coordinates to be well formed, their types must be <code>T1, T2 ... Tn </code>, where <code>T1, T2 ... Tn</code> are the coordinate types starting at position <code>pos</code> of the target var handle. </p>
<p> The resulting var handle will feature the same access modes (see <a href="../../../../java.base/java/lang/invoke/varhandle.accessmode" title="enum class in java.lang.invoke"><code>VarHandle.AccessMode</code></a>) and atomic access guarantees as those featured by the target var handle.</p>
</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>target</code> - the var handle to invoke after the bound coordinates are inserted</dd> <dd>
<code>pos</code> - the position of the first coordinate to be inserted</dd> <dd>
<code>values</code> - the series of bound coordinates to insert</dd> <dt>Returns:</dt> <dd>an adapter var handle which inserts an additional coordinates, before calling the target var handle</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.base/java/lang/illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if <code>pos</code> is not between 0 and the target var handle coordinate arity, inclusive, or if more values are provided than the actual number of coordinate types available starting at <code>pos</code>.</dd> <dd>
<code><a href="../../../../java.base/java/lang/classcastexception" title="class in java.lang">ClassCastException</a></code> - if the bound coordinates in <code>values</code> are not well-formed, that is, they have types other than <code>T1, T2 ... Tn </code>, where <code>T1, T2 ... Tn</code> are the coordinate types starting at position <code>pos</code> of the target var handle.</dd> </dl> </section><section class="detail" id="permuteCoordinates(java.lang.invoke.VarHandle,java.util.List,int...)"> <h3>permuteCoordinates</h3> <pre class="lang-java" data-language="java">public static VarHandle permuteCoordinates(VarHandle target, List&lt;Class&lt;?&gt;&gt; newCoordinates, int... reorder)</pre> <div class="block">Provides a var handle which adapts the coordinate values of the target var handle, by re-arranging them so that the new coordinates match the provided ones. <p> The given array controls the reordering. Call <code>#I</code> the number of incoming coordinates (the value <code>newCoordinates.size()</code>, and call <code>#O</code> the number of outgoing coordinates (the number of coordinates associated with the target var handle). Then the length of the reordering array must be <code>#O</code>, and each element must be a non-negative number less than <code>#I</code>. For every <code>N</code> less than <code>#O</code>, the <code>N</code>-th outgoing coordinate will be taken from the <code>I</code>-th incoming coordinate, where <code>I</code> is <code>reorder[N]</code>. </p>
<p> No coordinate value conversions are applied. The type of each incoming coordinate, as determined by <code>newCoordinates</code>, must be identical to the type of the corresponding outgoing coordinate in the target var handle. </p>
<p> The reordering array need not specify an actual permutation. An incoming coordinate will be duplicated if its index appears more than once in the array, and an incoming coordinate will be dropped if its index does not appear in the array. </p>
<p> The resulting var handle will feature the same access modes (see <a href="../../../../java.base/java/lang/invoke/varhandle.accessmode" title="enum class in java.lang.invoke"><code>VarHandle.AccessMode</code></a>) and atomic access guarantees as those featured by the target var handle.</p>
</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>target</code> - the var handle to invoke after the coordinates have been reordered</dd> <dd>
<code>newCoordinates</code> - the new coordinate types</dd> <dd>
<code>reorder</code> - an index array which controls the reordering</dd> <dt>Returns:</dt> <dd>an adapter var handle which re-arranges the incoming coordinate values, before calling the target var handle</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.base/java/lang/illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if the index array length is not equal to the number of coordinates of the target var handle, or if any index array element is not a valid index for a coordinate of <code>newCoordinates</code>, or if two corresponding coordinate types in the target var handle and in <code>newCoordinates</code> are not identical.</dd> </dl> </section><section class="detail" id="collectCoordinates(java.lang.invoke.VarHandle,int,java.lang.invoke.MethodHandle)"> <h3>collectCoordinates</h3> <pre class="lang-java" data-language="java">public static VarHandle collectCoordinates(VarHandle target, int pos, MethodHandle filter)</pre> <div class="block">Adapts a target var handle handle by pre-processing a sub-sequence of its coordinate values with a filter (a method handle). The pre-processed coordinates are replaced by the result (if any) of the filter function and the target var handle is then called on the modified (usually shortened) coordinate list. <p> If <code>R</code> is the return type of the filter (which cannot be void), the target var handle must accept a value of type <code>R</code> as its coordinate in position <code>pos</code>, preceded and/or followed by any coordinate not passed to the filter. No coordinates are reordered, and the result returned from the filter replaces (in order) the whole subsequence of coordinates originally passed to the adapter. </p>
<p> The argument types (if any) of the filter replace zero or one coordinate types of the target var handle, at position <code>pos</code>, in the resulting adapted var handle. The return type of the filter must be identical to the coordinate type of the target var handle at position <code>pos</code>, and that target var handle coordinate is supplied by the return value of the filter. </p>
<p> The resulting var handle will feature the same access modes (see <a href="../../../../java.base/java/lang/invoke/varhandle.accessmode" title="enum class in java.lang.invoke"><code>VarHandle.AccessMode</code></a>) and atomic access guarantees as those featured by the target var handle.</p>
</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>target</code> - the var handle to invoke after the coordinates have been filtered</dd> <dd>
<code>pos</code> - the position of the coordinate to be filtered</dd> <dd>
<code>filter</code> - the filter method handle</dd> <dt>Returns:</dt> <dd>an adapter var handle which filters the incoming coordinate values, before calling the target var handle</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.base/java/lang/illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if the return type of <code>filter</code> is void, or it is not the same as the <code>pos</code> coordinate of the target var handle, if <code>pos</code> is not between 0 and the target var handle coordinate arity, inclusive, if the resulting var handle's type would have <a href="methodhandle#maxarity">too many coordinates</a>, or if <code>filter</code> throws any checked exceptions.</dd> </dl> </section><section class="detail" id="dropCoordinates(java.lang.invoke.VarHandle,int,java.lang.Class...)"> <h3>dropCoordinates</h3> <pre class="lang-java" data-language="java">public static VarHandle dropCoordinates(VarHandle target, int pos, Class&lt;?&gt;... valueTypes)</pre> <div class="block">Returns a var handle which will discard some dummy coordinates before delegating to the target var handle. As a consequence, the resulting var handle will feature more coordinate types than the target var handle. <p> The <code>pos</code> argument may range between zero and <i>N</i>, where <i>N</i> is the arity of the target var handle's coordinate types. If <code>pos</code> is zero, the dummy coordinates will precede the target's real arguments; if <code>pos</code> is <i>N</i> they will come after. </p>
<p> The resulting var handle will feature the same access modes (see <a href="../../../../java.base/java/lang/invoke/varhandle.accessmode" title="enum class in java.lang.invoke"><code>VarHandle.AccessMode</code></a>) and atomic access guarantees as those featured by the target var handle.</p>
</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>target</code> - the var handle to invoke after the dummy coordinates are dropped</dd> <dd>
<code>pos</code> - position of first coordinate to drop (zero for the leftmost)</dd> <dd>
<code>valueTypes</code> - the type(s) of the coordinate(s) to drop</dd> <dt>Returns:</dt> <dd>an adapter var handle which drops some dummy coordinates, before calling the target var handle</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.base/java/lang/illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if <code>pos</code> is not between 0 and the target var handle coordinate arity, inclusive.</dd> </dl> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1993, 2021, Oracle and/or its affiliates. All rights reserved.<br>Documentation extracted from Debian's OpenJDK Development Kit package.<br>Licensed under the GNU General Public License, version 2, with the Classpath Exception.<br>Various third party code in OpenJDK is licensed under different licenses (see Debian package).<br>Java and OpenJDK are trademarks or registered trademarks of Oracle and/or its affiliates.<br>
    <a href="https://docs.oracle.com/en/java/javase/17/docs/api/jdk.incubator.foreign/jdk/incubator/foreign/MemoryHandles.html" class="_attribution-link">https://docs.oracle.com/en/java/javase/17/docs/api/jdk.incubator.foreign/jdk/incubator/foreign/MemoryHandles.html</a>
  </p>
</div>
