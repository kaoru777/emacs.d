<h1 title="Interface MemoryLayout" class="title">Interface MemoryLayout</h1> <section class="class-description" id="class-description"> <dl class="notes"> <dt>All Superinterfaces:</dt> <dd><code><a href="../../../../java.base/java/lang/constant/constable" title="interface in java.lang.constant">Constable</a></code></dd> </dl> <dl class="notes"> <dt>All Known Implementing Classes:</dt> <dd>
<code><a href="grouplayout" title="class in jdk.incubator.foreign">GroupLayout</a></code>, <code><a href="sequencelayout" title="class in jdk.incubator.foreign">SequenceLayout</a></code>, <code><a href="valuelayout" title="class in jdk.incubator.foreign">ValueLayout</a></code>
</dd> </dl>  <pre class="lang-java" data-language="java">public sealed interface MemoryLayout extends Constable permits SequenceLayout, GroupLayout, ValueLayout (not exhaustive)</pre> <div class="block">A memory layout can be used to describe the contents of a memory segment in a <em>language neutral</em> fashion. There are two leaves in the layout hierarchy, <em>value layouts</em>, which are used to represent values of given size and kind (see <a href="valuelayout" title="class in jdk.incubator.foreign"><code>ValueLayout</code></a>) and <em>padding layouts</em> which are used, as the name suggests, to represent a portion of a memory segment whose contents should be ignored, and which are primarily present for alignment reasons (see <a href="#paddingLayout(long)"><code>paddingLayout(long)</code></a>). Some common value layout constants are defined in the <a href="memorylayouts" title="class in jdk.incubator.foreign"><code>MemoryLayouts</code></a> class. <p> More complex layouts can be derived from simpler ones: a <em>sequence layout</em> denotes a repetition of one or more element layout (see <a href="sequencelayout" title="class in jdk.incubator.foreign"><code>SequenceLayout</code></a>); a <em>group layout</em> denotes an aggregation of (typically) heterogeneous member layouts (see <a href="grouplayout" title="class in jdk.incubator.foreign"><code>GroupLayout</code></a>). </p>
<p> For instance, consider the following struct declaration in C: </p>
<blockquote><pre class="lang-java" data-language="java"><code>
 typedef struct {
     char kind;
     int value;
 } TaggedValues[5];
 </code></pre></blockquote> The above declaration can be modelled using a layout object, as follows: <blockquote><pre class="lang-java" data-language="java"><code>
SequenceLayout taggedValues = MemoryLayout.sequenceLayout(5,
    MemoryLayout.structLayout(
        MemoryLayout.valueLayout(8, ByteOrder.nativeOrder()).withName("kind"),
        MemoryLayout.paddingLayout(24),
        MemoryLayout.valueLayout(32, ByteOrder.nativeOrder()).withName("value")
    )
).withName("TaggedValues");
 </code></pre></blockquote> <p> All implementations of this interface must be <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/doc-files/ValueBased.html">value-based</a>; programmers should treat instances that are <a href="#equals(java.lang.Object)">equal</a> as interchangeable and should not use instances for synchronization, or unpredictable behavior may occur. For example, in a future release, synchronization may fail. The <code>equals</code> method should be used for comparisons. </p>
<p> Non-platform classes should not implement <a href="memorylayout" title="interface in jdk.incubator.foreign">MemoryLayout</a> directly. </p>
<p> Unless otherwise specified, passing a <code>null</code> argument, or an array argument containing one or more <code>null</code> elements to a method in this class causes a <a href="../../../../java.base/java/lang/nullpointerexception" title="class in java.lang"><code>NullPointerException</code></a> to be thrown. </p> <h2><a id="layout-align">Size, alignment and byte order</a></h2> All layouts have a size; layout size for value and padding layouts is always explicitly denoted; this means that a layout description always has the same size in bits, regardless of the platform in which it is used. For derived layouts, the size is computed as follows: <ul> <li>for a <em>finite</em> sequence layout <em>S</em> whose element layout is <em>E</em> and size is L, the size of <em>S</em> is that of <em>E</em>, multiplied by <em>L</em>
</li> <li>the size of an <em>unbounded</em> sequence layout is <em>unknown</em>
</li> <li>for a group layout <em>G</em> with member layouts <em>M1</em>, <em>M2</em>, ... <em>Mn</em> whose sizes are <em>S1</em>, <em>S2</em>, ... <em>Sn</em>, respectively, the size of <em>G</em> is either <em>S1 + S2 + ... + Sn</em> or <em>max(S1, S2, ... Sn)</em> depending on whether the group is a <em>struct</em> or an <em>union</em>, respectively</li> </ul> <p> Furthermore, all layouts feature a <em>natural alignment</em> which can be inferred as follows: </p>
<ul> <li>for a padding layout <em>L</em>, the natural alignment is 1, regardless of its size; that is, in the absence of an explicit alignment constraint, a padding layout should not affect the alignment constraint of the group layout it is nested into</li> <li>for a value layout <em>L</em> whose size is <em>N</em>, the natural alignment of <em>L</em> is <em>N</em>
</li> <li>for a sequence layout <em>S</em> whose element layout is <em>E</em>, the natural alignment of <em>S</em> is that of <em>E</em>
</li> <li>for a group layout <em>G</em> with member layouts <em>M1</em>, <em>M2</em>, ... <em>Mn</em> whose alignments are <em>A1</em>, <em>A2</em>, ... <em>An</em>, respectively, the natural alignment of <em>G</em> is <em>max(A1, A2 ... An)</em>
</li> </ul> A layout's natural alignment can be overridden if needed (see <a href="#withBitAlignment(long)"><code>withBitAlignment(long)</code></a>), which can be useful to describe hyper-aligned layouts. <p> All value layouts have an <em>explicit</em> byte order (see <a href="../../../../java.base/java/nio/byteorder" title="class in java.nio"><code>ByteOrder</code></a>) which is set when the layout is created. </p>
<h2><a id="layout-paths">Layout paths</a></h2> A <em>layout path</em> originates from a <em>root</em> layout (typically a group or a sequence layout) and terminates at a layout nested within the root layout - this is the layout <em>selected</em> by the layout path. Layout paths are typically expressed as a sequence of one or more <a href="memorylayout.pathelement" title="interface in jdk.incubator.foreign"><code>MemoryLayout.PathElement</code></a> instances. <p> Layout paths are for example useful in order to obtain offsets of arbitrarily nested layouts inside another layout (see <a href="#bitOffset(jdk.incubator.foreign.MemoryLayout.PathElement...)"><code>bitOffset(PathElement...)</code></a>), to quickly obtain a memory access handle corresponding to the selected layout (see <a href="#varHandle(java.lang.Class,jdk.incubator.foreign.MemoryLayout.PathElement...)"><code>varHandle(Class, PathElement...)</code></a>), to select an arbitrarily nested layout inside another layout (see <a href="#select(jdk.incubator.foreign.MemoryLayout.PathElement...)"><code>select(PathElement...)</code></a>, or to transform a nested layout element inside another layout (see <a href="#map(java.util.function.UnaryOperator,jdk.incubator.foreign.MemoryLayout.PathElement...)"><code>map(UnaryOperator, PathElement...)</code></a>). </p>
<p> Such <em>layout paths</em> can be constructed programmatically using the methods in this class. For instance, given the <code>taggedValues</code> layout instance constructed as above, we can obtain the offset, in bits, of the member layout named <code>value</code> in the <em>first</em> sequence element, as follows: </p>
<blockquote><pre class="lang-java" data-language="java"><code>
long valueOffset = taggedValues.bitOffset(PathElement.sequenceElement(0),
                                          PathElement.groupElement("value")); // yields 32
 </code></pre></blockquote> Similarly, we can select the member layout named <code>value</code>, as follows: <blockquote><pre class="lang-java" data-language="java"><code>
MemoryLayout value = taggedValues.select(PathElement.sequenceElement(),
                                         PathElement.groupElement("value"));
 </code></pre></blockquote> And, we can also replace the layout named <code>value</code> with another layout, as follows: <blockquote><pre class="lang-java" data-language="java"><code>
MemoryLayout taggedValuesWithHole = taggedValues.map(l -&gt; MemoryLayout.paddingLayout(32),
                                            PathElement.sequenceElement(), PathElement.groupElement("value"));
 </code></pre></blockquote> That is, the above declaration is identical to the following, more verbose one: <blockquote><pre class="lang-java" data-language="java"><code>
MemoryLayout taggedValuesWithHole = MemoryLayout.sequenceLayout(5,
    MemoryLayout.structLayout(
        MemoryLayout.valueLayout(8, ByteOrder.nativeOrder()).withName("kind"),
        MemoryLayout.paddingLayout(32),
        MemoryLayout.paddingLayout(32)
));
 </code></pre></blockquote> Layout paths can feature one or more <em>free dimensions</em>. For instance, a layout path traversing an unspecified sequence element (that is, where one of the path component was obtained with the <a href="memorylayout.pathelement#sequenceElement()"><code>MemoryLayout.PathElement.sequenceElement()</code></a> method) features an additional free dimension, which will have to be bound at runtime. This is important when obtaining memory access var handle from layouts, as in the following code: <blockquote><pre class="lang-java" data-language="java"><code>
VarHandle valueHandle = taggedValues.varHandle(int.class,
                                               PathElement.sequenceElement(),
                                               PathElement.groupElement("value"));
 </code></pre></blockquote> Since the layout path constructed in the above example features exactly one free dimension (as it doesn't specify <em>which</em> member layout named <code>value</code> should be selected from the enclosing sequence layout), it follows that the memory access var handle <code>valueHandle</code> will feature an <em>additional</em> <code>long</code> access coordinate. <p>A layout path with free dimensions can also be used to create an offset-computing method handle, using the <a href="#bitOffset(jdk.incubator.foreign.MemoryLayout.PathElement...)"><code>bitOffset(PathElement...)</code></a> or <a href="#byteOffsetHandle(jdk.incubator.foreign.MemoryLayout.PathElement...)"><code>byteOffsetHandle(PathElement...)</code></a> method. Again, free dimensions are translated into <code>long</code> parameters of the created method handle. The method handle can be used to compute the offsets of elements of a sequence at different indices, by supplying these indices when invoking the method handle. For instance: </p>
<blockquote><pre class="lang-java" data-language="java"><code>
MethodHandle offsetHandle = taggedValues.byteOffsetHandle(PathElement.sequenceElement(),
                                                          PathElement.groupElement("kind"));
long offset1 = (long) offsetHandle.invokeExact(1L); // 8
long offset2 = (long) offsetHandle.invokeExact(2L); // 16
 </code></pre></blockquote> <h2>Layout attributes</h2> Layouts can be optionally associated with one or more <em>attributes</em>. A layout attribute forms a <em>name/value</em> pair, where the name is a <a href="../../../../java.base/java/lang/string" title="class in java.lang"><code>String</code></a> and the value is a <a href="../../../../java.base/java/lang/constant/constable" title="interface in java.lang.constant"><code>Constable</code></a>. The most common form of layout attribute is the <em>layout name</em> (see <a href="#LAYOUT_NAME"><code>LAYOUT_NAME</code></a>), a custom name that can be associated with memory layouts and that can be referred to when constructing <a href="memorylayout#layout-paths"><em>layout paths</em></a>.</div> <dl class="notes"> <dt>Implementation Requirements:</dt> <dd>Implementations of this interface are immutable, thread-safe and <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/doc-files/ValueBased.html">value-based</a>.</dd> </dl> </section> <section class="summary"> <section class="nested-class-summary" id="nested-class-summary"> <h2>Nested Class Summary</h2>  <table class="summary-table three-column-summary">       <tr>
<th>Modifier and Type</th>
<th>Interface</th>
<th>Description</th>
</tr>
<tr>
<td><code>static interface </code></td>
<td><code><a href="memorylayout.pathelement" class="type-name-link" title="interface in jdk.incubator.foreign">MemoryLayout.PathElement</a></code></td>
<td> <div class="block">Instances of this class are used to form <a href="memorylayout#layout-paths"><em>layout paths</em></a>.</div> </td>
</tr>
</table> </section><section class="field-summary" id="field-summary"> <h2>Field Summary</h2>  <table class="summary-table three-column-summary">       <tr>
<th>Modifier and Type</th>
<th>Field</th>
<th>Description</th>
</tr>
<tr>
<td><code>static final <a href="../../../../java.base/java/lang/string" title="class in java.lang">String</a></code></td>
<td><code><a href="#LAYOUT_NAME" class="member-name-link">LAYOUT_NAME</a></code></td>
<td> <div class="block">Attribute name used to specify the <em>name</em> property of a memory layout (see <a href="#name()"><code>name()</code></a> and <a href="#withName(java.lang.String)"><code>withName(String)</code></a>).</div> </td>
</tr>
</table> </section><section class="method-summary" id="method-summary"> <h2>Method Summary</h2> <div id="method-summary-table">  <div id="method-summary-table.tabpanel" role="tabpanel"> <table class="summary-table three-column-summary" aria-labelledby="method-summary-table-tab0">                                                                                              <tr>
<th>Modifier and Type</th>
<th>Method</th>
<th>Description</th>
</tr>
<tr>
<td><code><a href="../../../../java.base/java/util/optional" title="class in java.util">Optional</a>&lt;<a href="../../../../java.base/java/lang/constant/constable" title="interface in java.lang.constant">Constable</a>&gt;</code></td>
<td><code><a href="#attribute(java.lang.String)" class="member-name-link">attribute</a><wbr>(<a href="../../../../java.base/java/lang/string" title="class in java.lang">String</a> name)</wbr></code></td>
<td> <div class="block">Returns the attribute with the given name (if it exists).</div> </td>
</tr>
<tr>
<td><code><a href="../../../../java.base/java/util/stream/stream" title="interface in java.util.stream">Stream</a>&lt;<a href="../../../../java.base/java/lang/string" title="class in java.lang">String</a>&gt;</code></td>
<td><code><a href="#attributes()" class="member-name-link">attributes</a>()</code></td>
<td> <div class="block">Returns a stream of the attribute names associated with this layout.</div> </td>
</tr>
<tr>
<td><code>long</code></td>
<td><code><a href="#bitAlignment()" class="member-name-link">bitAlignment</a>()</code></td>
<td> <div class="block">Returns the alignment constraint associated with this layout, expressed in bits.</div> </td>
</tr>
<tr>
<td><code>default long</code></td>
<td><code><a href="#bitOffset(jdk.incubator.foreign.MemoryLayout.PathElement...)" class="member-name-link">bitOffset</a><wbr>(<a href="memorylayout.pathelement" title="interface in jdk.incubator.foreign">MemoryLayout.PathElement</a>... elements)</wbr></code></td>
<td> <div class="block">Computes the offset, in bits, of the layout selected by a given layout path, where the path is considered rooted in this layout.</div> </td>
</tr>
<tr>
<td><code>default <a href="../../../../java.base/java/lang/invoke/methodhandle" title="class in java.lang.invoke">MethodHandle</a></code></td>
<td><code><a href="#bitOffsetHandle(jdk.incubator.foreign.MemoryLayout.PathElement...)" class="member-name-link">bitOffsetHandle</a><wbr>(<a href="memorylayout.pathelement" title="interface in jdk.incubator.foreign">MemoryLayout.PathElement</a>... elements)</wbr></code></td>
<td> <div class="block">Creates a method handle that can be used to compute the offset, in bits, of the layout selected by a given layout path, where the path is considered rooted in this layout.</div> </td>
</tr>
<tr>
<td><code>long</code></td>
<td><code><a href="#bitSize()" class="member-name-link">bitSize</a>()</code></td>
<td> <div class="block">Computes the layout size, in bits.</div> </td>
</tr>
<tr>
<td><code>default long</code></td>
<td><code><a href="#byteAlignment()" class="member-name-link">byteAlignment</a>()</code></td>
<td> <div class="block">Returns the alignment constraint associated with this layout, expressed in bytes.</div> </td>
</tr>
<tr>
<td><code>default long</code></td>
<td><code><a href="#byteOffset(jdk.incubator.foreign.MemoryLayout.PathElement...)" class="member-name-link">byteOffset</a><wbr>(<a href="memorylayout.pathelement" title="interface in jdk.incubator.foreign">MemoryLayout.PathElement</a>... elements)</wbr></code></td>
<td> <div class="block">Computes the offset, in bytes, of the layout selected by a given layout path, where the path is considered rooted in this layout.</div> </td>
</tr>
<tr>
<td><code>default <a href="../../../../java.base/java/lang/invoke/methodhandle" title="class in java.lang.invoke">MethodHandle</a></code></td>
<td><code><a href="#byteOffsetHandle(jdk.incubator.foreign.MemoryLayout.PathElement...)" class="member-name-link">byteOffsetHandle</a><wbr>(<a href="memorylayout.pathelement" title="interface in jdk.incubator.foreign">MemoryLayout.PathElement</a>... elements)</wbr></code></td>
<td> <div class="block">Creates a method handle that can be used to compute the offset, in bytes, of the layout selected by a given layout path, where the path is considered rooted in this layout.</div> </td>
</tr>
<tr>
<td><code>default long</code></td>
<td><code><a href="#byteSize()" class="member-name-link">byteSize</a>()</code></td>
<td> <div class="block">Computes the layout size, in bytes.</div> </td>
</tr>
<tr>
<td><code><a href="../../../../java.base/java/util/optional" title="class in java.util">Optional</a>&lt;? extends <a href="../../../../java.base/java/lang/constant/dynamicconstantdesc" title="class in java.lang.constant">DynamicConstantDesc</a>&lt;? extends <a href="memorylayout" title="interface in jdk.incubator.foreign">MemoryLayout</a>&gt;&gt;</code></td>
<td><code><a href="#describeConstable()" class="member-name-link">describeConstable</a>()</code></td>
<td> <div class="block">Returns an <a href="../../../../java.base/java/util/optional" title="class in java.util"><code>Optional</code></a> containing the nominal descriptor for this layout, if one can be constructed, or an empty <a href="../../../../java.base/java/util/optional" title="class in java.util"><code>Optional</code></a> if one cannot be constructed.</div> </td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code><a href="#equals(java.lang.Object)" class="member-name-link">equals</a><wbr>(<a href="../../../../java.base/java/lang/object" title="class in java.lang">Object</a> that)</wbr></code></td>
<td> <div class="block">Compares the specified object with this layout for equality.</div> </td>
</tr>
<tr>
<td><code>int</code></td>
<td><code><a href="#hashCode()" class="member-name-link">hashCode</a>()</code></td>
<td> <div class="block">Returns the hash code value for this layout.</div> </td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code><a href="#hasSize()" class="member-name-link">hasSize</a>()</code></td>
<td> <div class="block">Does this layout have a specified size?</div> </td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code><a href="#isPadding()" class="member-name-link">isPadding</a>()</code></td>
<td> <div class="block">Is this a padding layout (e.g. a layout created from <a href="#paddingLayout(long)"><code>paddingLayout(long)</code></a>) ?</div> </td>
</tr>
<tr>
<td><code>default <a href="memorylayout" title="interface in jdk.incubator.foreign">MemoryLayout</a></code></td>
<td><code><a href="#map(java.util.function.UnaryOperator,jdk.incubator.foreign.MemoryLayout.PathElement...)" class="member-name-link">map</a><wbr>(<a href="../../../../java.base/java/util/function/unaryoperator" title="interface in java.util.function">UnaryOperator</a>&lt;<a href="memorylayout" title="interface in jdk.incubator.foreign">MemoryLayout</a>&gt; op,
 <a href="memorylayout.pathelement" title="interface in jdk.incubator.foreign">MemoryLayout.PathElement</a>... elements)</wbr></code></td>
<td> <div class="block">Creates a transformed copy of this layout where a selected layout, from a path rooted in this layout, is replaced with the result of applying the given operation.</div> </td>
</tr>
<tr>
<td><code><a href="../../../../java.base/java/util/optional" title="class in java.util">Optional</a>&lt;<a href="../../../../java.base/java/lang/string" title="class in java.lang">String</a>&gt;</code></td>
<td><code><a href="#name()" class="member-name-link">name</a>()</code></td>
<td> <div class="block">Return the <em>name</em> (if any) associated with this layout.</div> </td>
</tr>
<tr>
<td><code>static <a href="memorylayout" title="interface in jdk.incubator.foreign">MemoryLayout</a></code></td>
<td><code><a href="#paddingLayout(long)" class="member-name-link">paddingLayout</a><wbr>(long size)</wbr></code></td>
<td> <div class="block">Create a new padding layout with given size.</div> </td>
</tr>
<tr>
<td><code>default <a href="memorylayout" title="interface in jdk.incubator.foreign">MemoryLayout</a></code></td>
<td><code><a href="#select(jdk.incubator.foreign.MemoryLayout.PathElement...)" class="member-name-link">select</a><wbr>(<a href="memorylayout.pathelement" title="interface in jdk.incubator.foreign">MemoryLayout.PathElement</a>... elements)</wbr></code></td>
<td> <div class="block">Selects the layout from a path rooted in this layout.</div> </td>
</tr>
<tr>
<td><code>static <a href="sequencelayout" title="class in jdk.incubator.foreign">SequenceLayout</a></code></td>
<td><code><a href="#sequenceLayout(long,jdk.incubator.foreign.MemoryLayout)" class="member-name-link">sequenceLayout</a><wbr>(long elementCount,
 <a href="memorylayout" title="interface in jdk.incubator.foreign">MemoryLayout</a> elementLayout)</wbr></code></td>
<td> <div class="block">Create a new sequence layout with given element layout and element count.</div> </td>
</tr>
<tr>
<td><code>static <a href="sequencelayout" title="class in jdk.incubator.foreign">SequenceLayout</a></code></td>
<td><code><a href="#sequenceLayout(jdk.incubator.foreign.MemoryLayout)" class="member-name-link">sequenceLayout</a><wbr>(<a href="memorylayout" title="interface in jdk.incubator.foreign">MemoryLayout</a> elementLayout)</wbr></code></td>
<td> <div class="block">Create a new sequence layout, with unbounded element count and given element layout.</div> </td>
</tr>
<tr>
<td><code>default <a href="../../../../java.base/java/lang/invoke/methodhandle" title="class in java.lang.invoke">MethodHandle</a></code></td>
<td><code><a href="#sliceHandle(jdk.incubator.foreign.MemoryLayout.PathElement...)" class="member-name-link">sliceHandle</a><wbr>(<a href="memorylayout.pathelement" title="interface in jdk.incubator.foreign">MemoryLayout.PathElement</a>... elements)</wbr></code></td>
<td> <div class="block">Creates a method handle which, given a memory segment, returns a <a href="memorysegment#asSlice(long,long)">slice</a> corresponding to the layout selected by a given layout path, where the path is considered rooted in this layout.</div> </td>
</tr>
<tr>
<td><code>static <a href="grouplayout" title="class in jdk.incubator.foreign">GroupLayout</a></code></td>
<td><code><a href="#structLayout(jdk.incubator.foreign.MemoryLayout...)" class="member-name-link">structLayout</a><wbr>(<a href="memorylayout" title="interface in jdk.incubator.foreign">MemoryLayout</a>... elements)</wbr></code></td>
<td> <div class="block">Create a new <em>struct</em> group layout with given member layouts.</div> </td>
</tr>
<tr>
<td><code><a href="../../../../java.base/java/lang/string" title="class in java.lang">String</a></code></td>
<td><code><a href="#toString()" class="member-name-link">toString</a>()</code></td>
<td> <div class="block">Returns a string representation of this layout.</div> </td>
</tr>
<tr>
<td><code>static <a href="grouplayout" title="class in jdk.incubator.foreign">GroupLayout</a></code></td>
<td><code><a href="#unionLayout(jdk.incubator.foreign.MemoryLayout...)" class="member-name-link">unionLayout</a><wbr>(<a href="memorylayout" title="interface in jdk.incubator.foreign">MemoryLayout</a>... elements)</wbr></code></td>
<td> <div class="block">Create a new <em>union</em> group layout with given member layouts.</div> </td>
</tr>
<tr>
<td><code>static <a href="valuelayout" title="class in jdk.incubator.foreign">ValueLayout</a></code></td>
<td><code><a href="#valueLayout(long,java.nio.ByteOrder)" class="member-name-link">valueLayout</a><wbr>(long size,
 <a href="../../../../java.base/java/nio/byteorder" title="class in java.nio">ByteOrder</a> order)</wbr></code></td>
<td> <div class="block">Create a value layout of given byte order and size.</div> </td>
</tr>
<tr>
<td><code>default <a href="../../../../java.base/java/lang/invoke/varhandle" title="class in java.lang.invoke">VarHandle</a></code></td>
<td><code><a href="#varHandle(java.lang.Class,jdk.incubator.foreign.MemoryLayout.PathElement...)" class="member-name-link">varHandle</a><wbr>(<a href="../../../../java.base/java/lang/class" title="class in java.lang">Class</a>&lt;?&gt; carrier,
 <a href="memorylayout.pathelement" title="interface in jdk.incubator.foreign">MemoryLayout.PathElement</a>... elements)</wbr></code></td>
<td> <div class="block">Creates a memory access var handle that can be used to dereference memory at the layout selected by a given layout path, where the path is considered rooted in this layout.</div> </td>
</tr>
<tr>
<td><code><a href="memorylayout" title="interface in jdk.incubator.foreign">MemoryLayout</a></code></td>
<td><code><a href="#withAttribute(java.lang.String,java.lang.constant.Constable)" class="member-name-link">withAttribute</a><wbr>(<a href="../../../../java.base/java/lang/string" title="class in java.lang">String</a> name,
 <a href="../../../../java.base/java/lang/constant/constable" title="interface in java.lang.constant">Constable</a> value)</wbr></code></td>
<td> <div class="block">Returns a new memory layout which features the same attributes as this layout, plus the newly specified attribute.</div> </td>
</tr>
<tr>
<td><code><a href="memorylayout" title="interface in jdk.incubator.foreign">MemoryLayout</a></code></td>
<td><code><a href="#withBitAlignment(long)" class="member-name-link">withBitAlignment</a><wbr>(long bitAlignment)</wbr></code></td>
<td> <div class="block">Creates a new layout which features the desired alignment constraint.</div> </td>
</tr>
<tr>
<td><code><a href="memorylayout" title="interface in jdk.incubator.foreign">MemoryLayout</a></code></td>
<td><code><a href="#withName(java.lang.String)" class="member-name-link">withName</a><wbr>(<a href="../../../../java.base/java/lang/string" title="class in java.lang">String</a> name)</wbr></code></td>
<td> <div class="block">Creates a new layout which features the desired layout <em>name</em>.</div> </td>
</tr>
</table> </div> </div> </section> </section> <section class="details"> <section class="field-details" id="field-detail"> <h2>Field Details</h2>  </section><section class="detail" id="LAYOUT_NAME"> <h3>LAYOUT_NAME</h3> <pre class="lang-java" data-language="java">static final String LAYOUT_NAME</pre> <div class="block">Attribute name used to specify the <em>name</em> property of a memory layout (see <a href="#name()"><code>name()</code></a> and <a href="#withName(java.lang.String)"><code>withName(String)</code></a>).</div> <dl class="notes"> <dt>See Also:</dt> <dd> <ul class="see-list"> <li><a href="https://docs.oracle.com/en/java/javase/17/docs/api/constant-values.html#jdk.incubator.foreign.MemoryLayout.LAYOUT_NAME">Constant Field Values</a></li> </ul> </dd> </dl> </section><section class="method-details" id="method-detail"> <h2>Method Details</h2>  </section><section class="detail" id="describeConstable()"> <h3>describeConstable</h3> <pre class="lang-java" data-language="java">Optional&lt;? extends DynamicConstantDesc&lt;? extends MemoryLayout&gt;&gt; describeConstable()</pre> <div class="block">Returns an <a href="../../../../java.base/java/util/optional" title="class in java.util"><code>Optional</code></a> containing the nominal descriptor for this layout, if one can be constructed, or an empty <a href="../../../../java.base/java/util/optional" title="class in java.util"><code>Optional</code></a> if one cannot be constructed.</div> <dl class="notes"> <dt>Specified by:</dt> <dd>
<code><a href="../../../../java.base/java/lang/constant/constable#describeConstable()">describeConstable</a></code> in interface <code><a href="../../../../java.base/java/lang/constant/constable" title="interface in java.lang.constant">Constable</a></code>
</dd> <dt>Returns:</dt> <dd>An <a href="../../../../java.base/java/util/optional" title="class in java.util"><code>Optional</code></a> containing the resulting nominal descriptor, or an empty <a href="../../../../java.base/java/util/optional" title="class in java.util"><code>Optional</code></a> if one cannot be constructed.</dd> </dl> </section><section class="detail" id="hasSize()"> <h3>hasSize</h3> <pre class="lang-java" data-language="java">boolean hasSize()</pre> <div class="block">Does this layout have a specified size? A layout does not have a specified size if it is (or contains) a sequence layout whose size is unspecified (see <a href="sequencelayout#elementCount()"><code>SequenceLayout.elementCount()</code></a>). Value layouts (see <a href="valuelayout" title="class in jdk.incubator.foreign"><code>ValueLayout</code></a>) and padding layouts (see <a href="#paddingLayout(long)"><code>paddingLayout(long)</code></a>) <em>always</em> have a specified size, therefore this method always returns <code>true</code> in these cases.</div> <dl class="notes"> <dt>Returns:</dt> <dd>
<code>true</code>, if this layout has a specified size.</dd> </dl> </section><section class="detail" id="bitSize()"> <h3>bitSize</h3> <pre class="lang-java" data-language="java">long bitSize()</pre> <div class="block">Computes the layout size, in bits.</div> <dl class="notes"> <dt>Returns:</dt> <dd>the layout size, in bits.</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.base/java/lang/unsupportedoperationexception" title="class in java.lang">UnsupportedOperationException</a></code> - if the layout is, or contains, a sequence layout with unspecified size (see <a href="sequencelayout" title="class in jdk.incubator.foreign"><code>SequenceLayout</code></a>).</dd> </dl> </section><section class="detail" id="byteSize()"> <h3>byteSize</h3> <pre class="lang-java" data-language="java">default long byteSize()</pre> <div class="block">Computes the layout size, in bytes.</div> <dl class="notes"> <dt>Returns:</dt> <dd>the layout size, in bytes.</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.base/java/lang/unsupportedoperationexception" title="class in java.lang">UnsupportedOperationException</a></code> - if the layout is, or contains, a sequence layout with unspecified size (see <a href="sequencelayout" title="class in jdk.incubator.foreign"><code>SequenceLayout</code></a>), or if <code>bitSize()</code> is not a multiple of 8.</dd> </dl> </section><section class="detail" id="name()"> <h3>name</h3> <pre class="lang-java" data-language="java">Optional&lt;String&gt; name()</pre> <div class="block">Return the <em>name</em> (if any) associated with this layout. <p> This is equivalent to the following code: </p>
<blockquote><pre class="lang-java" data-language="java"><code>
    attribute(LAYOUT_NAME).map(String.class::cast);
 </code></pre></blockquote>
</div> <dl class="notes"> <dt>Returns:</dt> <dd>the layout <em>name</em> (if any).</dd> <dt>See Also:</dt> <dd> <ul class="see-list"> <li><a href="#withName(java.lang.String)"><code>withName(String)</code></a></li> </ul> </dd> </dl> </section><section class="detail" id="withName(java.lang.String)"> <h3>withName</h3> <pre class="lang-java" data-language="java">MemoryLayout withName(String name)</pre> <div class="block">Creates a new layout which features the desired layout <em>name</em>. <p> This is equivalent to the following code: </p>
<blockquote><pre class="lang-java" data-language="java"><code>
    withAttribute(LAYOUT_NAME, name);
 </code></pre></blockquote>
</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>name</code> - the layout name.</dd> <dt>Returns:</dt> <dd>a new layout which is the same as this layout, except for the <em>name</em> associated with it.</dd> <dt>See Also:</dt> <dd> <ul class="see-list"> <li><a href="#name()"><code>name()</code></a></li> </ul> </dd> </dl> </section><section class="detail" id="bitAlignment()"> <h3>bitAlignment</h3> <pre class="lang-java" data-language="java">long bitAlignment()</pre> <div class="block">Returns the alignment constraint associated with this layout, expressed in bits. Layout alignment defines a power of two <code>A</code> which is the bit-wise alignment of the layout. If <code>A &lt;= 8</code> then <code>A/8</code> is the number of bytes that must be aligned for any pointer that correctly points to this layout. Thus: <ul> <li>
<code>A=8</code> means unaligned (in the usual sense), which is common in packets.</li> <li>
<code>A=64</code> means word aligned (on LP64), <code>A=32</code> int aligned, <code>A=16</code> short aligned, etc.</li> <li>
<code>A=512</code> is the most strict alignment required by the x86/SV ABI (for AVX-512 data).</li> </ul> If no explicit alignment constraint was set on this layout (see <a href="#withBitAlignment(long)"><code>withBitAlignment(long)</code></a>), then this method returns the <a href="#layout-align">natural alignment</a> constraint (in bits) associated with this layout.</div> <dl class="notes"> <dt>Returns:</dt> <dd>the layout alignment constraint, in bits.</dd> </dl> </section><section class="detail" id="byteAlignment()"> <h3>byteAlignment</h3> <pre class="lang-java" data-language="java">default long byteAlignment()</pre> <div class="block">Returns the alignment constraint associated with this layout, expressed in bytes. Layout alignment defines a power of two <code>A</code> which is the byte-wise alignment of the layout, where <code>A</code> is the number of bytes that must be aligned for any pointer that correctly points to this layout. Thus: <ul> <li>
<code>A=1</code> means unaligned (in the usual sense), which is common in packets.</li> <li>
<code>A=8</code> means word aligned (on LP64), <code>A=4</code> int aligned, <code>A=2</code> short aligned, etc.</li> <li>
<code>A=64</code> is the most strict alignment required by the x86/SV ABI (for AVX-512 data).</li> </ul> If no explicit alignment constraint was set on this layout (see <a href="#withBitAlignment(long)"><code>withBitAlignment(long)</code></a>), then this method returns the <a href="#layout-align">natural alignment</a> constraint (in bytes) associated with this layout.</div> <dl class="notes"> <dt>Returns:</dt> <dd>the layout alignment constraint, in bytes.</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.base/java/lang/unsupportedoperationexception" title="class in java.lang">UnsupportedOperationException</a></code> - if <code>bitAlignment()</code> is not a multiple of 8.</dd> </dl> </section><section class="detail" id="withBitAlignment(long)"> <h3>withBitAlignment</h3> <pre class="lang-java" data-language="java">MemoryLayout withBitAlignment(long bitAlignment)</pre> <div class="block">Creates a new layout which features the desired alignment constraint.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>bitAlignment</code> - the layout alignment constraint, expressed in bits.</dd> <dt>Returns:</dt> <dd>a new layout which is the same as this layout, except for the alignment constraint associated with it.</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.base/java/lang/illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if <code>bitAlignment</code> is not a power of two, or if it's less than than 8.</dd> </dl> </section><section class="detail" id="attribute(java.lang.String)"> <h3>attribute</h3> <pre class="lang-java" data-language="java">Optional&lt;Constable&gt; attribute(String name)</pre> <div class="block">Returns the attribute with the given name (if it exists).</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>name</code> - the attribute name</dd> <dt>Returns:</dt> <dd>the attribute with the given name (if it exists).</dd> </dl> </section><section class="detail" id="withAttribute(java.lang.String,java.lang.constant.Constable)"> <h3>withAttribute</h3> <pre class="lang-java" data-language="java">MemoryLayout withAttribute(String name, Constable value)</pre> <div class="block">Returns a new memory layout which features the same attributes as this layout, plus the newly specified attribute. If this layout already contains an attribute with the same name, the existing attribute value is overwritten in the returned layout.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>name</code> - the attribute name.</dd> <dd>
<code>value</code> - the attribute value.</dd> <dt>Returns:</dt> <dd>a new memory layout which features the same attributes as this layout, plus the newly specified attribute.</dd> </dl> </section><section class="detail" id="attributes()"> <h3>attributes</h3> <pre class="lang-java" data-language="java">Stream&lt;String&gt; attributes()</pre> <div class="block">Returns a stream of the attribute names associated with this layout.</div> <dl class="notes"> <dt>Returns:</dt> <dd>a stream of the attribute names associated with this layout.</dd> </dl> </section><section class="detail" id="bitOffset(jdk.incubator.foreign.MemoryLayout.PathElement...)"> <h3>bitOffset</h3> <pre class="lang-java" data-language="java">default long bitOffset(MemoryLayout.PathElement... elements)</pre> <div class="block">Computes the offset, in bits, of the layout selected by a given layout path, where the path is considered rooted in this layout.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>elements</code> - the layout path elements.</dd> <dt>Returns:</dt> <dd>The offset, in bits, of the layout selected by the layout path in <code>elements</code>.</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.base/java/lang/illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if the layout path does not select any layout nested in this layout, or if the layout path contains one or more path elements that select multiple sequence element indices (see <a href="memorylayout.pathelement#sequenceElement()"><code>MemoryLayout.PathElement.sequenceElement()</code></a> and <a href="memorylayout.pathelement#sequenceElement(long,long)"><code>MemoryLayout.PathElement.sequenceElement(long, long)</code></a>).</dd> <dd>
<code><a href="../../../../java.base/java/lang/unsupportedoperationexception" title="class in java.lang">UnsupportedOperationException</a></code> - if one of the layouts traversed by the layout path has unspecified size.</dd> <dd>
<code><a href="../../../../java.base/java/lang/nullpointerexception" title="class in java.lang">NullPointerException</a></code> - if either <code>elements == null</code>, or if any of the elements in <code>elements</code> is <code>null</code>.</dd> </dl> </section><section class="detail" id="bitOffsetHandle(jdk.incubator.foreign.MemoryLayout.PathElement...)"> <h3>bitOffsetHandle</h3> <pre class="lang-java" data-language="java">default MethodHandle bitOffsetHandle(MemoryLayout.PathElement... elements)</pre> <div class="block">Creates a method handle that can be used to compute the offset, in bits, of the layout selected by a given layout path, where the path is considered rooted in this layout. <p>The returned method handle has a return type of <code>long</code>, and features as many <code>long</code> parameter types as there are free dimensions in the provided layout path (see <a href="memorylayout.pathelement#sequenceElement()"><code>MemoryLayout.PathElement.sequenceElement()</code></a>, where the order of the parameters corresponds to the order of the path elements. The returned method handle can be used to compute a layout offset similar to <a href="#bitOffset(jdk.incubator.foreign.MemoryLayout.PathElement...)"><code>bitOffset(PathElement...)</code></a>, but where some sequence indices are specified only when invoking the method handle. </p>
<p>The final offset returned by the method handle is computed as follows: </p>
<blockquote><pre class="lang-java" data-language="java"><code>
    offset = c_1 + c_2 + ... + c_m + (x_1 * s_1) + (x_2 * s_2) + ... + (x_n * s_n)
 </code></pre></blockquote> where <code>x_1</code>, <code>x_2</code>, ... <code>x_n</code> are <em>dynamic</em> values provided as <code>long</code> arguments, whereas <code>c_1</code>, <code>c_2</code>, ... <code>c_m</code> are <em>static</em> offset constants and <code>s_0</code>, <code>s_1</code>, ... <code>s_n</code> are <em>static</em> stride constants which are derived from the layout path.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>elements</code> - the layout path elements.</dd> <dt>Returns:</dt> <dd>a method handle that can be used to compute the bit offset of the layout element specified by the given layout path elements, when supplied with the missing sequence element indices.</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.base/java/lang/illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if the layout path contains one or more path elements that select multiple sequence element indices (see <a href="memorylayout.pathelement#sequenceElement(long,long)"><code>MemoryLayout.PathElement.sequenceElement(long, long)</code></a>).</dd> <dd>
<code><a href="../../../../java.base/java/lang/unsupportedoperationexception" title="class in java.lang">UnsupportedOperationException</a></code> - if one of the layouts traversed by the layout path has unspecified size.</dd> </dl> </section><section class="detail" id="byteOffset(jdk.incubator.foreign.MemoryLayout.PathElement...)"> <h3>byteOffset</h3> <pre class="lang-java" data-language="java">default long byteOffset(MemoryLayout.PathElement... elements)</pre> <div class="block">Computes the offset, in bytes, of the layout selected by a given layout path, where the path is considered rooted in this layout.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>elements</code> - the layout path elements.</dd> <dt>Returns:</dt> <dd>The offset, in bytes, of the layout selected by the layout path in <code>elements</code>.</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.base/java/lang/illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if the layout path does not select any layout nested in this layout, or if the layout path contains one or more path elements that select multiple sequence element indices (see <a href="memorylayout.pathelement#sequenceElement()"><code>MemoryLayout.PathElement.sequenceElement()</code></a> and <a href="memorylayout.pathelement#sequenceElement(long,long)"><code>MemoryLayout.PathElement.sequenceElement(long, long)</code></a>).</dd> <dd>
<code><a href="../../../../java.base/java/lang/unsupportedoperationexception" title="class in java.lang">UnsupportedOperationException</a></code> - if one of the layouts traversed by the layout path has unspecified size, or if <code>bitOffset(elements)</code> is not a multiple of 8.</dd> <dd>
<code><a href="../../../../java.base/java/lang/nullpointerexception" title="class in java.lang">NullPointerException</a></code> - if either <code>elements == null</code>, or if any of the elements in <code>elements</code> is <code>null</code>.</dd> </dl> </section><section class="detail" id="byteOffsetHandle(jdk.incubator.foreign.MemoryLayout.PathElement...)"> <h3>byteOffsetHandle</h3> <pre class="lang-java" data-language="java">default MethodHandle byteOffsetHandle(MemoryLayout.PathElement... elements)</pre> <div class="block">Creates a method handle that can be used to compute the offset, in bytes, of the layout selected by a given layout path, where the path is considered rooted in this layout. <p>The returned method handle has a return type of <code>long</code>, and features as many <code>long</code> parameter types as there are free dimensions in the provided layout path (see <a href="memorylayout.pathelement#sequenceElement()"><code>MemoryLayout.PathElement.sequenceElement()</code></a>, where the order of the parameters corresponds to the order of the path elements. The returned method handle can be used to compute a layout offset similar to <a href="#byteOffset(jdk.incubator.foreign.MemoryLayout.PathElement...)"><code>byteOffset(PathElement...)</code></a>, but where some sequence indices are specified only when invoking the method handle. </p>
<p>The final offset returned by the method handle is computed as follows: </p>
<blockquote><pre class="lang-java" data-language="java"><code>
    bitOffset = c_1 + c_2 + ... + c_m + (x_1 * s_1) + (x_2 * s_2) + ... + (x_n * s_n)
    offset = bitOffset / 8
 </code></pre></blockquote> where <code>x_1</code>, <code>x_2</code>, ... <code>x_n</code> are <em>dynamic</em> values provided as <code>long</code> arguments, whereas <code>c_1</code>, <code>c_2</code>, ... <code>c_m</code> are <em>static</em> offset constants and <code>s_0</code>, <code>s_1</code>, ... <code>s_n</code> are <em>static</em> stride constants which are derived from the layout path. <p>The method handle will throw an <a href="../../../../java.base/java/lang/unsupportedoperationexception" title="class in java.lang"><code>UnsupportedOperationException</code></a> if the computed offset in bits is not a multiple of 8.</p>
</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>elements</code> - the layout path elements.</dd> <dt>Returns:</dt> <dd>a method handle that can be used to compute the byte offset of the layout element specified by the given layout path elements, when supplied with the missing sequence element indices.</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.base/java/lang/illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if the layout path contains one or more path elements that select multiple sequence element indices (see <a href="memorylayout.pathelement#sequenceElement(long,long)"><code>MemoryLayout.PathElement.sequenceElement(long, long)</code></a>).</dd> <dd>
<code><a href="../../../../java.base/java/lang/unsupportedoperationexception" title="class in java.lang">UnsupportedOperationException</a></code> - if one of the layouts traversed by the layout path has unspecified size.</dd> </dl> </section><section class="detail" id="varHandle(java.lang.Class,jdk.incubator.foreign.MemoryLayout.PathElement...)"> <h3>varHandle</h3> <pre class="lang-java" data-language="java">default VarHandle varHandle(Class&lt;?&gt; carrier, MemoryLayout.PathElement... elements)</pre> <div class="block">Creates a memory access var handle that can be used to dereference memory at the layout selected by a given layout path, where the path is considered rooted in this layout. <p> The final memory location accessed by the returned memory access var handle can be computed as follows: </p>
<blockquote><pre class="lang-java" data-language="java"><code>
    address = base + offset
 </code></pre></blockquote> where <code>base</code> denotes the base address expressed by the <a href="memorysegment" title="interface in jdk.incubator.foreign"><code>MemorySegment</code></a> access coordinate (see <a href="memorysegment#address()"><code>MemorySegment.address()</code></a> and <a href="memoryaddress#toRawLongValue()"><code>MemoryAddress.toRawLongValue()</code></a>) and <code>offset</code> can be expressed in the following form: <blockquote><pre class="lang-java" data-language="java"><code>
    offset = c_1 + c_2 + ... + c_m + (x_1 * s_1) + (x_2 * s_2) + ... + (x_n * s_n)
 </code></pre></blockquote> where <code>x_1</code>, <code>x_2</code>, ... <code>x_n</code> are <em>dynamic</em> values provided as <code>long</code> arguments, whereas <code>c_1</code>, <code>c_2</code>, ... <code>c_m</code> are <em>static</em> offset constants and <code>s_0</code>, <code>s_1</code>, ... <code>s_n</code> are <em>static</em> stride constants which are derived from the layout path.</div> <dl class="notes"> <dt>API Note:</dt> <dd>the resulting var handle will feature an additional <code>long</code> access coordinate for every unspecified sequence access component contained in this layout path. Moreover, the resulting var handle features certain <a href="memoryhandles#memaccess-mode">access mode restrictions</a>, which are common to all memory access var handles.</dd> <dt>Parameters:</dt> <dd>
<code>carrier</code> - the var handle carrier type.</dd> <dd>
<code>elements</code> - the layout path elements.</dd> <dt>Returns:</dt> <dd>a var handle which can be used to dereference memory at the (possibly nested) layout selected by the layout path in <code>elements</code>.</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.base/java/lang/unsupportedoperationexception" title="class in java.lang">UnsupportedOperationException</a></code> - if the layout path has one or more elements with incompatible alignment constraints, or if one of the layouts traversed by the layout path has unspecified size.</dd> <dd>
<code><a href="../../../../java.base/java/lang/illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if the carrier does not represent a primitive type, if the carrier is <code>void</code>, <code>boolean</code>, or if the layout path in <code>elements</code> does not select a value layout (see <a href="valuelayout" title="class in jdk.incubator.foreign"><code>ValueLayout</code></a>), or if the selected value layout has a size that that does not match that of the specified carrier type.</dd> </dl> </section><section class="detail" id="sliceHandle(jdk.incubator.foreign.MemoryLayout.PathElement...)"> <h3>sliceHandle</h3> <pre class="lang-java" data-language="java">default MethodHandle sliceHandle(MemoryLayout.PathElement... elements)</pre> <div class="block">Creates a method handle which, given a memory segment, returns a <a href="memorysegment#asSlice(long,long)">slice</a> corresponding to the layout selected by a given layout path, where the path is considered rooted in this layout. <p>The returned method handle has a return type of <code>MemorySegment</code>, features a <code>MemorySegment</code> parameter as leading parameter representing the segment to be sliced, and features as many trailing <code>long</code> parameter types as there are free dimensions in the provided layout path (see <a href="memorylayout.pathelement#sequenceElement()"><code>MemoryLayout.PathElement.sequenceElement()</code></a>, where the order of the parameters corresponds to the order of the path elements. The returned method handle can be used to create a slice similar to using <a href="memorysegment#asSlice(long,long)"><code>MemorySegment.asSlice(long, long)</code></a>, but where the offset argument is dynamically compute based on indices specified when invoking the method handle. </p>
<p>The offset of the returned segment is computed as follows: </p>
<blockquote><pre class="lang-java" data-language="java"><code>
    bitOffset = c_1 + c_2 + ... + c_m + (x_1 * s_1) + (x_2 * s_2) + ... + (x_n * s_n)
    offset = bitOffset / 8
 </code></pre></blockquote> where <code>x_1</code>, <code>x_2</code>, ... <code>x_n</code> are <em>dynamic</em> values provided as <code>long</code> arguments, whereas <code>c_1</code>, <code>c_2</code>, ... <code>c_m</code> are <em>static</em> offset constants and <code>s_0</code>, <code>s_1</code>, ... <code>s_n</code> are <em>static</em> stride constants which are derived from the layout path. <p>After the offset is computed, the returned segment is create as if by calling: </p>
<blockquote><pre class="lang-java" data-language="java"><code>
    segment.asSlice(offset, layout.byteSize());
 </code></pre></blockquote> where <code>segment</code> is the segment to be sliced, and where <code>layout</code> is the layout selected by the given layout path, as per <a href="#select(jdk.incubator.foreign.MemoryLayout.PathElement...)"><code>select(PathElement...)</code></a>. <p>The method handle will throw an <a href="../../../../java.base/java/lang/unsupportedoperationexception" title="class in java.lang"><code>UnsupportedOperationException</code></a> if the computed offset in bits is not a multiple of 8.</p>
</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>elements</code> - the layout path elements.</dd> <dt>Returns:</dt> <dd>a method handle which can be used to create a slice of the selected layout element, given a segment.</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.base/java/lang/unsupportedoperationexception" title="class in java.lang">UnsupportedOperationException</a></code> - if the size of the selected layout in bits is not a multiple of 8.</dd> </dl> </section><section class="detail" id="select(jdk.incubator.foreign.MemoryLayout.PathElement...)"> <h3>select</h3> <pre class="lang-java" data-language="java">default MemoryLayout select(MemoryLayout.PathElement... elements)</pre> <div class="block">Selects the layout from a path rooted in this layout.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>elements</code> - the layout path elements.</dd> <dt>Returns:</dt> <dd>the layout selected by the layout path in <code>elements</code>.</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.base/java/lang/illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if the layout path does not select any layout nested in this layout, or if the layout path contains one or more path elements that select one or more sequence element indices (see <a href="memorylayout.pathelement#sequenceElement(long)"><code>MemoryLayout.PathElement.sequenceElement(long)</code></a> and <a href="memorylayout.pathelement#sequenceElement(long,long)"><code>MemoryLayout.PathElement.sequenceElement(long, long)</code></a>).</dd> </dl> </section><section class="detail" id="map(java.util.function.UnaryOperator,jdk.incubator.foreign.MemoryLayout.PathElement...)"> <h3>map</h3> <pre class="lang-java" data-language="java">default MemoryLayout map(UnaryOperator&lt;MemoryLayout&gt; op, MemoryLayout.PathElement... elements)</pre> <div class="block">Creates a transformed copy of this layout where a selected layout, from a path rooted in this layout, is replaced with the result of applying the given operation.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>op</code> - the unary operation to be applied to the selected layout.</dd> <dd>
<code>elements</code> - the layout path elements.</dd> <dt>Returns:</dt> <dd>a new layout where the layout selected by the layout path in <code>elements</code>, has been replaced by the result of applying <code>op</code> to the selected layout.</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.base/java/lang/illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if the layout path does not select any layout nested in this layout, or if the layout path contains one or more path elements that select one or more sequence element indices (see <a href="memorylayout.pathelement#sequenceElement(long)"><code>MemoryLayout.PathElement.sequenceElement(long)</code></a> and <a href="memorylayout.pathelement#sequenceElement(long,long)"><code>MemoryLayout.PathElement.sequenceElement(long, long)</code></a>).</dd> </dl> </section><section class="detail" id="isPadding()"> <h3>isPadding</h3> <pre class="lang-java" data-language="java">boolean isPadding()</pre> <div class="block">Is this a padding layout (e.g. a layout created from <a href="#paddingLayout(long)"><code>paddingLayout(long)</code></a>) ?</div> <dl class="notes"> <dt>Returns:</dt> <dd>true, if this layout is a padding layout.</dd> </dl> </section><section class="detail" id="equals(java.lang.Object)"> <h3>equals</h3> <pre class="lang-java" data-language="java">boolean equals(Object that)</pre> <div class="block">Compares the specified object with this layout for equality. Returns <code>true</code> if and only if the specified object is also a layout, and it is equal to this layout. Two layouts are considered equal if they are of the same kind, have the same size, name and alignment constraints. Furthermore, depending on the layout kind, additional conditions must be satisfied: <ul> <li>two value layouts are considered equal if they have the same byte order (see <a href="valuelayout#order()"><code>ValueLayout.order()</code></a>)</li> <li>two sequence layouts are considered equal if they have the same element count (see <a href="sequencelayout#elementCount()"><code>SequenceLayout.elementCount()</code></a>), and if their element layouts (see <a href="sequencelayout#elementLayout()"><code>SequenceLayout.elementLayout()</code></a>) are also equal</li> <li>two group layouts are considered equal if they are of the same kind (see <a href="grouplayout#isStruct()"><code>GroupLayout.isStruct()</code></a>, <a href="grouplayout#isUnion()"><code>GroupLayout.isUnion()</code></a>) and if their member layouts (see <a href="grouplayout#memberLayouts()"><code>GroupLayout.memberLayouts()</code></a>) are also equal</li> </ul>
</div> <dl class="notes"> <dt>Overrides:</dt> <dd>
<code><a href="../../../../java.base/java/lang/object#equals(java.lang.Object)">equals</a></code> in class <code><a href="../../../../java.base/java/lang/object" title="class in java.lang">Object</a></code>
</dd> <dt>Parameters:</dt> <dd>
<code>that</code> - the object to be compared for equality with this layout.</dd> <dt>Returns:</dt> <dd>
<code>true</code> if the specified object is equal to this layout.</dd> <dt>See Also:</dt> <dd> <ul class="see-list"> <li><a href="../../../../java.base/java/lang/object#hashCode()"><code>Object.hashCode()</code></a></li> <li><a href="../../../../java.base/java/util/hashmap" title="class in java.util"><code>HashMap</code></a></li> </ul> </dd> </dl> </section><section class="detail" id="hashCode()"> <h3>hashCode</h3> <pre class="lang-java" data-language="java">int hashCode()</pre> <div class="block">Returns the hash code value for this layout.</div> <dl class="notes"> <dt>Overrides:</dt> <dd>
<code><a href="../../../../java.base/java/lang/object#hashCode()">hashCode</a></code> in class <code><a href="../../../../java.base/java/lang/object" title="class in java.lang">Object</a></code>
</dd> <dt>Returns:</dt> <dd>the hash code value for this layout.</dd> <dt>See Also:</dt> <dd> <ul class="see-list-long"> <li><a href="../../../../java.base/java/lang/object#equals(java.lang.Object)"><code>Object.equals(java.lang.Object)</code></a></li> <li><a href="../../../../java.base/java/lang/system#identityHashCode(java.lang.Object)"><code>System.identityHashCode(java.lang.Object)</code></a></li> </ul> </dd> </dl> </section><section class="detail" id="toString()"> <h3>toString</h3> <pre class="lang-java" data-language="java">String toString()</pre> <div class="block">Returns a string representation of this layout.</div> <dl class="notes"> <dt>Overrides:</dt> <dd>
<code><a href="../../../../java.base/java/lang/object#toString()">toString</a></code> in class <code><a href="../../../../java.base/java/lang/object" title="class in java.lang">Object</a></code>
</dd> <dt>Returns:</dt> <dd>a string representation of this layout.</dd> </dl> </section><section class="detail" id="paddingLayout(long)"> <h3>paddingLayout</h3> <pre class="lang-java" data-language="java">static MemoryLayout paddingLayout(long size)</pre> <div class="block">Create a new padding layout with given size.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>size</code> - the padding size in bits.</dd> <dt>Returns:</dt> <dd>the new selector layout.</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.base/java/lang/illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if <code>size &lt;= 0</code>.</dd> </dl> </section><section class="detail" id="valueLayout(long,java.nio.ByteOrder)"> <h3>valueLayout</h3> <pre class="lang-java" data-language="java">static ValueLayout valueLayout(long size, ByteOrder order)</pre> <div class="block">Create a value layout of given byte order and size.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>size</code> - the value layout size.</dd> <dd>
<code>order</code> - the value layout's byte order.</dd> <dt>Returns:</dt> <dd>a new value layout.</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.base/java/lang/illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if <code>size &lt;= 0</code>.</dd> </dl> </section><section class="detail" id="sequenceLayout(long,jdk.incubator.foreign.MemoryLayout)"> <h3>sequenceLayout</h3> <pre class="lang-java" data-language="java">static SequenceLayout sequenceLayout(long elementCount, MemoryLayout elementLayout)</pre> <div class="block">Create a new sequence layout with given element layout and element count.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>elementCount</code> - the sequence element count.</dd> <dd>
<code>elementLayout</code> - the sequence element layout.</dd> <dt>Returns:</dt> <dd>the new sequence layout with given element layout and size.</dd> <dt>Throws:</dt> <dd>
<code><a href="../../../../java.base/java/lang/illegalargumentexception" title="class in java.lang">IllegalArgumentException</a></code> - if <code>elementCount &lt; 0</code>.</dd> </dl> </section><section class="detail" id="sequenceLayout(jdk.incubator.foreign.MemoryLayout)"> <h3>sequenceLayout</h3> <pre class="lang-java" data-language="java">static SequenceLayout sequenceLayout(MemoryLayout elementLayout)</pre> <div class="block">Create a new sequence layout, with unbounded element count and given element layout.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>elementLayout</code> - the element layout of the sequence layout.</dd> <dt>Returns:</dt> <dd>the new sequence layout with given element layout.</dd> </dl> </section><section class="detail" id="structLayout(jdk.incubator.foreign.MemoryLayout...)"> <h3>structLayout</h3> <pre class="lang-java" data-language="java">static GroupLayout structLayout(MemoryLayout... elements)</pre> <div class="block">Create a new <em>struct</em> group layout with given member layouts.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>elements</code> - The member layouts of the <em>struct</em> group layout.</dd> <dt>Returns:</dt> <dd>a new <em>struct</em> group layout with given member layouts.</dd> </dl> </section><section class="detail" id="unionLayout(jdk.incubator.foreign.MemoryLayout...)"> <h3>unionLayout</h3> <pre class="lang-java" data-language="java">static GroupLayout unionLayout(MemoryLayout... elements)</pre> <div class="block">Create a new <em>union</em> group layout with given member layouts.</div> <dl class="notes"> <dt>Parameters:</dt> <dd>
<code>elements</code> - The member layouts of the <em>union</em> layout.</dd> <dt>Returns:</dt> <dd>a new <em>union</em> group layout with given member layouts.</dd> </dl> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1993, 2021, Oracle and/or its affiliates. All rights reserved.<br>Documentation extracted from Debian's OpenJDK Development Kit package.<br>Licensed under the GNU General Public License, version 2, with the Classpath Exception.<br>Various third party code in OpenJDK is licensed under different licenses (see Debian package).<br>Java and OpenJDK are trademarks or registered trademarks of Oracle and/or its affiliates.<br>
    <a href="https://docs.oracle.com/en/java/javase/17/docs/api/jdk.incubator.foreign/jdk/incubator/foreign/MemoryLayout.html" class="_attribution-link">https://docs.oracle.com/en/java/javase/17/docs/api/jdk.incubator.foreign/jdk/incubator/foreign/MemoryLayout.html</a>
  </p>
</div>
