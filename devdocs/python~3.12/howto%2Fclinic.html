<h1 id="howto-clinic">Argument Clinic How-To</h1> <dl class="field-list simple"> <dt class="field-odd">author</dt> <dd class="field-odd">
<p>Larry Hastings</p> </dd> </dl> <p><strong>Source code:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.12/Tools/clinic/clinic.py">Tools/clinic/clinic.py</a>.</p> <div class="topic"> <p class="topic-title">Abstract</p> <p>Argument Clinic is a preprocessor for CPython C files. It was introduced in Python 3.4 with <a class="pep reference external" href="https://peps.python.org/pep-0436/" id="index-0"><strong>PEP 436</strong></a>, in order to provide introspection signatures, and to generate performant and tailor-made boilerplate code for argument parsing in CPython builtins, module level functions, and class methods. This document is divided in four major sections:</p> <ul class="simple"> <li>
<a class="reference internal" href="#clinic-background"><span class="std std-ref">Background</span></a> talks about the basic concepts and goals of Argument Clinic.</li> <li>
<a class="reference internal" href="#clinic-reference"><span class="std std-ref">Reference</span></a> describes the command-line interface and Argument Clinic terminology.</li> <li>
<a class="reference internal" href="#clinic-tutorial"><span class="std std-ref">Tutorial</span></a> guides you through all the steps required to adapt an existing C function to Argument Clinic.</li> <li>
<a class="reference internal" href="#clinic-howtos"><span class="std std-ref">How-to guides</span></a> details how to handle specific tasks.</li> </ul> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Argument Clinic is considered internal-only for CPython. Its use is not supported for files outside CPython, and no guarantees are made regarding backwards compatibility for future versions. In other words: if you maintain an external C extension for CPython, you’re welcome to experiment with Argument Clinic in your own code. But the version of Argument Clinic that ships with the next version of CPython <em>could</em> be totally incompatible and break all your code.</p> </div> <section id="background"> <h2 id="clinic-background">Background</h2> <section id="basic-concepts"> <h3>Basic concepts</h3> <p>When Argument Clinic is run on a file, either via the <a class="reference internal" href="#clinic-cli"><span class="std std-ref">Command-line interface</span></a> or via <code>make clinic</code>, it will scan over the input files looking for <a class="reference internal" href="#term-start-line"><span class="xref std std-term">start lines</span></a>:</p> <pre data-language="none">/*[clinic input]
</pre> <p>When it finds one, it reads everything up to the <a class="reference internal" href="#term-end-line"><span class="xref std std-term">end line</span></a>:</p> <pre data-language="none">[clinic start generated code]*/
</pre> <p>Everything in between these two lines is Argument Clinic <a class="reference internal" href="#term-input"><span class="xref std std-term">input</span></a>. When Argument Clinic parses input, it generates <a class="reference internal" href="#term-output"><span class="xref std std-term">output</span></a>. The output is rewritten into the C file immediately after the input, followed by a <a class="reference internal" href="#term-checksum-line"><span class="xref std std-term">checksum line</span></a>. All of these lines, including the <a class="reference internal" href="#term-start-line"><span class="xref std std-term">start line</span></a> and <a class="reference internal" href="#term-checksum-line"><span class="xref std std-term">checksum line</span></a>, are collectively called an Argument Clinic <a class="reference internal" href="#term-block"><span class="xref std std-term">block</span></a>:</p> <pre data-language="none">/*[clinic input]
... clinic input goes here ...
[clinic start generated code]*/
... clinic output goes here ...
/*[clinic end generated code: ...]*/
</pre> <p>If you run Argument Clinic on the same file a second time, Argument Clinic will discard the old <a class="reference internal" href="#term-output"><span class="xref std std-term">output</span></a> and write out the new output with a fresh <a class="reference internal" href="#term-checksum-line"><span class="xref std std-term">checksum line</span></a>. If the <a class="reference internal" href="#term-input"><span class="xref std std-term">input</span></a> hasn’t changed, the output won’t change either.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>You should never modify the output of an Argument Clinic block, as any change will be lost in future Argument Clinic runs; Argument Clinic will detect an output checksum mismatch and regenerate the correct output. If you are not happy with the generated output, you should instead change the input until it produces the output you want.</p> </div> </section> </section> <section id="reference"> <h2 id="clinic-reference">Reference</h2> <section id="terminology"> <h3 id="clinic-terminology">Terminology</h3> <dl class="glossary simple"> <dt id="term-start-line">
<code>start line</code> </dt>
<dd>
<p>The line <code>/*[clinic input]</code>. This line marks the beginning of Argument Clinic input. Note that the <em>start line</em> opens a C block comment.</p> </dd> <dt id="term-end-line">
<code>end line</code> </dt>
<dd>
<p>The line <code>[clinic start generated code]*/</code>. The <em>end line</em> marks the _end_ of Argument Clinic <a class="reference internal" href="#term-input"><span class="xref std std-term">input</span></a>, but at the same time marks the _start_ of Argument Clinic <a class="reference internal" href="#term-output"><span class="xref std std-term">output</span></a>, thus the text <em>“clinic start start generated code”</em> Note that the <em>end line</em> closes the C block comment opened by the <em>start line</em>.</p> </dd> <dt id="term-checksum">
<code>checksum</code> </dt>
<dd>
<p>A hash to distinguish unique <a class="reference internal" href="#term-input"><span class="xref std std-term">inputs</span></a> and <a class="reference internal" href="#term-output"><span class="xref std std-term">outputs</span></a>.</p> </dd> <dt id="term-checksum-line">
<code>checksum line</code> </dt>
<dd>
<p>A line that looks like <code>/*[clinic end generated code: ...]*/</code>. The three dots will be replaced by a <a class="reference internal" href="#term-checksum"><span class="xref std std-term">checksum</span></a> generated from the <a class="reference internal" href="#term-input"><span class="xref std std-term">input</span></a>, and a <a class="reference internal" href="#term-checksum"><span class="xref std std-term">checksum</span></a> generated from the <a class="reference internal" href="#term-output"><span class="xref std std-term">output</span></a>. The checksum line marks the end of Argument Clinic generated code, and is used by Argument Clinic to determine if it needs to regenerate output.</p> </dd> <dt id="term-input">
<code>input</code> </dt>
<dd>
<p>The text between the <a class="reference internal" href="#term-start-line"><span class="xref std std-term">start line</span></a> and the <a class="reference internal" href="#term-end-line"><span class="xref std std-term">end line</span></a>. Note that the start and end lines open and close a C block comment; the <em>input</em> is thus a part of that same C block comment.</p> </dd> <dt id="term-output">
<code>output</code> </dt>
<dd>
<p>The text between the <a class="reference internal" href="#term-end-line"><span class="xref std std-term">end line</span></a> and the <a class="reference internal" href="#term-checksum-line"><span class="xref std std-term">checksum line</span></a>.</p> </dd> <dt id="term-block">
<code>block</code> </dt>
<dd>
<p>All text from the <a class="reference internal" href="#term-start-line"><span class="xref std std-term">start line</span></a> to the <a class="reference internal" href="#term-checksum-line"><span class="xref std std-term">checksum line</span></a> inclusively.</p> </dd> </dl> </section> <section id="command-line-interface"> <h3 id="clinic-cli">Command-line interface</h3> <p>The Argument Clinic <abbr title="Command-Line Interface">CLI</abbr> is typically used to process a single source file, like this:</p> <pre data-language="shell">$ python3 ./Tools/clinic/clinic.py foo.c
</pre> <p>The CLI supports the following options:</p> <dl class="std option"> <dt class="sig sig-object std" id="cmdoption-.-Tools-clinic-clinic.py-h-f-o-OUTPUT-v-converters-make-srcdir-SRCDIR-FILE-...-h">
<code>-h, --help</code> </dt> <dd>
<p>Print CLI usage.</p> </dd>
</dl> <dl class="std option"> <dt class="sig sig-object std" id="cmdoption-.-Tools-clinic-clinic.py-h-f-o-OUTPUT-v-converters-make-srcdir-SRCDIR-FILE-...-f">
<code>-f, --force</code> </dt> <dd>
<p>Force output regeneration.</p> </dd>
</dl> <dl class="std option"> <dt class="sig sig-object std" id="cmdoption-.-Tools-clinic-clinic.py-h-f-o-OUTPUT-v-converters-make-srcdir-SRCDIR-FILE-...-o">
<code>-o, --output OUTPUT</code> </dt> <dd>
<p>Redirect file output to OUTPUT</p> </dd>
</dl> <dl class="std option"> <dt class="sig sig-object std" id="cmdoption-.-Tools-clinic-clinic.py-h-f-o-OUTPUT-v-converters-make-srcdir-SRCDIR-FILE-...-v">
<code>-v, --verbose</code> </dt> <dd>
<p>Enable verbose mode.</p> </dd>
</dl> <dl class="std option"> <dt class="sig sig-object std" id="cmdoption-.-Tools-clinic-clinic.py-h-f-o-OUTPUT-v-converters-make-srcdir-SRCDIR-FILE-...-converters">
<code>--converters</code> </dt> <dd>
<p>Print a list of all supported converters and return converters.</p> </dd>
</dl> <dl class="std option"> <dt class="sig sig-object std" id="cmdoption-.-Tools-clinic-clinic.py-h-f-o-OUTPUT-v-converters-make-srcdir-SRCDIR-FILE-...-make">
<code>--make</code> </dt> <dd>
<p>Walk <a class="reference internal" href="#cmdoption-.-Tools-clinic-clinic.py-h-f-o-OUTPUT-v-converters-make-srcdir-SRCDIR-FILE-...-srcdir"><code>--srcdir</code></a> to run over all relevant files.</p> </dd>
</dl> <dl class="std option"> <dt class="sig sig-object std" id="cmdoption-.-Tools-clinic-clinic.py-h-f-o-OUTPUT-v-converters-make-srcdir-SRCDIR-FILE-...-srcdir">
<code>--srcdir SRCDIR</code> </dt> <dd>
<p>The directory tree to walk in <a class="reference internal" href="#cmdoption-.-Tools-clinic-clinic.py-h-f-o-OUTPUT-v-converters-make-srcdir-SRCDIR-FILE-...-make"><code>--make</code></a> mode.</p> </dd>
</dl> <dl class="std option"> <dt class="sig sig-object std" id="cmdoption-.-Tools-clinic-clinic.py-h-f-o-OUTPUT-v-converters-make-srcdir-SRCDIR-FILE-...-arg-FILE">
<code>FILE ...</code> </dt> <dd>
<p>The list of files to process.</p> </dd>
</dl> </section> <section id="module-clinic"> <h3 id="clinic-classes">Classes for extending Argument Clinic</h3> <dl class="py class"> <dt class="sig sig-object py" id="clinic.CConverter">
<code>class clinic.CConverter</code> </dt> <dd>
<p>The base class for all converters. See <a class="reference internal" href="#clinic-howto-custom-converter"><span class="std std-ref">How to write a custom converter</span></a> for how to subclass this class.</p> <dl class="py attribute"> <dt class="sig sig-object py" id="clinic.CConverter.type">
<code>type</code> </dt> <dd>
<p>The C type to use for this variable. <code>type</code> should be a Python string specifying the type, e.g. <code>'int'</code>. If this is a pointer type, the type string should end with <code>' *'</code>.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="clinic.CConverter.default">
<code>default</code> </dt> <dd>
<p>The Python default value for this parameter, as a Python value. Or the magic value <code>unspecified</code> if there is no default.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="clinic.CConverter.py_default">
<code>py_default</code> </dt> <dd>
<p><code>default</code> as it should appear in Python code, as a string. Or <code>None</code> if there is no default.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="clinic.CConverter.c_default">
<code>c_default</code> </dt> <dd>
<p><code>default</code> as it should appear in C code, as a string. Or <code>None</code> if there is no default.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="clinic.CConverter.c_ignored_default">
<code>c_ignored_default</code> </dt> <dd>
<p>The default value used to initialize the C variable when there is no default, but not specifying a default may result in an “uninitialized variable” warning. This can easily happen when using option groups—although properly written code will never actually use this value, the variable does get passed in to the impl, and the C compiler will complain about the “use” of the uninitialized value. This value should always be a non-empty string.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="clinic.CConverter.converter">
<code>converter</code> </dt> <dd>
<p>The name of the C converter function, as a string.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="clinic.CConverter.impl_by_reference">
<code>impl_by_reference</code> </dt> <dd>
<p>A boolean value. If true, Argument Clinic will add a <code>&amp;</code> in front of the name of the variable when passing it into the impl function.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="clinic.CConverter.parse_by_reference">
<code>parse_by_reference</code> </dt> <dd>
<p>A boolean value. If true, Argument Clinic will add a <code>&amp;</code> in front of the name of the variable when passing it into <a class="reference internal" href="../c-api/arg#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code>PyArg_ParseTuple()</code></a>.</p> </dd>
</dl> </dd>
</dl> </section> </section> <section id="tutorial"> <h2 id="clinic-tutorial">Tutorial</h2> <p>The best way to get a sense of how Argument Clinic works is to convert a function to work with it. Here, then, are the bare minimum steps you’d need to follow to convert a function to work with Argument Clinic. Note that for code you plan to check in to CPython, you really should take the conversion farther, using some of the <a class="reference internal" href="#clinic-howtos"><span class="std std-ref">advanced concepts</span></a> you’ll see later on in the document, like <a class="reference internal" href="#clinic-howto-return-converters"><span class="std std-ref">How to use return converters</span></a> and <a class="reference internal" href="#clinic-howto-self-converter"><span class="std std-ref">How to use the “self converter”</span></a>. But we’ll keep it simple for this walkthrough so you can learn.</p> <p>First, make sure you’re working with a freshly updated checkout of the CPython trunk.</p> <p>Next, find a Python builtin that calls either <a class="reference internal" href="../c-api/arg#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code>PyArg_ParseTuple()</code></a> or <a class="reference internal" href="../c-api/arg#c.PyArg_ParseTupleAndKeywords" title="PyArg_ParseTupleAndKeywords"><code>PyArg_ParseTupleAndKeywords()</code></a>, and hasn’t been converted to work with Argument Clinic yet. For this tutorial, we’ll be using <a class="reference internal" href="../library/pickle#pickle.Pickler.dump" title="pickle.Pickler.dump"><code>_pickle.Pickler.dump</code></a>.</p> <p>If the call to the <code>PyArg_Parse*()</code> function uses any of the following format units…:</p>  <pre data-language="none">O&amp;
O!
es
es#
et
et#
</pre>  <p>… or if it has multiple calls to <a class="reference internal" href="../c-api/arg#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code>PyArg_ParseTuple()</code></a>, you should choose a different function. (See <a class="reference internal" href="#clinic-howto-advanced-converters"><span class="std std-ref">How to use advanced converters</span></a> for those scenarios.)</p> <p>Also, if the function has multiple calls to <code>PyArg_ParseTuple()</code> or <a class="reference internal" href="../c-api/arg#c.PyArg_ParseTupleAndKeywords" title="PyArg_ParseTupleAndKeywords"><code>PyArg_ParseTupleAndKeywords()</code></a> where it supports different types for the same argument, or if the function uses something besides <code>PyArg_Parse*()</code> functions to parse its arguments, it probably isn’t suitable for conversion to Argument Clinic. Argument Clinic doesn’t support generic functions or polymorphic parameters.</p> <p>Next, add the following boilerplate above the function, creating our input block:</p> <pre data-language="c">/*[clinic input]
[clinic start generated code]*/
</pre> <p>Cut the docstring and paste it in between the <code>[clinic]</code> lines, removing all the junk that makes it a properly quoted C string. When you’re done you should have just the text, based at the left margin, with no line wider than 80 characters. Argument Clinic will preserve indents inside the docstring.</p> <p>If the old docstring had a first line that looked like a function signature, throw that line away; The docstring doesn’t need it anymore — when you use <a class="reference internal" href="../library/functions#help" title="help"><code>help()</code></a> on your builtin in the future, the first line will be built automatically based on the function’s signature.</p> <p>Example docstring summary line:</p> <pre data-language="c">/*[clinic input]
Write a pickled representation of obj to the open file.
[clinic start generated code]*/
</pre> <p>If your docstring doesn’t have a “summary” line, Argument Clinic will complain, so let’s make sure it has one. The “summary” line should be a paragraph consisting of a single 80-column line at the beginning of the docstring. (See <a class="pep reference external" href="https://peps.python.org/pep-0257/" id="index-1"><strong>PEP 257</strong></a> regarding docstring conventions.)</p> <p>Our example docstring consists solely of a summary line, so the sample code doesn’t have to change for this step.</p> <p>Now, above the docstring, enter the name of the function, followed by a blank line. This should be the Python name of the function, and should be the full dotted path to the function — it should start with the name of the module, include any sub-modules, and if the function is a method on a class it should include the class name too.</p> <p>In our example, <code>_pickle</code> is the module, <code>Pickler</code> is the class, and <code>dump()</code> is the method, so the name becomes <code>_pickle.Pickler.dump()</code>:</p> <pre data-language="c">/*[clinic input]
_pickle.Pickler.dump

Write a pickled representation of obj to the open file.
[clinic start generated code]*/
</pre> <p>If this is the first time that module or class has been used with Argument Clinic in this C file, you must declare the module and/or class. Proper Argument Clinic hygiene prefers declaring these in a separate block somewhere near the top of the C file, in the same way that include files and statics go at the top. In our sample code we’ll just show the two blocks next to each other.</p> <p>The name of the class and module should be the same as the one seen by Python. Check the name defined in the <a class="reference internal" href="../c-api/module#c.PyModuleDef" title="PyModuleDef"><code>PyModuleDef</code></a> or <a class="reference internal" href="../c-api/type#c.PyTypeObject" title="PyTypeObject"><code>PyTypeObject</code></a> as appropriate.</p> <p>When you declare a class, you must also specify two aspects of its type in C: the type declaration you’d use for a pointer to an instance of this class, and a pointer to the <code>PyTypeObject</code> for this class:</p> <pre data-language="c">/*[clinic input]
module _pickle
class _pickle.Pickler "PicklerObject *" "&amp;Pickler_Type"
[clinic start generated code]*/

/*[clinic input]
_pickle.Pickler.dump

Write a pickled representation of obj to the open file.
[clinic start generated code]*/
</pre> <p>Declare each of the parameters to the function. Each parameter should get its own line. All the parameter lines should be indented from the function name and the docstring. The general form of these parameter lines is as follows:</p> <pre data-language="none">name_of_parameter: converter
</pre> <p>If the parameter has a default value, add that after the converter:</p> <pre data-language="none">name_of_parameter: converter = default_value
</pre> <p>Argument Clinic’s support for “default values” is quite sophisticated; see <a class="reference internal" href="#clinic-howto-default-values"><span class="std std-ref">How to assign default values to parameter</span></a> for more information.</p> <p>Next, add a blank line below the parameters.</p> <p>What’s a “converter”? It establishes both the type of the variable used in C, and the method to convert the Python value into a C value at runtime. For now you’re going to use what’s called a “legacy converter” — a convenience syntax intended to make porting old code into Argument Clinic easier.</p> <p>For each parameter, copy the “format unit” for that parameter from the <a class="reference internal" href="../c-api/arg#c.PyArg_Parse" title="PyArg_Parse"><code>PyArg_Parse()</code></a> format argument and specify <em>that</em> as its converter, as a quoted string. The “format unit” is the formal name for the one-to-three character substring of the <em>format</em> parameter that tells the argument parsing function what the type of the variable is and how to convert it. For more on format units please see <a class="reference internal" href="../c-api/arg#arg-parsing"><span class="std std-ref">Parsing arguments and building values</span></a>.</p> <p>For multicharacter format units like <code>z#</code>, use the entire two-or-three character string.</p> <p>Sample:</p> <pre data-language="c">/*[clinic input]
module _pickle
class _pickle.Pickler "PicklerObject *" "&amp;Pickler_Type"
[clinic start generated code]*/

/*[clinic input]
_pickle.Pickler.dump

    obj: 'O'

Write a pickled representation of obj to the open file.
[clinic start generated code]*/
</pre> <p>If your function has <code>|</code> in the format string, meaning some parameters have default values, you can ignore it. Argument Clinic infers which parameters are optional based on whether or not they have default values.</p> <p>If your function has <code>$</code> in the format string, meaning it takes keyword-only arguments, specify <code>*</code> on a line by itself before the first keyword-only argument, indented the same as the parameter lines.</p> <p><code>_pickle.Pickler.dump()</code> has neither, so our sample is unchanged.</p> <p>Next, if the existing C function calls <a class="reference internal" href="../c-api/arg#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code>PyArg_ParseTuple()</code></a> (as opposed to <a class="reference internal" href="../c-api/arg#c.PyArg_ParseTupleAndKeywords" title="PyArg_ParseTupleAndKeywords"><code>PyArg_ParseTupleAndKeywords()</code></a>), then all its arguments are positional-only.</p> <p>To mark parameters as positional-only in Argument Clinic, add a <code>/</code> on a line by itself after the last positional-only parameter, indented the same as the parameter lines.</p> <p>Sample:</p> <pre data-language="c">/*[clinic input]
module _pickle
class _pickle.Pickler "PicklerObject *" "&amp;Pickler_Type"
[clinic start generated code]*/

/*[clinic input]
_pickle.Pickler.dump

    obj: 'O'
    /

Write a pickled representation of obj to the open file.
[clinic start generated code]*/
</pre> <p>It can be helpful to write a per-parameter docstring for each parameter. Since per-parameter docstrings are optional, you can skip this step if you prefer.</p> <p>Nevertheless, here’s how to add a per-parameter docstring. The first line of the per-parameter docstring must be indented further than the parameter definition. The left margin of this first line establishes the left margin for the whole per-parameter docstring; all the text you write will be outdented by this amount. You can write as much text as you like, across multiple lines if you wish.</p> <p>Sample:</p> <pre data-language="c">/*[clinic input]
module _pickle
class _pickle.Pickler "PicklerObject *" "&amp;Pickler_Type"
[clinic start generated code]*/

/*[clinic input]
_pickle.Pickler.dump

    obj: 'O'
        The object to be pickled.
    /

Write a pickled representation of obj to the open file.
[clinic start generated code]*/
</pre> <p>Save and close the file, then run <code>Tools/clinic/clinic.py</code> on it. With luck everything worked—your block now has output, and a <code>.c.h</code> file has been generated! Reload the file in your text editor to see the generated code:</p> <pre data-language="c">/*[clinic input]
_pickle.Pickler.dump

    obj: 'O'
        The object to be pickled.
    /

Write a pickled representation of obj to the open file.
[clinic start generated code]*/

static PyObject *
_pickle_Pickler_dump(PicklerObject *self, PyObject *obj)
/*[clinic end generated code: output=87ecad1261e02ac7 input=552eb1c0f52260d9]*/
</pre> <p>Obviously, if Argument Clinic didn’t produce any output, it’s because it found an error in your input. Keep fixing your errors and retrying until Argument Clinic processes your file without complaint.</p> <p>For readability, most of the glue code has been generated to a <code>.c.h</code> file. You’ll need to include that in your original <code>.c</code> file, typically right after the clinic module block:</p> <pre data-language="c">#include "clinic/_pickle.c.h"
</pre> <p>Double-check that the argument-parsing code Argument Clinic generated looks basically the same as the existing code.</p> <p>First, ensure both places use the same argument-parsing function. The existing code must call either <a class="reference internal" href="../c-api/arg#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code>PyArg_ParseTuple()</code></a> or <a class="reference internal" href="../c-api/arg#c.PyArg_ParseTupleAndKeywords" title="PyArg_ParseTupleAndKeywords"><code>PyArg_ParseTupleAndKeywords()</code></a>; ensure that the code generated by Argument Clinic calls the <em>exact</em> same function.</p> <p>Second, the format string passed in to <code>PyArg_ParseTuple()</code> or <code>PyArg_ParseTupleAndKeywords()</code> should be <em>exactly</em> the same as the hand-written one in the existing function, up to the colon or semi-colon.</p> <p>Argument Clinic always generates its format strings with a <code>:</code> followed by the name of the function. If the existing code’s format string ends with <code>;</code>, to provide usage help, this change is harmless — don’t worry about it.</p> <p>Third, for parameters whose format units require two arguments, like a length variable, an encoding string, or a pointer to a conversion function, ensure that the second argument is <em>exactly</em> the same between the two invocations.</p> <p>Fourth, inside the output portion of the block, you’ll find a preprocessor macro defining the appropriate static <a class="reference internal" href="../c-api/structures#c.PyMethodDef" title="PyMethodDef"><code>PyMethodDef</code></a> structure for this builtin:</p> <pre data-language="c">#define __PICKLE_PICKLER_DUMP_METHODDEF    \
{"dump", (PyCFunction)__pickle_Pickler_dump, METH_O, __pickle_Pickler_dump__doc__},
</pre> <p>This static structure should be <em>exactly</em> the same as the existing static <code>PyMethodDef</code> structure for this builtin.</p> <p>If any of these items differ in <em>any way</em>, adjust your Argument Clinic function specification and rerun <code>Tools/clinic/clinic.py</code> until they <em>are</em> the same.</p> <p>Notice that the last line of its output is the declaration of your “impl” function. This is where the builtin’s implementation goes. Delete the existing prototype of the function you’re modifying, but leave the opening curly brace. Now delete its argument parsing code and the declarations of all the variables it dumps the arguments into. Notice how the Python arguments are now arguments to this impl function; if the implementation used different names for these variables, fix it.</p> <p>Let’s reiterate, just because it’s kind of weird. Your code should now look like this:</p> <pre data-language="c">static return_type
your_function_impl(...)
/*[clinic end generated code: input=..., output=...]*/
{
...
</pre> <p>Argument Clinic generated the checksum line and the function prototype just above it. You should write the opening and closing curly braces for the function, and the implementation inside.</p> <p>Sample:</p> <pre data-language="c">/*[clinic input]
module _pickle
class _pickle.Pickler "PicklerObject *" "&amp;Pickler_Type"
[clinic start generated code]*/
/*[clinic end generated code: checksum=da39a3ee5e6b4b0d3255bfef95601890afd80709]*/

/*[clinic input]
_pickle.Pickler.dump

    obj: 'O'
        The object to be pickled.
    /

Write a pickled representation of obj to the open file.
[clinic start generated code]*/

PyDoc_STRVAR(__pickle_Pickler_dump__doc__,
"Write a pickled representation of obj to the open file.\n"
"\n"
...
static PyObject *
_pickle_Pickler_dump_impl(PicklerObject *self, PyObject *obj)
/*[clinic end generated code: checksum=3bd30745bf206a48f8b576a1da3d90f55a0a4187]*/
{
    /* Check whether the Pickler was initialized correctly (issue3664).
       Developers often forget to call __init__() in their subclasses, which
       would trigger a segfault without this check. */
    if (self-&gt;write == NULL) {
        PyErr_Format(PicklingError,
                     "Pickler.__init__() was not called by %s.__init__()",
                     Py_TYPE(self)-&gt;tp_name);
        return NULL;
    }

    if (_Pickler_ClearBuffer(self) &lt; 0) {
        return NULL;
    }

    ...
</pre> <p>Remember the macro with the <a class="reference internal" href="../c-api/structures#c.PyMethodDef" title="PyMethodDef"><code>PyMethodDef</code></a> structure for this function? Find the existing <code>PyMethodDef</code> structure for this function and replace it with a reference to the macro. If the builtin is at module scope, this will probably be very near the end of the file; if the builtin is a class method, this will probably be below but relatively near to the implementation.</p> <p>Note that the body of the macro contains a trailing comma; when you replace the existing static <code>PyMethodDef</code> structure with the macro, <em>don’t</em> add a comma to the end.</p> <p>Sample:</p> <pre data-language="c">static struct PyMethodDef Pickler_methods[] = {
    __PICKLE_PICKLER_DUMP_METHODDEF
    __PICKLE_PICKLER_CLEAR_MEMO_METHODDEF
    {NULL, NULL}                /* sentinel */
};
</pre> <p>Argument Clinic may generate new instances of <code>_Py_ID</code>. For example:</p> <pre data-language="c">&amp;_Py_ID(new_unique_py_id)
</pre> <p>If it does, you’ll have to run <code>make regen-global-objects</code> to regenerate the list of precompiled identifiers at this point.</p> <p>Finally, compile, then run the relevant portions of the regression-test suite. This change should not introduce any new compile-time warnings or errors, and there should be no externally visible change to Python’s behavior, except for one difference: <a class="reference internal" href="../library/inspect#inspect.signature" title="inspect.signature"><code>inspect.signature()</code></a> run on your function should now provide a valid signature!</p> <p>Congratulations, you’ve ported your first function to work with Argument Clinic!</p> </section> <section id="how-to-guides"> <h2 id="clinic-howtos">How-to guides</h2> <section id="how-to-rename-c-functions-and-variables-generated-by-argument-clinic"> <h3>How to rename C functions and variables generated by Argument Clinic</h3> <p>Argument Clinic automatically names the functions it generates for you. Occasionally this may cause a problem, if the generated name collides with the name of an existing C function. There’s an easy solution: override the names used for the C functions. Just add the keyword <code>"as"</code> to your function declaration line, followed by the function name you wish to use. Argument Clinic will use that function name for the base (generated) function, then add <code>"_impl"</code> to the end and use that for the name of the impl function.</p> <p>For example, if we wanted to rename the C function names generated for <a class="reference internal" href="../library/pickle#pickle.Pickler.dump" title="pickle.Pickler.dump"><code>pickle.Pickler.dump()</code></a>, it’d look like this:</p> <pre data-language="c">/*[clinic input]
pickle.Pickler.dump as pickler_dumper

...
</pre> <p>The base function would now be named <code>pickler_dumper()</code>, and the impl function would now be named <code>pickler_dumper_impl()</code>.</p> <p>Similarly, you may have a problem where you want to give a parameter a specific Python name, but that name may be inconvenient in C. Argument Clinic allows you to give a parameter different names in Python and in C, using the same <code>"as"</code> syntax:</p> <pre data-language="c">/*[clinic input]
pickle.Pickler.dump

    obj: object
    file as file_obj: object
    protocol: object = NULL
    *
    fix_imports: bool = True
</pre> <p>Here, the name used in Python (in the signature and the <code>keywords</code> array) would be <em>file</em>, but the C variable would be named <code>file_obj</code>.</p> <p>You can use this to rename the <em>self</em> parameter too!</p> </section> <section id="how-to-convert-functions-using-pyarg-unpacktuple"> <h3>How to convert functions using <code>PyArg_UnpackTuple</code>
</h3> <p>To convert a function parsing its arguments with <a class="reference internal" href="../c-api/arg#c.PyArg_UnpackTuple" title="PyArg_UnpackTuple"><code>PyArg_UnpackTuple()</code></a>, simply write out all the arguments, specifying each as an <code>object</code>. You may specify the <em>type</em> argument to cast the type as appropriate. All arguments should be marked positional-only (add a <code>/</code> on a line by itself after the last argument).</p> <p>Currently the generated code will use <a class="reference internal" href="../c-api/arg#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code>PyArg_ParseTuple()</code></a>, but this will change soon.</p> </section> <section id="how-to-use-optional-groups"> <h3>How to use optional groups</h3> <p>Some legacy functions have a tricky approach to parsing their arguments: they count the number of positional arguments, then use a <code>switch</code> statement to call one of several different <a class="reference internal" href="../c-api/arg#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code>PyArg_ParseTuple()</code></a> calls depending on how many positional arguments there are. (These functions cannot accept keyword-only arguments.) This approach was used to simulate optional arguments back before <a class="reference internal" href="../c-api/arg#c.PyArg_ParseTupleAndKeywords" title="PyArg_ParseTupleAndKeywords"><code>PyArg_ParseTupleAndKeywords()</code></a> was created.</p> <p>While functions using this approach can often be converted to use <code>PyArg_ParseTupleAndKeywords()</code>, optional arguments, and default values, it’s not always possible. Some of these legacy functions have behaviors <code>PyArg_ParseTupleAndKeywords()</code> doesn’t directly support. The most obvious example is the builtin function <a class="reference internal" href="../library/stdtypes#range" title="range"><code>range()</code></a>, which has an optional argument on the <em>left</em> side of its required argument! Another example is <a class="reference internal" href="../library/curses#curses.window.addch" title="curses.window.addch"><code>curses.window.addch()</code></a>, which has a group of two arguments that must always be specified together. (The arguments are called <em>x</em> and <em>y</em>; if you call the function passing in <em>x</em>, you must also pass in <em>y</em> — and if you don’t pass in <em>x</em> you may not pass in <em>y</em> either.)</p> <p>In any case, the goal of Argument Clinic is to support argument parsing for all existing CPython builtins without changing their semantics. Therefore Argument Clinic supports this alternate approach to parsing, using what are called <em>optional groups</em>. Optional groups are groups of arguments that must all be passed in together. They can be to the left or the right of the required arguments. They can <em>only</em> be used with positional-only parameters.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Optional groups are <em>only</em> intended for use when converting functions that make multiple calls to <a class="reference internal" href="../c-api/arg#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code>PyArg_ParseTuple()</code></a>! Functions that use <em>any</em> other approach for parsing arguments should <em>almost never</em> be converted to Argument Clinic using optional groups. Functions using optional groups currently cannot have accurate signatures in Python, because Python just doesn’t understand the concept. Please avoid using optional groups wherever possible.</p> </div> <p>To specify an optional group, add a <code>[</code> on a line by itself before the parameters you wish to group together, and a <code>]</code> on a line by itself after these parameters. As an example, here’s how <a class="reference internal" href="../library/curses#curses.window.addch" title="curses.window.addch"><code>curses.window.addch()</code></a> uses optional groups to make the first two parameters and the last parameter optional:</p> <pre data-language="c">/*[clinic input]

curses.window.addch

    [
    x: int
      X-coordinate.
    y: int
      Y-coordinate.
    ]

    ch: object
      Character to add.

    [
    attr: long
      Attributes for the character.
    ]
    /

...
</pre> <p>Notes:</p> <ul class="simple"> <li>For every optional group, one additional parameter will be passed into the impl function representing the group. The parameter will be an int named <code>group_{direction}_{number}</code>, where <code>{direction}</code> is either <code>right</code> or <code>left</code> depending on whether the group is before or after the required parameters, and <code>{number}</code> is a monotonically increasing number (starting at 1) indicating how far away the group is from the required parameters. When the impl is called, this parameter will be set to zero if this group was unused, and set to non-zero if this group was used. (By used or unused, I mean whether or not the parameters received arguments in this invocation.)</li> <li>If there are no required arguments, the optional groups will behave as if they’re to the right of the required arguments.</li> <li>In the case of ambiguity, the argument parsing code favors parameters on the left (before the required parameters).</li> <li>Optional groups can only contain positional-only parameters.</li> <li>Optional groups are <em>only</em> intended for legacy code. Please do not use optional groups for new code.</li> </ul> </section> <section id="how-to-use-real-argument-clinic-converters-instead-of-legacy-converters"> <h3>How to use real Argument Clinic converters, instead of “legacy converters”</h3> <p>To save time, and to minimize how much you need to learn to achieve your first port to Argument Clinic, the walkthrough above tells you to use “legacy converters”. “Legacy converters” are a convenience, designed explicitly to make porting existing code to Argument Clinic easier. And to be clear, their use is acceptable when porting code for Python 3.4.</p> <p>However, in the long term we probably want all our blocks to use Argument Clinic’s real syntax for converters. Why? A couple reasons:</p> <ul class="simple"> <li>The proper converters are far easier to read and clearer in their intent.</li> <li>There are some format units that are unsupported as “legacy converters”, because they require arguments, and the legacy converter syntax doesn’t support specifying arguments.</li> <li>In the future we may have a new argument parsing library that isn’t restricted to what <a class="reference internal" href="../c-api/arg#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code>PyArg_ParseTuple()</code></a> supports; this flexibility won’t be available to parameters using legacy converters.</li> </ul> <p>Therefore, if you don’t mind a little extra effort, please use the normal converters instead of legacy converters.</p> <p>In a nutshell, the syntax for Argument Clinic (non-legacy) converters looks like a Python function call. However, if there are no explicit arguments to the function (all functions take their default values), you may omit the parentheses. Thus <code>bool</code> and <code>bool()</code> are exactly the same converters.</p> <p>All arguments to Argument Clinic converters are keyword-only. All Argument Clinic converters accept the following arguments:</p>  <dl class="simple"> <dt><em>c_default</em></dt>
<dd>
<p>The default value for this parameter when defined in C. Specifically, this will be the initializer for the variable declared in the “parse function”. See <a class="reference internal" href="#default-values"><span class="std std-ref">the section on default values</span></a> for how to use this. Specified as a string.</p> </dd> <dt><em>annotation</em></dt>
<dd>
<p>The annotation value for this parameter. Not currently supported, because <a class="pep reference external" href="https://peps.python.org/pep-0008/" id="index-2"><strong>PEP 8</strong></a> mandates that the Python library may not use annotations.</p> </dd> <dt><em>unused</em></dt>
<dd>
<p>Wrap the argument with <a class="reference internal" href="../c-api/intro#c.Py_UNUSED" title="Py_UNUSED"><code>Py_UNUSED</code></a> in the impl function signature.</p> </dd> </dl>  <p>In addition, some converters accept additional arguments. Here is a list of these arguments, along with their meanings:</p>  <dl> <dt><em>accept</em></dt>
<dd>
<p>A set of Python types (and possibly pseudo-types); this restricts the allowable Python argument to values of these types. (This is not a general-purpose facility; as a rule it only supports specific lists of types as shown in the legacy converter table.)</p> <p>To accept <code>None</code>, add <code>NoneType</code> to this set.</p> </dd> <dt><em>bitwise</em></dt>
<dd>
<p>Only supported for unsigned integers. The native integer value of this Python argument will be written to the parameter without any range checking, even for negative values.</p> </dd> <dt><em>converter</em></dt>
<dd>
<p>Only supported by the <code>object</code> converter. Specifies the name of a <a class="reference internal" href="../c-api/arg#o-ampersand"><span class="std std-ref">C “converter function”</span></a> to use to convert this object to a native type.</p> </dd> <dt><em>encoding</em></dt>
<dd>
<p>Only supported for strings. Specifies the encoding to use when converting this string from a Python str (Unicode) value into a C <code>char *</code> value.</p> </dd> <dt><em>subclass_of</em></dt>
<dd>
<p>Only supported for the <code>object</code> converter. Requires that the Python value be a subclass of a Python type, as expressed in C.</p> </dd> <dt><em>type</em></dt>
<dd>
<p>Only supported for the <code>object</code> and <code>self</code> converters. Specifies the C type that will be used to declare the variable. Default value is <code>"PyObject *"</code>.</p> </dd> <dt><em>zeroes</em></dt>
<dd>
<p>Only supported for strings. If true, embedded NUL bytes (<code>'\\0'</code>) are permitted inside the value. The length of the string will be passed in to the impl function, just after the string parameter, as a parameter named <code>&lt;parameter_name&gt;_length</code>.</p> </dd> </dl>  <p>Please note, not every possible combination of arguments will work. Usually these arguments are implemented by specific <a class="reference internal" href="../c-api/arg#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code>PyArg_ParseTuple()</code></a> <em>format units</em>, with specific behavior. For example, currently you cannot call <code>unsigned_short</code> without also specifying <code>bitwise=True</code>. Although it’s perfectly reasonable to think this would work, these semantics don’t map to any existing format unit. So Argument Clinic doesn’t support it. (Or, at least, not yet.)</p> <p>Below is a table showing the mapping of legacy converters into real Argument Clinic converters. On the left is the legacy converter, on the right is the text you’d replace it with.</p> <table class="docutils align-default">   <tr>
<td><p><code>'B'</code></p></td> <td><p><code>unsigned_char(bitwise=True)</code></p></td> </tr> <tr>
<td><p><code>'b'</code></p></td> <td><p><code>unsigned_char</code></p></td> </tr> <tr>
<td><p><code>'c'</code></p></td> <td><p><code>char</code></p></td> </tr> <tr>
<td><p><code>'C'</code></p></td> <td><p><code>int(accept={str})</code></p></td> </tr> <tr>
<td><p><code>'d'</code></p></td> <td><p><code>double</code></p></td> </tr> <tr>
<td><p><code>'D'</code></p></td> <td><p><code>Py_complex</code></p></td> </tr> <tr>
<td><p><code>'es'</code></p></td> <td><p><code>str(encoding='name_of_encoding')</code></p></td> </tr> <tr>
<td><p><code>'es#'</code></p></td> <td><p><code>str(encoding='name_of_encoding', zeroes=True)</code></p></td> </tr> <tr>
<td><p><code>'et'</code></p></td> <td><p><code>str(encoding='name_of_encoding', accept={bytes, bytearray, str})</code></p></td> </tr> <tr>
<td><p><code>'et#'</code></p></td> <td><p><code>str(encoding='name_of_encoding', accept={bytes, bytearray, str}, zeroes=True)</code></p></td> </tr> <tr>
<td><p><code>'f'</code></p></td> <td><p><code>float</code></p></td> </tr> <tr>
<td><p><code>'h'</code></p></td> <td><p><code>short</code></p></td> </tr> <tr>
<td><p><code>'H'</code></p></td> <td><p><code>unsigned_short(bitwise=True)</code></p></td> </tr> <tr>
<td><p><code>'i'</code></p></td> <td><p><code>int</code></p></td> </tr> <tr>
<td><p><code>'I'</code></p></td> <td><p><code>unsigned_int(bitwise=True)</code></p></td> </tr> <tr>
<td><p><code>'k'</code></p></td> <td><p><code>unsigned_long(bitwise=True)</code></p></td> </tr> <tr>
<td><p><code>'K'</code></p></td> <td><p><code>unsigned_long_long(bitwise=True)</code></p></td> </tr> <tr>
<td><p><code>'l'</code></p></td> <td><p><code>long</code></p></td> </tr> <tr>
<td><p><code>'L'</code></p></td> <td><p><code>long long</code></p></td> </tr> <tr>
<td><p><code>'n'</code></p></td> <td><p><code>Py_ssize_t</code></p></td> </tr> <tr>
<td><p><code>'O'</code></p></td> <td><p><code>object</code></p></td> </tr> <tr>
<td><p><code>'O!'</code></p></td> <td><p><code>object(subclass_of='&amp;PySomething_Type')</code></p></td> </tr> <tr>
<td><p><code>'O&amp;'</code></p></td> <td><p><code>object(converter='name_of_c_function')</code></p></td> </tr> <tr>
<td><p><code>'p'</code></p></td> <td><p><code>bool</code></p></td> </tr> <tr>
<td><p><code>'S'</code></p></td> <td><p><code>PyBytesObject</code></p></td> </tr> <tr>
<td><p><code>'s'</code></p></td> <td><p><code>str</code></p></td> </tr> <tr>
<td><p><code>'s#'</code></p></td> <td><p><code>str(zeroes=True)</code></p></td> </tr> <tr>
<td><p><code>'s*'</code></p></td> <td><p><code>Py_buffer(accept={buffer, str})</code></p></td> </tr> <tr>
<td><p><code>'U'</code></p></td> <td><p><code>unicode</code></p></td> </tr> <tr>
<td><p><code>'u'</code></p></td> <td><p><code>wchar_t</code></p></td> </tr> <tr>
<td><p><code>'u#'</code></p></td> <td><p><code>wchar_t(zeroes=True)</code></p></td> </tr> <tr>
<td><p><code>'w*'</code></p></td> <td><p><code>Py_buffer(accept={rwbuffer})</code></p></td> </tr> <tr>
<td><p><code>'Y'</code></p></td> <td><p><code>PyByteArrayObject</code></p></td> </tr> <tr>
<td><p><code>'y'</code></p></td> <td><p><code>str(accept={bytes})</code></p></td> </tr> <tr>
<td><p><code>'y#'</code></p></td> <td><p><code>str(accept={robuffer}, zeroes=True)</code></p></td> </tr> <tr>
<td><p><code>'y*'</code></p></td> <td><p><code>Py_buffer</code></p></td> </tr> <tr>
<td><p><code>'Z'</code></p></td> <td><p><code>wchar_t(accept={str, NoneType})</code></p></td> </tr> <tr>
<td><p><code>'Z#'</code></p></td> <td><p><code>wchar_t(accept={str, NoneType}, zeroes=True)</code></p></td> </tr> <tr>
<td><p><code>'z'</code></p></td> <td><p><code>str(accept={str, NoneType})</code></p></td> </tr> <tr>
<td><p><code>'z#'</code></p></td> <td><p><code>str(accept={str, NoneType}, zeroes=True)</code></p></td> </tr> <tr>
<td><p><code>'z*'</code></p></td> <td><p><code>Py_buffer(accept={buffer, str, NoneType})</code></p></td> </tr>  </table> <p>As an example, here’s our sample <code>pickle.Pickler.dump</code> using the proper converter:</p> <pre data-language="c">/*[clinic input]
pickle.Pickler.dump

    obj: object
        The object to be pickled.
    /

Write a pickled representation of obj to the open file.
[clinic start generated code]*/
</pre> <p>One advantage of real converters is that they’re more flexible than legacy converters. For example, the <code>unsigned_int</code> converter (and all the <code>unsigned_</code> converters) can be specified without <code>bitwise=True</code>. Their default behavior performs range checking on the value, and they won’t accept negative numbers. You just can’t do that with a legacy converter!</p> <p>Argument Clinic will show you all the converters it has available. For each converter it’ll show you all the parameters it accepts, along with the default value for each parameter. Just run <code>Tools/clinic/clinic.py --converters</code> to see the full list.</p> </section> <section id="how-to-use-the-py-buffer-converter"> <h3>How to use the <code>Py_buffer</code> converter</h3> <p>When using the <code>Py_buffer</code> converter (or the <code>'s*'</code>, <code>'w*'</code>, <code>'*y'</code>, or <code>'z*'</code> legacy converters), you <em>must</em> not call <a class="reference internal" href="../c-api/buffer#c.PyBuffer_Release" title="PyBuffer_Release"><code>PyBuffer_Release()</code></a> on the provided buffer. Argument Clinic generates code that does it for you (in the parsing function).</p> </section> <section id="how-to-use-advanced-converters"> <h3 id="clinic-howto-advanced-converters">How to use advanced converters</h3> <p>Remember those format units you skipped for your first time because they were advanced? Here’s how to handle those too.</p> <p>The trick is, all those format units take arguments—either conversion functions, or types, or strings specifying an encoding. (But “legacy converters” don’t support arguments. That’s why we skipped them for your first function.) The argument you specified to the format unit is now an argument to the converter; this argument is either <em>converter</em> (for <code>O&amp;</code>), <em>subclass_of</em> (for <code>O!</code>), or <em>encoding</em> (for all the format units that start with <code>e</code>).</p> <p>When using <em>subclass_of</em>, you may also want to use the other custom argument for <code>object()</code>: <em>type</em>, which lets you set the type actually used for the parameter. For example, if you want to ensure that the object is a subclass of <a class="reference internal" href="../c-api/unicode#c.PyUnicode_Type" title="PyUnicode_Type"><code>PyUnicode_Type</code></a>, you probably want to use the converter <code>object(type='PyUnicodeObject *', subclass_of='&amp;PyUnicode_Type')</code>.</p> <p>One possible problem with using Argument Clinic: it takes away some possible flexibility for the format units starting with <code>e</code>. When writing a <code>PyArg_Parse*()</code> call by hand, you could theoretically decide at runtime what encoding string to pass to that call. But now this string must be hard-coded at Argument-Clinic-preprocessing-time. This limitation is deliberate; it made supporting this format unit much easier, and may allow for future optimizations. This restriction doesn’t seem unreasonable; CPython itself always passes in static hard-coded encoding strings for parameters whose format units start with <code>e</code>.</p> </section> <section id="how-to-assign-default-values-to-parameter"> <h3 id="clinic-howto-default-values">How to assign default values to parameter</h3> <p>Default values for parameters can be any of a number of values. At their simplest, they can be string, int, or float literals:</p> <pre data-language="none">foo: str = "abc"
bar: int = 123
bat: float = 45.6
</pre> <p>They can also use any of Python’s built-in constants:</p> <pre data-language="none">yep:  bool = True
nope: bool = False
nada: object = None
</pre> <p>There’s also special support for a default value of <code>NULL</code>, and for simple expressions, documented in the following sections.</p> <section id="the-null-default-value"> <h4>The <code>NULL</code> default value</h4> <p>For string and object parameters, you can set them to <code>None</code> to indicate that there’s no default. However, that means the C variable will be initialized to <code>Py_None</code>. For convenience’s sakes, there’s a special value called <code>NULL</code> for just this reason: from Python’s perspective it behaves like a default value of <code>None</code>, but the C variable is initialized with <code>NULL</code>.</p> </section> <section id="symbolic-default-values"> <h4>Symbolic default values</h4> <p>The default value you provide for a parameter can’t be any arbitrary expression. Currently the following are explicitly supported:</p> <ul class="simple"> <li>Numeric constants (integer and float)</li> <li>String constants</li> <li>
<code>True</code>, <code>False</code>, and <code>None</code>
</li> <li>Simple symbolic constants like <a class="reference internal" href="../library/sys#sys.maxsize" title="sys.maxsize"><code>sys.maxsize</code></a>, which must start with the name of the module</li> </ul> <p>(In the future, this may need to get even more elaborate, to allow full expressions like <code>CONSTANT - 1</code>.)</p> </section> <section id="expressions-as-default-values"> <h4>Expressions as default values</h4> <p>The default value for a parameter can be more than just a literal value. It can be an entire expression, using math operators and looking up attributes on objects. However, this support isn’t exactly simple, because of some non-obvious semantics.</p> <p>Consider the following example:</p> <pre data-language="none">foo: Py_ssize_t = sys.maxsize - 1
</pre> <p><a class="reference internal" href="../library/sys#sys.maxsize" title="sys.maxsize"><code>sys.maxsize</code></a> can have different values on different platforms. Therefore Argument Clinic can’t simply evaluate that expression locally and hard-code it in C. So it stores the default in such a way that it will get evaluated at runtime, when the user asks for the function’s signature.</p> <p>What namespace is available when the expression is evaluated? It’s evaluated in the context of the module the builtin came from. So, if your module has an attribute called <code>max_widgets</code>, you may simply use it:</p> <pre data-language="none">foo: Py_ssize_t = max_widgets
</pre> <p>If the symbol isn’t found in the current module, it fails over to looking in <a class="reference internal" href="../library/sys#sys.modules" title="sys.modules"><code>sys.modules</code></a>. That’s how it can find <a class="reference internal" href="../library/sys#sys.maxsize" title="sys.maxsize"><code>sys.maxsize</code></a> for example. (Since you don’t know in advance what modules the user will load into their interpreter, it’s best to restrict yourself to modules that are preloaded by Python itself.)</p> <p>Evaluating default values only at runtime means Argument Clinic can’t compute the correct equivalent C default value. So you need to tell it explicitly. When you use an expression, you must also specify the equivalent expression in C, using the <em>c_default</em> parameter to the converter:</p> <pre data-language="none">foo: Py_ssize_t(c_default="PY_SSIZE_T_MAX - 1") = sys.maxsize - 1
</pre> <p>Another complication: Argument Clinic can’t know in advance whether or not the expression you supply is valid. It parses it to make sure it looks legal, but it can’t <em>actually</em> know. You must be very careful when using expressions to specify values that are guaranteed to be valid at runtime!</p> <p>Finally, because expressions must be representable as static C values, there are many restrictions on legal expressions. Here’s a list of Python features you’re not permitted to use:</p> <ul class="simple"> <li>Function calls.</li> <li>Inline if statements (<code>3 if foo else 5</code>).</li> <li>Automatic sequence unpacking (<code>*[1, 2, 3]</code>).</li> <li>List/set/dict comprehensions and generator expressions.</li> <li>Tuple/list/set/dict literals.</li> </ul> </section> </section> <section id="how-to-use-return-converters"> <h3 id="clinic-howto-return-converters">How to use return converters</h3> <p>By default, the impl function Argument Clinic generates for you returns <a class="reference internal" href="../c-api/structures#c.PyObject" title="PyObject"><code>PyObject *</code></a>. But your C function often computes some C type, then converts it into the <code>PyObject *</code> at the last moment. Argument Clinic handles converting your inputs from Python types into native C types—why not have it convert your return value from a native C type into a Python type too?</p> <p>That’s what a “return converter” does. It changes your impl function to return some C type, then adds code to the generated (non-impl) function to handle converting that value into the appropriate <code>PyObject *</code>.</p> <p>The syntax for return converters is similar to that of parameter converters. You specify the return converter like it was a return annotation on the function itself, using <code>-&gt;</code> notation.</p> <p>For example:</p> <pre data-language="c">/*[clinic input]
add -&gt; int

    a: int
    b: int
    /

[clinic start generated code]*/
</pre> <p>Return converters behave much the same as parameter converters; they take arguments, the arguments are all keyword-only, and if you’re not changing any of the default arguments you can omit the parentheses.</p> <p>(If you use both <code>"as"</code> <em>and</em> a return converter for your function, the <code>"as"</code> should come before the return converter.)</p> <p>There’s one additional complication when using return converters: how do you indicate an error has occurred? Normally, a function returns a valid (non-<code>NULL</code>) pointer for success, and <code>NULL</code> for failure. But if you use an integer return converter, all integers are valid. How can Argument Clinic detect an error? Its solution: each return converter implicitly looks for a special value that indicates an error. If you return that value, and an error has been set (c:func:<code>PyErr_Occurred</code> returns a true value), then the generated code will propagate the error. Otherwise it will encode the value you return like normal.</p> <p>Currently Argument Clinic supports only a few return converters:</p> <pre data-language="none">bool
double
float
int
long
Py_ssize_t
size_t
unsigned int
unsigned long
</pre> <p>None of these take parameters. For all of these, return <code>-1</code> to indicate error.</p> <p>To see all the return converters Argument Clinic supports, along with their parameters (if any), just run <code>Tools/clinic/clinic.py --converters</code> for the full list.</p> </section> <section id="how-to-clone-existing-functions"> <h3>How to clone existing functions</h3> <p>If you have a number of functions that look similar, you may be able to use Clinic’s “clone” feature. When you clone an existing function, you reuse:</p> <ul class="simple"> <li>
<p>its parameters, including</p> <ul> <li>their names,</li> <li>their converters, with all parameters,</li> <li>their default values,</li> <li>their per-parameter docstrings,</li> <li>their <em>kind</em> (whether they’re positional only, positional or keyword, or keyword only), and</li> </ul> </li> <li>its return converter.</li> </ul> <p>The only thing not copied from the original function is its docstring; the syntax allows you to specify a new docstring.</p> <p>Here’s the syntax for cloning a function:</p> <pre data-language="c">/*[clinic input]
module.class.new_function [as c_basename] = module.class.existing_function

Docstring for new_function goes here.
[clinic start generated code]*/
</pre> <p>(The functions can be in different modules or classes. I wrote <code>module.class</code> in the sample just to illustrate that you must use the full path to <em>both</em> functions.)</p> <p>Sorry, there’s no syntax for partially cloning a function, or cloning a function then modifying it. Cloning is an all-or nothing proposition.</p> <p>Also, the function you are cloning from must have been previously defined in the current file.</p> </section> <section id="how-to-call-python-code"> <h3>How to call Python code</h3> <p>The rest of the advanced topics require you to write Python code which lives inside your C file and modifies Argument Clinic’s runtime state. This is simple: you simply define a Python block.</p> <p>A Python block uses different delimiter lines than an Argument Clinic function block. It looks like this:</p> <pre data-language="c">/*[python input]
# python code goes here
[python start generated code]*/
</pre> <p>All the code inside the Python block is executed at the time it’s parsed. All text written to stdout inside the block is redirected into the “output” after the block.</p> <p>As an example, here’s a Python block that adds a static integer variable to the C code:</p> <pre data-language="c">/*[python input]
print('static int __ignored_unused_variable__ = 0;')
[python start generated code]*/
static int __ignored_unused_variable__ = 0;
/*[python checksum:...]*/
</pre> </section> <section id="how-to-use-the-self-converter"> <h3 id="clinic-howto-self-converter">How to use the “self converter”</h3> <p>Argument Clinic automatically adds a “self” parameter for you using a default converter. It automatically sets the <code>type</code> of this parameter to the “pointer to an instance” you specified when you declared the type. However, you can override Argument Clinic’s converter and specify one yourself. Just add your own <em>self</em> parameter as the first parameter in a block, and ensure that its converter is an instance of <code>self_converter</code> or a subclass thereof.</p> <p>What’s the point? This lets you override the type of <code>self</code>, or give it a different default name.</p> <p>How do you specify the custom type you want to cast <code>self</code> to? If you only have one or two functions with the same type for <code>self</code>, you can directly use Argument Clinic’s existing <code>self</code> converter, passing in the type you want to use as the <em>type</em> parameter:</p> <pre data-language="c">/*[clinic input]

_pickle.Pickler.dump

  self: self(type="PicklerObject *")
  obj: object
  /

Write a pickled representation of the given object to the open file.
[clinic start generated code]*/
</pre> <p>On the other hand, if you have a lot of functions that will use the same type for <code>self</code>, it’s best to create your own converter, subclassing <code>self_converter</code> but overwriting the <code>type</code> member:</p> <pre data-language="c">/*[python input]
class PicklerObject_converter(self_converter):
    type = "PicklerObject *"
[python start generated code]*/

/*[clinic input]

_pickle.Pickler.dump

  self: PicklerObject
  obj: object
  /

Write a pickled representation of the given object to the open file.
[clinic start generated code]*/
</pre> </section> <section id="how-to-use-the-defining-class-converter"> <h3>How to use the “defining class” converter</h3> <p>Argument Clinic facilitates gaining access to the defining class of a method. This is useful for <a class="reference internal" href="../c-api/typeobj#heap-types"><span class="std std-ref">heap type</span></a> methods that need to fetch module level state. Use <a class="reference internal" href="../c-api/type#c.PyType_FromModuleAndSpec" title="PyType_FromModuleAndSpec"><code>PyType_FromModuleAndSpec()</code></a> to associate a new heap type with a module. You can now use <a class="reference internal" href="../c-api/type#c.PyType_GetModuleState" title="PyType_GetModuleState"><code>PyType_GetModuleState()</code></a> on the defining class to fetch the module state, for example from a module method.</p> <p>Example from <a class="reference external" href="https://github.com/python/cpython/tree/3.12/Modules/zlibmodule.c">Modules/zlibmodule.c</a>. First, <code>defining_class</code> is added to the clinic input:</p> <pre data-language="c">/*[clinic input]
zlib.Compress.compress

  cls: defining_class
  data: Py_buffer
    Binary data to be compressed.
  /
</pre> <p>After running the Argument Clinic tool, the following function signature is generated:</p> <pre data-language="c">/*[clinic start generated code]*/
static PyObject *
zlib_Compress_compress_impl(compobject *self, PyTypeObject *cls,
                            Py_buffer *data)
/*[clinic end generated code: output=6731b3f0ff357ca6 input=04d00f65ab01d260]*/
</pre> <p>The following code can now use <code>PyType_GetModuleState(cls)</code> to fetch the module state:</p> <pre data-language="c">zlibstate *state = PyType_GetModuleState(cls);
</pre> <p>Each method may only have one argument using this converter, and it must appear after <code>self</code>, or, if <code>self</code> is not used, as the first argument. The argument will be of type <code>PyTypeObject *</code>. The argument will not appear in the <code>__text_signature__</code>.</p> <p>The <code>defining_class</code> converter is not compatible with <code>__init__()</code> and <code>__new__()</code> methods, which cannot use the <a class="reference internal" href="../c-api/structures#c.METH_METHOD" title="METH_METHOD"><code>METH_METHOD</code></a> convention.</p> <p>It is not possible to use <code>defining_class</code> with slot methods. In order to fetch the module state from such methods, use <a class="reference internal" href="../c-api/type#c.PyType_GetModuleByDef" title="PyType_GetModuleByDef"><code>PyType_GetModuleByDef()</code></a> to look up the module and then <a class="reference internal" href="../c-api/module#c.PyModule_GetState" title="PyModule_GetState"><code>PyModule_GetState()</code></a> to fetch the module state. Example from the <code>setattro</code> slot method in <a class="reference external" href="https://github.com/python/cpython/tree/3.12/Modules/_threadmodule.c">Modules/_threadmodule.c</a>:</p> <pre data-language="c">static int
local_setattro(localobject *self, PyObject *name, PyObject *v)
{
    PyObject *module = PyType_GetModuleByDef(Py_TYPE(self), &amp;thread_module);
    thread_module_state *state = get_thread_state(module);
    ...
}
</pre> <p>See also <a class="pep reference external" href="https://peps.python.org/pep-0573/" id="index-3"><strong>PEP 573</strong></a>.</p> </section> <section id="how-to-write-a-custom-converter"> <h3 id="clinic-howto-custom-converter">How to write a custom converter</h3> <p>A converter is a Python class that inherits from <a class="reference internal" href="#clinic.CConverter" title="clinic.CConverter"><code>CConverter</code></a>. The main purpose of a custom converter, is for parameters parsed with the <code>O&amp;</code> format unit — parsing such a parameter means calling a <a class="reference internal" href="../c-api/arg#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code>PyArg_ParseTuple()</code></a> “converter function”.</p> <p>Your converter class should be named <code><em>ConverterName</em>_converter</code>. By following this convention, your converter class will be automatically registered with Argument Clinic, with its <em>converter name</em> being the name of your converter class with the <code>_converter</code> suffix stripped off.</p> <p>Instead of subclassing <code>CConverter.__init__()</code>, write a <code>converter_init()</code> method. <code>converter_init()</code> always accepts a <em>self</em> parameter. After <em>self</em>, all additional parameters <strong>must</strong> be keyword-only. Any arguments passed to the converter in Argument Clinic will be passed along to your <code>converter_init()</code> method. See <a class="reference internal" href="#clinic.CConverter" title="clinic.CConverter"><code>CConverter</code></a> for a list of members you may wish to specify in your subclass.</p> <p>Here’s the simplest example of a custom converter, from <a class="reference external" href="https://github.com/python/cpython/tree/3.12/Modules/zlibmodule.c">Modules/zlibmodule.c</a>:</p> <pre data-language="c">/*[python input]

class ssize_t_converter(CConverter):
    type = 'Py_ssize_t'
    converter = 'ssize_t_converter'

[python start generated code]*/
/*[python end generated code: output=da39a3ee5e6b4b0d input=35521e4e733823c7]*/
</pre> <p>This block adds a converter named <code>ssize_t</code> to Argument Clinic. Parameters declared as <code>ssize_t</code> will be declared with type <a class="reference internal" href="../c-api/intro#c.Py_ssize_t" title="Py_ssize_t"><code>Py_ssize_t</code></a>, and will be parsed by the <code>'O&amp;'</code> format unit, which will call the <code>ssize_t_converter()</code> converter C function. <code>ssize_t</code> variables automatically support default values.</p> <p>More sophisticated custom converters can insert custom C code to handle initialization and cleanup. You can see more examples of custom converters in the CPython source tree; grep the C files for the string <code>CConverter</code>.</p> </section> <section id="how-to-write-a-custom-return-converter"> <h3>How to write a custom return converter</h3> <p>Writing a custom return converter is much like writing a custom converter. Except it’s somewhat simpler, because return converters are themselves much simpler.</p> <p>Return converters must subclass <code>CReturnConverter</code>. There are no examples yet of custom return converters, because they are not widely used yet. If you wish to write your own return converter, please read <a class="reference external" href="https://github.com/python/cpython/tree/3.12/Tools/clinic/clinic.py">Tools/clinic/clinic.py</a>, specifically the implementation of <code>CReturnConverter</code> and all its subclasses.</p> </section> <section id="how-to-convert-meth-o-and-meth-noargs-functions"> <h3>How to convert <code>METH_O</code> and <code>METH_NOARGS</code> functions</h3> <p>To convert a function using <a class="reference internal" href="../c-api/structures#c.METH_O" title="METH_O"><code>METH_O</code></a>, make sure the function’s single argument is using the <code>object</code> converter, and mark the arguments as positional-only:</p> <pre data-language="c">/*[clinic input]
meth_o_sample

     argument: object
     /
[clinic start generated code]*/
</pre> <p>To convert a function using <a class="reference internal" href="../c-api/structures#c.METH_NOARGS" title="METH_NOARGS"><code>METH_NOARGS</code></a>, just don’t specify any arguments.</p> <p>You can still use a self converter, a return converter, and specify a <em>type</em> argument to the object converter for <a class="reference internal" href="../c-api/structures#c.METH_O" title="METH_O"><code>METH_O</code></a>.</p> </section> <section id="how-to-convert-tp-new-and-tp-init-functions"> <h3>How to convert <code>tp_new</code> and <code>tp_init</code> functions</h3> <p>You can convert <a class="reference internal" href="../c-api/typeobj#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code>tp_new</code></a> and <a class="reference internal" href="../c-api/typeobj#c.PyTypeObject.tp_init" title="PyTypeObject.tp_init"><code>tp_init</code></a> functions. Just name them <code>__new__</code> or <code>__init__</code> as appropriate. Notes:</p> <ul class="simple"> <li>The function name generated for <code>__new__</code> doesn’t end in <code>__new__</code> like it would by default. It’s just the name of the class, converted into a valid C identifier.</li> <li>No <a class="reference internal" href="../c-api/structures#c.PyMethodDef" title="PyMethodDef"><code>PyMethodDef</code></a> <code>#define</code> is generated for these functions.</li> <li>
<code>__init__</code> functions return <code>int</code>, not <code>PyObject *</code>.</li> <li>Use the docstring as the class docstring.</li> <li>Although <code>__new__</code> and <code>__init__</code> functions must always accept both the <code>args</code> and <code>kwargs</code> objects, when converting you may specify any signature for these functions that you like. (If your function doesn’t support keywords, the parsing function generated will throw an exception if it receives any.)</li> </ul> </section> <section id="how-to-change-and-redirect-clinic-s-output"> <h3>How to change and redirect Clinic’s output</h3> <p>It can be inconvenient to have Clinic’s output interspersed with your conventional hand-edited C code. Luckily, Clinic is configurable: you can buffer up its output for printing later (or earlier!), or write its output to a separate file. You can also add a prefix or suffix to every line of Clinic’s generated output.</p> <p>While changing Clinic’s output in this manner can be a boon to readability, it may result in Clinic code using types before they are defined, or your code attempting to use Clinic-generated code before it is defined. These problems can be easily solved by rearranging the declarations in your file, or moving where Clinic’s generated code goes. (This is why the default behavior of Clinic is to output everything into the current block; while many people consider this hampers readability, it will never require rearranging your code to fix definition-before-use problems.)</p> <p>Let’s start with defining some terminology:</p> <dl> <dt><em>field</em></dt>
<dd>
<p>A field, in this context, is a subsection of Clinic’s output. For example, the <code>#define</code> for the <a class="reference internal" href="../c-api/structures#c.PyMethodDef" title="PyMethodDef"><code>PyMethodDef</code></a> structure is a field, called <code>methoddef_define</code>. Clinic has seven different fields it can output per function definition:</p> <pre data-language="none">docstring_prototype
docstring_definition
methoddef_define
impl_prototype
parser_prototype
parser_definition
impl_definition
</pre> <p>All the names are of the form <code>"&lt;a&gt;_&lt;b&gt;"</code>, where <code>"&lt;a&gt;"</code> is the semantic object represented (the parsing function, the impl function, the docstring, or the methoddef structure) and <code>"&lt;b&gt;"</code> represents what kind of statement the field is. Field names that end in <code>"_prototype"</code> represent forward declarations of that thing, without the actual body/data of the thing; field names that end in <code>"_definition"</code> represent the actual definition of the thing, with the body/data of the thing. (<code>"methoddef"</code> is special, it’s the only one that ends with <code>"_define"</code>, representing that it’s a preprocessor #define.)</p> </dd> <dt><em>destination</em></dt>
<dd>
<p>A destination is a place Clinic can write output to. There are five built-in destinations:</p> <dl> <dt>
<code>block</code> </dt>
<dd>
<p>The default destination: printed in the output section of the current Clinic block.</p> </dd> <dt>
<code>buffer</code> </dt>
<dd>
<p>A text buffer where you can save text for later. Text sent here is appended to the end of any existing text. It’s an error to have any text left in the buffer when Clinic finishes processing a file.</p> </dd> <dt>
<code>file</code> </dt>
<dd>
<p>A separate “clinic file” that will be created automatically by Clinic. The filename chosen for the file is <code>{basename}.clinic{extension}</code>, where <code>basename</code> and <code>extension</code> were assigned the output from <code>os.path.splitext()</code> run on the current file. (Example: the <code>file</code> destination for <code>_pickle.c</code> would be written to <code>_pickle.clinic.c</code>.)</p> <p><strong>Important: When using a</strong> <code>file</code> <strong>destination, you</strong> <em>must check in</em> <strong>the generated file!</strong></p> </dd> <dt>
<code>two-pass</code> </dt>
<dd>
<p>A buffer like <code>buffer</code>. However, a two-pass buffer can only be dumped once, and it prints out all text sent to it during all processing, even from Clinic blocks <em>after</em> the dumping point.</p> </dd> <dt>
<code>suppress</code> </dt>
<dd>
<p>The text is suppressed—thrown away.</p> </dd> </dl> </dd> </dl> <p>Clinic defines five new directives that let you reconfigure its output.</p> <p>The first new directive is <code>dump</code>:</p> <pre data-language="none">dump &lt;destination&gt;
</pre> <p>This dumps the current contents of the named destination into the output of the current block, and empties it. This only works with <code>buffer</code> and <code>two-pass</code> destinations.</p> <p>The second new directive is <code>output</code>. The most basic form of <code>output</code> is like this:</p> <pre data-language="none">output &lt;field&gt; &lt;destination&gt;
</pre> <p>This tells Clinic to output <em>field</em> to <em>destination</em>. <code>output</code> also supports a special meta-destination, called <code>everything</code>, which tells Clinic to output <em>all</em> fields to that <em>destination</em>.</p> <p><code>output</code> has a number of other functions:</p> <pre data-language="none">output push
output pop
output preset &lt;preset&gt;
</pre> <p><code>output push</code> and <code>output pop</code> allow you to push and pop configurations on an internal configuration stack, so that you can temporarily modify the output configuration, then easily restore the previous configuration. Simply push before your change to save the current configuration, then pop when you wish to restore the previous configuration.</p> <p><code>output preset</code> sets Clinic’s output to one of several built-in preset configurations, as follows:</p>  <dl> <dt>
<code>block</code> </dt>
<dd>
<p>Clinic’s original starting configuration. Writes everything immediately after the input block.</p> <p>Suppress the <code>parser_prototype</code> and <code>docstring_prototype</code>, write everything else to <code>block</code>.</p> </dd> <dt>
<code>file</code> </dt>
<dd>
<p>Designed to write everything to the “clinic file” that it can. You then <code>#include</code> this file near the top of your file. You may need to rearrange your file to make this work, though usually this just means creating forward declarations for various <code>typedef</code> and <code>PyTypeObject</code> definitions.</p> <p>Suppress the <code>parser_prototype</code> and <code>docstring_prototype</code>, write the <code>impl_definition</code> to <code>block</code>, and write everything else to <code>file</code>.</p> <p>The default filename is <code>"{dirname}/clinic/{basename}.h"</code>.</p> </dd> <dt>
<code>buffer</code> </dt>
<dd>
<p>Save up most of the output from Clinic, to be written into your file near the end. For Python files implementing modules or builtin types, it’s recommended that you dump the buffer just above the static structures for your module or builtin type; these are normally very near the end. Using <code>buffer</code> may require even more editing than <code>file</code>, if your file has static <code>PyMethodDef</code> arrays defined in the middle of the file.</p> <p>Suppress the <code>parser_prototype</code>, <code>impl_prototype</code>, and <code>docstring_prototype</code>, write the <code>impl_definition</code> to <code>block</code>, and write everything else to <code>file</code>.</p> </dd> <dt>
<code>two-pass</code> </dt>
<dd>
<p>Similar to the <code>buffer</code> preset, but writes forward declarations to the <code>two-pass</code> buffer, and definitions to the <code>buffer</code>. This is similar to the <code>buffer</code> preset, but may require less editing than <code>buffer</code>. Dump the <code>two-pass</code> buffer near the top of your file, and dump the <code>buffer</code> near the end just like you would when using the <code>buffer</code> preset.</p> <p>Suppresses the <code>impl_prototype</code>, write the <code>impl_definition</code> to <code>block</code>, write <code>docstring_prototype</code>, <code>methoddef_define</code>, and <code>parser_prototype</code> to <code>two-pass</code>, write everything else to <code>buffer</code>.</p> </dd> <dt>
<code>partial-buffer</code> </dt>
<dd>
<p>Similar to the <code>buffer</code> preset, but writes more things to <code>block</code>, only writing the really big chunks of generated code to <code>buffer</code>. This avoids the definition-before-use problem of <code>buffer</code> completely, at the small cost of having slightly more stuff in the block’s output. Dump the <code>buffer</code> near the end, just like you would when using the <code>buffer</code> preset.</p> <p>Suppresses the <code>impl_prototype</code>, write the <code>docstring_definition</code> and <code>parser_definition</code> to <code>buffer</code>, write everything else to <code>block</code>.</p> </dd> </dl>  <p>The third new directive is <code>destination</code>:</p> <pre data-language="none">destination &lt;name&gt; &lt;command&gt; [...]
</pre> <p>This performs an operation on the destination named <code>name</code>.</p> <p>There are two defined subcommands: <code>new</code> and <code>clear</code>.</p> <p>The <code>new</code> subcommand works like this:</p> <pre data-language="none">destination &lt;name&gt; new &lt;type&gt;
</pre> <p>This creates a new destination with name <code>&lt;name&gt;</code> and type <code>&lt;type&gt;</code>.</p> <p>There are five destination types:</p>  <dl> <dt>
<code>suppress</code> </dt>
<dd>
<p>Throws the text away.</p> </dd> <dt>
<code>block</code> </dt>
<dd>
<p>Writes the text to the current block. This is what Clinic originally did.</p> </dd> <dt>
<code>buffer</code> </dt>
<dd>
<p>A simple text buffer, like the “buffer” builtin destination above.</p> </dd> <dt>
<code>file</code> </dt>
<dd>
<p>A text file. The file destination takes an extra argument, a template to use for building the filename, like so:</p>  <p>destination &lt;name&gt; new &lt;type&gt; &lt;file_template&gt;</p>  <p>The template can use three strings internally that will be replaced by bits of the filename:</p>  <dl class="simple"> <dt>{path}</dt>
<dd>
<p>The full path to the file, including directory and full filename.</p> </dd> <dt>{dirname}</dt>
<dd>
<p>The name of the directory the file is in.</p> </dd> <dt>{basename}</dt>
<dd>
<p>Just the name of the file, not including the directory.</p> </dd> <dt>{basename_root}</dt>
<dd>
<p>Basename with the extension clipped off (everything up to but not including the last ‘.’).</p> </dd> <dt>{basename_extension}</dt>
<dd>
<p>The last ‘.’ and everything after it. If the basename does not contain a period, this will be the empty string.</p> </dd> </dl>  <p>If there are no periods in the filename, {basename} and {filename} are the same, and {extension} is empty. “{basename}{extension}” is always exactly the same as “{filename}”.”</p> </dd> <dt>
<code>two-pass</code> </dt>
<dd>
<p>A two-pass buffer, like the “two-pass” builtin destination above.</p> </dd> </dl>  <p>The <code>clear</code> subcommand works like this:</p> <pre data-language="none">destination &lt;name&gt; clear
</pre> <p>It removes all the accumulated text up to this point in the destination. (I don’t know what you’d need this for, but I thought maybe it’d be useful while someone’s experimenting.)</p> <p>The fourth new directive is <code>set</code>:</p> <pre data-language="none">set line_prefix "string"
set line_suffix "string"
</pre> <p><code>set</code> lets you set two internal variables in Clinic. <code>line_prefix</code> is a string that will be prepended to every line of Clinic’s output; <code>line_suffix</code> is a string that will be appended to every line of Clinic’s output.</p> <p>Both of these support two format strings:</p>  <dl class="simple"> <dt>
<code>{block comment start}</code> </dt>
<dd>
<p>Turns into the string <code>/*</code>, the start-comment text sequence for C files.</p> </dd> <dt>
<code>{block comment end}</code> </dt>
<dd>
<p>Turns into the string <code>*/</code>, the end-comment text sequence for C files.</p> </dd> </dl>  <p>The final new directive is one you shouldn’t need to use directly, called <code>preserve</code>:</p> <pre data-language="none">preserve
</pre> <p>This tells Clinic that the current contents of the output should be kept, unmodified. This is used internally by Clinic when dumping output into <code>file</code> files; wrapping it in a Clinic block lets Clinic use its existing checksum functionality to ensure the file was not modified by hand before it gets overwritten.</p> </section> <section id="how-to-use-the-ifdef-trick"> <h3>How to use the <code>#ifdef</code> trick</h3> <p>If you’re converting a function that isn’t available on all platforms, there’s a trick you can use to make life a little easier. The existing code probably looks like this:</p> <pre data-language="c">#ifdef HAVE_FUNCTIONNAME
static module_functionname(...)
{
...
}
#endif /* HAVE_FUNCTIONNAME */
</pre> <p>And then in the <code>PyMethodDef</code> structure at the bottom the existing code will have:</p> <pre data-language="none">#ifdef HAVE_FUNCTIONNAME
{'functionname', ... },
#endif /* HAVE_FUNCTIONNAME */
</pre> <p>In this scenario, you should enclose the body of your impl function inside the <code>#ifdef</code>, like so:</p> <pre data-language="c">#ifdef HAVE_FUNCTIONNAME
/*[clinic input]
module.functionname
...
[clinic start generated code]*/
static module_functionname(...)
{
...
}
#endif /* HAVE_FUNCTIONNAME */
</pre> <p>Then, remove those three lines from the <a class="reference internal" href="../c-api/structures#c.PyMethodDef" title="PyMethodDef"><code>PyMethodDef</code></a> structure, replacing them with the macro Argument Clinic generated:</p> <pre data-language="none">MODULE_FUNCTIONNAME_METHODDEF
</pre> <p>(You can find the real name for this macro inside the generated code. Or you can calculate it yourself: it’s the name of your function as defined on the first line of your block, but with periods changed to underscores, uppercased, and <code>"_METHODDEF"</code> added to the end.)</p> <p>Perhaps you’re wondering: what if <code>HAVE_FUNCTIONNAME</code> isn’t defined? The <code>MODULE_FUNCTIONNAME_METHODDEF</code> macro won’t be defined either!</p> <p>Here’s where Argument Clinic gets very clever. It actually detects that the Argument Clinic block might be deactivated by the <code>#ifdef</code>. When that happens, it generates a little extra code that looks like this:</p> <pre data-language="c">#ifndef MODULE_FUNCTIONNAME_METHODDEF
    #define MODULE_FUNCTIONNAME_METHODDEF
#endif /* !defined(MODULE_FUNCTIONNAME_METHODDEF) */
</pre> <p>That means the macro always works. If the function is defined, this turns into the correct structure, including the trailing comma. If the function is undefined, this turns into nothing.</p> <p>However, this causes one ticklish problem: where should Argument Clinic put this extra code when using the “block” output preset? It can’t go in the output block, because that could be deactivated by the <code>#ifdef</code>. (That’s the whole point!)</p> <p>In this situation, Argument Clinic writes the extra code to the “buffer” destination. This may mean that you get a complaint from Argument Clinic:</p> <pre data-language="none">Warning in file "Modules/posixmodule.c" on line 12357:
Destination buffer 'buffer' not empty at end of file, emptying.
</pre> <p>When this happens, just open your file, find the <code>dump buffer</code> block that Argument Clinic added to your file (it’ll be at the very bottom), then move it above the <a class="reference internal" href="../c-api/structures#c.PyMethodDef" title="PyMethodDef"><code>PyMethodDef</code></a> structure where that macro is used.</p> </section> <section id="how-to-use-argument-clinic-in-python-files"> <h3>How to use Argument Clinic in Python files</h3> <p>It’s actually possible to use Argument Clinic to preprocess Python files. There’s no point to using Argument Clinic blocks, of course, as the output wouldn’t make any sense to the Python interpreter. But using Argument Clinic to run Python blocks lets you use Python as a Python preprocessor!</p> <p>Since Python comments are different from C comments, Argument Clinic blocks embedded in Python files look slightly different. They look like this:</p> <pre data-language="python">#/*[python input]
#print("def foo(): pass")
#[python start generated code]*/
def foo(): pass
#/*[python checksum:...]*/
</pre> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2001&ndash;2023 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/3.12/howto/clinic.html" class="_attribution-link">https://docs.python.org/3.12/howto/clinic.html</a>
  </p>
</div>
